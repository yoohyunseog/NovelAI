<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì†Œì„¤ êµ¬ì„± ìš”ì†Œ ê´€ë¦¬</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f5f5f5;
            padding: 0;
            margin: 0;
            width: 100%;
        }
        .main-container {
            width: 100%;
            margin: 0;
            padding: 0;
        }
        .card {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 0;
        }
        .attribute-item {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: white;
        }
        .attribute-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .attribute-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #007bff;
        }
        .bit-display {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
        }
        .data-item {
            background: #f8f9fa;
            padding: 10px;
            margin: 8px 0;
            border-left: 3px solid #28a745;
            border-radius: 4px;
        }
        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }
        .status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
        }
        .status-success {
            background-color: #d4edda;
            color: #155724;
        }
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .attribute-card {
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }
        .attribute-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
            border-color: #007bff !important;
        }
        .attribute-card:active {
            transform: translateY(0);
        }
        .attribute-item.highlighted {
            background-color: #fff3cd;
            border: 2px solid #ffc107;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
            animation: highlight-pulse 2s ease-in-out;
        }
        @keyframes highlight-pulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
            }
            50% {
                box-shadow: 0 0 25px rgba(255, 193, 7, 0.8);
            }
        }
        .log-container {
            width: 100%;
            background-color: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            border-top: 2px solid #333;
        }
        .log-entry {
            margin-bottom: 4px;
            padding: 2px 0;
            border-bottom: 1px solid #222;
        }
        .log-entry:first-child {
            border-top: 1px solid #333;
        }
        .log-time {
            color: #888;
            margin-right: 8px;
        }
        .log-message {
            color: #0f0;
        }
        .log-error {
            color: #f00;
        }
        .log-warn {
            color: #ff0;
        }
        .log-info {
            color: #0ff;
        }
        .log-entry {
            cursor: pointer;
        }
        .log-entry:hover {
            background-color: #1a1a1a;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1 class="mb-4 p-3">ğŸ“š ì†Œì„¤ êµ¬ì„± ìš”ì†Œ ê´€ë¦¬ (GPT ìë™ ì •ë¦¬)</h1>

        <div class="row g-0">
            <!-- ì¢Œì¸¡: ì†ì„± ëª©ë¡ ì„¹ì…˜ -->
            <div class="col-md-3">
                <div class="card h-100" style="border-radius: 0;">
                    <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">ğŸ“‹ ì €ì¥ëœ ì†ì„± ëª©ë¡</h5>
                        <button id="refreshBtn" class="btn btn-sm btn-light">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
                    </div>
                    <div class="card-body" style="max-height: calc(100vh - 200px); overflow-y: auto;">
                        <div id="attributesList"></div>
                    </div>
                </div>
            </div>

            <!-- ê°€ìš´ë°: GPT ë¶„ì„ ê²°ê³¼ -->
            <div class="col-md-6">
                <!-- GPT ë¶„ì„ ê²°ê³¼ -->
                <div class="card" id="gptResultCard" style="display: none; border-radius: 0;">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0">ğŸ“‹ GPT ë¶„ì„ ê²°ê³¼</h5>
                    </div>
                    <div class="card-body">
                        <div id="gptResponse" class="mb-3 p-3 bg-light rounded" style="white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></div>
                        <div id="extractedAttributes" class="mb-3"></div>
                    </div>
                </div>
            </div>

            <!-- ìš°ì¸¡: GPT ë¶„ì„ ì…ë ¥ ì„¹ì…˜ -->
            <div class="col-md-3">
                <!-- GPT ìë™ ë¶„ì„ ì„¹ì…˜ -->
                <div class="card h-100" style="border-radius: 0;">
                    <div class="card-header bg-gradient text-white" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        <h5 class="mb-0">ğŸ¤– GPT AI ìë™ ì†ì„± ì¶”ì¶œ</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">ë¶„ì„í•  í…ìŠ¤íŠ¸ ì…ë ¥</label>
                            <textarea 
                                id="gptInput" 
                                class="form-control" 
                                placeholder="ì†Œì„¤ ê´€ë ¨ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”. GPTê°€ ìë™ìœ¼ë¡œ ì†ì„±(ì†Œì„¤ êµ¬ì„± ìš”ì†Œ)ë“¤ì„ ì¶”ì¶œí•˜ê³  ì •ë¦¬í•©ë‹ˆë‹¤.&#10;ì˜ˆ: ì†Œì„¤ì˜ ë‚´ìš©, ë“±ì¥ì¸ë¬¼ ì„¤ëª…, ë°°ê²½ ì„¤ì •, ì£¼ìš” ì‚¬ê±´ ë“±..."
                                rows="6"
                            ></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">í”„ë¡¬í”„íŠ¸ ì…ë ¥ 1</label>
                            <textarea 
                                id="gptPrompt1" 
                                class="form-control mb-2" 
                                placeholder="GPTì—ê²Œ ì¶”ê°€ ì§€ì‹œì‚¬í•­ì„ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ: 'ì†ì„±ì„ ë” ì¶”ê°€í•´ì£¼ì„¸ìš”', 'ì†Œì„¤ì˜ ë“±ì¥ì¸ë¬¼ê³¼ ë°°ê²½ë§Œ ì¶”ì¶œí•´ì£¼ì„¸ìš”', 'ì¥ë¥´ì™€ ì£¼ì œë¡œ ë¶„ë¥˜í•´ì£¼ì„¸ìš”' ë“±..."
                                rows="2"
                            ></textarea>
                        </div>
                        <button id="analyzeBtn1" class="btn btn-primary btn-lg w-100 mb-3">
                            ğŸ” GPT AIë¡œ ë¶„ì„ (í”„ë¡¬í”„íŠ¸ 1)
                        </button>
                        <div class="mb-3">
                            <label class="form-label fw-bold">í”„ë¡¬í”„íŠ¸ ì…ë ¥ 2</label>
                            <textarea 
                                id="gptPrompt2" 
                                class="form-control mb-2" 
                                placeholder="GPTì—ê²Œ ì¶”ê°€ ì§€ì‹œì‚¬í•­ì„ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ: 'ê°œìš”ë¥¼ ì¨ë‹¬ë¼', 'ìƒì„¸í•˜ê²Œ êµ¬ì¡°í™”í•´ì„œ ì‘ì„±í•´ì£¼ì„¸ìš”' ë“±..."
                                rows="2"
                            ></textarea>
                        </div>
                        <button id="analyzeBtn2" class="btn btn-success btn-lg w-100">
                            ğŸ” GPT AIë¡œ ë¶„ì„ (í”„ë¡¬í”„íŠ¸ 2)
                        </button>
                        <div id="gptStatus" class="mt-2 small"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ë¡œê·¸ ì¶œë ¥ ì˜ì—­ -->
        <div class="log-container" id="logContainer"></div>

        <!-- ì†ì„±ë³„ ë°ì´í„° ì¶”ê°€ ëª¨ë‹¬ -->
        <div class="modal fade" id="addDataModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">ë°ì´í„° ì¶”ê°€</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì†ì„±:</label>
                            <div id="modalAttributeName" class="fw-bold text-primary"></div>
                            <small class="text-muted">
                                BIT MAX: <span id="modalAttributeMax">-</span> | 
                                BIT MIN: <span id="modalAttributeMin">-</span>
                            </small>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ë°ì´í„° ì¶”ê°€ (ì´ ì†ì„±ì— ì†í•˜ëŠ” êµ¬ì²´ì ì¸ ë‚´ìš©)</label>
                            <textarea 
                                id="newDataInput" 
                                class="form-control" 
                                rows="3"
                                placeholder="ì˜ˆ: 'ì£¼ì¸ê³µì˜ ë‚´ì  ê°ˆë“±', 'ë§ˆë²• ì„¸ê³„ì˜ ë²•ì¹™' ë“±..."
                            ></textarea>
                            <div class="row mt-2">
                                <div class="col-md-6">
                                    <div class="bit-display">
                                        <strong>ë°ì´í„° BIT MAX:</strong> <span id="newDataMax">-</span>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="bit-display">
                                        <strong>ë°ì´í„° BIT MIN:</strong> <span id="newDataMin">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button id="saveDataBtn" class="btn btn-success">ë°ì´í„° ì €ì¥</button>
                        <span id="saveDataStatus" class="ms-2 small"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://xn--9l4b4xi9r.com/_8%EB%B9%84%ED%8A%B8/js/bitCalculation.js" defer></script>
    <script>
        // DOM ìš”ì†Œ
        const $gptPrompt1 = document.getElementById('gptPrompt1');
        const $gptPrompt2 = document.getElementById('gptPrompt2');
        const $gptInput = document.getElementById('gptInput');
        const $analyzeBtn1 = document.getElementById('analyzeBtn1');
        const $analyzeBtn2 = document.getElementById('analyzeBtn2');
        const $gptStatus = document.getElementById('gptStatus');
        const $gptResultCard = document.getElementById('gptResultCard');
        const $gptResponse = document.getElementById('gptResponse');
        const $extractedAttributes = document.getElementById('extractedAttributes');

        const $attributesList = document.getElementById('attributesList');
        const $refreshBtn = document.getElementById('refreshBtn');
        
        // ë¡œê·¸ ê´€ë ¨
        const $logContainer = document.getElementById('logContainer');
        const MAX_LOG_ENTRIES = 50;

        // ë¡œê·¸ ì¶”ê°€ í•¨ìˆ˜
        function addLog(type, ...args) {
            const timestamp = new Date().toLocaleTimeString();
            let fullMessage = args.map(arg => {
                if (typeof arg === 'object') {
                    try {
                        return JSON.stringify(arg, null, 2);
                    } catch (e) {
                        return String(arg);
                    }
                }
                return String(arg);
            }).join(' ');

            // í‘œì‹œìš© ë©”ì‹œì§€ ê¸¸ì´ 50ìë¡œ ì œí•œ
            let displayMessage = fullMessage;
            const isTruncated = fullMessage.length > 50;
            if (isTruncated) {
                displayMessage = fullMessage.substring(0, 47) + '...';
            }

            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.setAttribute('data-full-message', fullMessage);
            logEntry.setAttribute('data-timestamp', timestamp);
            logEntry.setAttribute('data-type', type);
            
            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = `[${timestamp}]`;
            
            const messageSpan = document.createElement('span');
            messageSpan.className = `log-message log-${type}`;
            messageSpan.textContent = displayMessage;
            
            logEntry.appendChild(timeSpan);
            logEntry.appendChild(messageSpan);
            
            // í´ë¦­ ì´ë²¤íŠ¸: ì „ì²´ ë©”ì‹œì§€ ë³´ê¸°
            if (isTruncated || fullMessage.length > 0) {
                logEntry.addEventListener('click', () => {
                    showLogDetail(fullMessage, timestamp, type);
                });
            }
            
            // prepend: ìƒˆ ë©”ì‹œì§€ë¥¼ ë§¨ ìœ„ì— ì¶”ê°€
            const firstChild = $logContainer.firstChild;
            if (firstChild) {
                $logContainer.insertBefore(logEntry, firstChild);
            } else {
                $logContainer.appendChild(logEntry);
            }
            
            // ìµœëŒ€ 50ê°œê¹Œì§€ë§Œ ìœ ì§€ (ë§¨ ì•„ë˜ë¶€í„° ì œê±°)
            const allEntries = $logContainer.querySelectorAll('.log-entry');
            if (allEntries.length > MAX_LOG_ENTRIES) {
                // ë§¨ ì•„ë˜(ê°€ì¥ ì˜¤ë˜ëœ) í•­ëª© ì œê±°
                const oldestEntry = allEntries[allEntries.length - 1];
                if (oldestEntry && oldestEntry.parentNode) {
                    oldestEntry.parentNode.removeChild(oldestEntry);
                }
            }
        }

        // ë¡œê·¸ ìƒì„¸ ë‚´ìš© í‘œì‹œ
        function showLogDetail(fullMessage, timestamp, type) {
            const typeLabels = {
                'message': 'ì •ë³´',
                'error': 'ì—ëŸ¬',
                'warn': 'ê²½ê³ ',
                'info': 'ì •ë³´'
            };
            
            // HTML ì´ìŠ¤ì¼€ì´í”„ í—¬í¼ í•¨ìˆ˜
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.setAttribute('tabindex', '-1');
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-dialog modal-lg';
            
            const content = document.createElement('div');
            content.className = 'modal-content bg-dark text-light';
            
            // í—¤ë”
            const header = document.createElement('div');
            header.className = 'modal-header border-secondary';
            header.innerHTML = `
                <h5 class="modal-title">ë¡œê·¸ ìƒì„¸ ë‚´ìš©</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            `;
            
            // ë°”ë””
            const body = document.createElement('div');
            body.className = 'modal-body';
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'mb-2';
            timeDiv.innerHTML = `<strong>ì‹œê°„:</strong> ${escapeHtml(timestamp)}`;
            
            const typeDiv = document.createElement('div');
            typeDiv.className = 'mb-2';
            typeDiv.innerHTML = `<strong>íƒ€ì…:</strong> <span class="log-${type}">${typeLabels[type] || type}</span>`;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'mb-2';
            labelDiv.innerHTML = `<strong>ì „ì²´ ë©”ì‹œì§€:</strong>`;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'p-3 bg-black rounded';
            messageDiv.style.cssText = 'max-height: 400px; overflow-y: auto; font-family: monospace; white-space: pre-wrap; word-break: break-all; color: #0f0;';
            messageDiv.textContent = fullMessage;
            
            body.appendChild(timeDiv);
            body.appendChild(typeDiv);
            body.appendChild(labelDiv);
            body.appendChild(messageDiv);
            
            // í‘¸í„°
            const footer = document.createElement('div');
            footer.className = 'modal-footer border-secondary';
            
            const closeBtn = document.createElement('button');
            closeBtn.type = 'button';
            closeBtn.className = 'btn btn-secondary';
            closeBtn.setAttribute('data-bs-dismiss', 'modal');
            closeBtn.textContent = 'ë‹«ê¸°';
            
            footer.appendChild(closeBtn);
            
            content.appendChild(header);
            content.appendChild(body);
            content.appendChild(footer);
            modalContent.appendChild(content);
            modal.appendChild(modalContent);
            
            document.body.appendChild(modal);
            
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
            
            // ëª¨ë‹¬ì´ ë‹«íˆë©´ DOMì—ì„œ ì œê±°
            modal.addEventListener('hidden.bs.modal', () => {
                if (modal.parentNode) {
                    document.body.removeChild(modal);
                }
            });
        }


        // console ë©”ì„œë“œ ì¸í„°ì…‰ì…˜
        (function() {
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalInfo = console.info;

            console.log = function(...args) {
                originalLog.apply(console, args);
                addLog('message', ...args);
            };

            console.error = function(...args) {
                originalError.apply(console, args);
                addLog('error', ...args);
            };

            console.warn = function(...args) {
                originalWarn.apply(console, args);
                addLog('warn', ...args);
            };

            console.info = function(...args) {
                originalInfo.apply(console, args);
                addLog('info', ...args);
            };
        })();

        // ì „ì—­ ì—ëŸ¬ í•¸ë“¤ëŸ¬
        window.addEventListener('error', (event) => {
            console.error('ì „ì—­ ì—ëŸ¬:', event.error || event.message, event.filename, event.lineno);
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('ì²˜ë¦¬ë˜ì§€ ì•Šì€ Promise ê±°ë¶€:', event.reason);
        });

        // Fetch ì—ëŸ¬ ì¸í„°ì…‰ì…˜ (ì„ íƒì )
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            try {
                const response = await originalFetch.apply(this, args);
                return response;
            } catch (error) {
                console.error('Fetch ì—ëŸ¬:', error, args[0]);
                throw error;
            }
        };
        
        // ëª¨ë‹¬ ê´€ë ¨
        const addDataModal = new bootstrap.Modal(document.getElementById('addDataModal'));
        const $modalAttributeName = document.getElementById('modalAttributeName');
        const $modalAttributeMax = document.getElementById('modalAttributeMax');
        const $modalAttributeMin = document.getElementById('modalAttributeMin');
        const $newDataInput = document.getElementById('newDataInput');
        const $newDataMax = document.getElementById('newDataMax');
        const $newDataMin = document.getElementById('newDataMin');
        const $saveDataBtn = document.getElementById('saveDataBtn');
        const $saveDataStatus = document.getElementById('saveDataStatus');

        let currentAttribute = null;
        let extractedAttributesList = [];

        function getServerUrl(path) {
            if (window.location.protocol === 'file:') {
                return `http://localhost:8123${path}`;
            }
            return path;
        }

        function calculateBitValues(text) {
            if (!text || typeof text !== 'string' || text.trim() === '') {
                return { max: null, min: null };
            }
            try {
                if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
                    console.warn('BIT ê³„ì‚° í•¨ìˆ˜ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                    return { max: null, min: null };
                }
                const unicodeArray = wordNbUnicodeFormat(text);
                const max = BIT_MAX_NB(unicodeArray);
                const min = BIT_MIN_NB(unicodeArray);
                return { max: isFinite(max) ? max : null, min: isFinite(min) ? min : null };
            } catch (e) {
                console.error('BIT ê³„ì‚° ì˜¤ë¥˜:', e);
                return { max: null, min: null };
            }
        }

        // GPT ë¶„ì„ í•¨ìˆ˜
        async function analyzeWithGPT(customPrompt = null) {
            const text = $gptInput.value.trim();
            if (!text) {
                console.warn('GPT ë¶„ì„: ë¶„ì„í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                alert('ë¶„ì„í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            // í”„ë¡¬í”„íŠ¸ê°€ ì „ë‹¬ë˜ì§€ ì•Šìœ¼ë©´ ì²« ë²ˆì§¸ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©
            if (customPrompt === null) {
                customPrompt = $gptPrompt1.value.trim();
            }

            // í”„ë¡¬í”„íŠ¸ ë¡œê·¸ ì¶œë ¥ (50ì ì œí•œ)
            const promptForLog = customPrompt && customPrompt.length > 50 
                ? customPrompt.substring(0, 47) + '...' 
                : customPrompt || '(ì—†ìŒ)';
            console.log('GPT ë¶„ì„ ì‹œì‘', `í”„ë¡¬í”„íŠ¸: ${promptForLog}`, `í…ìŠ¤íŠ¸ê¸¸ì´: ${text.length}`);

            try {
                // ë‘ ë²„íŠ¼ ëª¨ë‘ ë¹„í™œì„±í™”
                $analyzeBtn1.disabled = true;
                $analyzeBtn2.disabled = true;
                $gptStatus.textContent = 'GPT AI ë¶„ì„ ì¤‘...';
                $gptStatus.style.color = '#007bff';
                $gptResponse.textContent = 'ë¶„ì„ ì¤‘...';

                console.log('í”„ë¡¬í”„íŠ¸ ì„¤ì •', `í”„ë¡¬í”„íŠ¸: ${promptForLog}`);
                
                // ê°œìš” ìš”ì²­ í™•ì¸ (ë” ë„“ì€ ë²”ìœ„ë¡œ ê²€ìƒ‰)
                const lowerPrompt = customPrompt ? customPrompt.toLowerCase() : '';
                const isOutlineRequest = customPrompt && (
                    lowerPrompt.includes('ê°œìš”') || 
                    lowerPrompt.includes('ìƒì„¸') || 
                    lowerPrompt.includes('êµ¬ì¡°í™”') ||
                    lowerPrompt.includes('outline') ||
                    lowerPrompt.includes('ìš”ì•½') ||
                    lowerPrompt.includes('ì •ë¦¬')
                );
                
                console.log('ê°œìš” ìš”ì²­ í™•ì¸', { isOutlineRequest, customPrompt });
                
                const outlineInstructions = isOutlineRequest ? `

**âš ï¸ ì¤‘ìš”: ê°œìš” ì‘ì„± ëª¨ë“œ í™œì„±í™” âš ï¸**
ì‚¬ìš©ìê°€ "${customPrompt}"ë¼ê³  ìš”ì²­í–ˆìŠµë‹ˆë‹¤. ì´ë¥¼ ë°˜ë“œì‹œ ì¤€ìˆ˜í•˜ì„¸ìš”.

ê° ì†ì„±ì˜ "ë°ì´í„°" ë¶€ë¶„ì„ êµ¬ì¡°í™”ë˜ê³  ìƒì„¸í•œ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”:

- **ë“±ì¥ì¸ë¬¼ì˜ ê²½ìš°**: ê° ì¸ë¬¼ì˜ ì´ë¦„, ì—­í• , íŠ¹ì§•ì„ ëª…í™•íˆ êµ¬ë¶„í•˜ì—¬ ì‘ì„±
  ì˜ˆ: "ì¹´ì´ (ì£¼ì¸ê³µ): ì—˜í”„ ê°€ë“œì— í•©ë¥˜í•œ ì¸ë¬¼, ì •ì²´ì„±ì„ ì°¾ëŠ” ì¤‘ | ì„¸ë¦¬ì—˜: ë¦¬ë” ì—­í• , ê²½í—˜ ë§ì€ ì „ì‚¬ | ë¦¬ì•„ë‚˜: ì§€ì› ì—­í• , ë§ˆë²•ì‚¬..."

- **ë°°ê²½ ì„¤ì •ì˜ ê²½ìš°**: ì‹œê°„, ì¥ì†Œ, ì„¸ê³„ê´€ì„ êµ¬ë¶„í•˜ì—¬ ì‘ì„±
  ì˜ˆ: "ì‹œê°„: íŒíƒ€ì§€ ì‹œëŒ€ | ì¥ì†Œ: ì–´ë‘ìš´ ìˆ² | ì„¸ê³„ê´€: ì—˜í”„ ê°€ë“œì˜ ì „ì„¤ì´ ì¡´ì¬í•˜ëŠ” íŒíƒ€ì§€ ì„¸ê³„..."

- **ì£¼ìš” ì‚¬ê±´ì˜ ê²½ìš°**: ì‚¬ê±´ë“¤ì„ ì‹œê°„ìˆœ ë˜ëŠ” ì¤‘ìš”ë„ìˆœìœ¼ë¡œ ì •ë¦¬
  ì˜ˆ: "1. ì¹´ì´ê°€ ì—˜í”„ ê°€ë“œ ë¶€ëŒ€ì— í•©ë¥˜ | 2. ì „íˆ¬ì™€ ê°±í‚¹ ë°œìƒ | 3. ìì¹´ë¥´ì™€ì˜ ëŒ€ì¹˜ | 4. í¬í¬ë¦¬ì˜ ë“±ì¥ ë° í˜‘ë ¥..."

- **ê°ì •/ë¶„ìœ„ê¸°ì˜ ê²½ìš°**: ê°ì • ë³€í™”ì™€ ë¶„ìœ„ê¸°ë¥¼ êµ¬ì²´ì ìœ¼ë¡œ ì„¤ëª…
  ì˜ˆ: "ê¸´ì¥ê°: ì „íˆ¬ ìƒí™©ì—ì„œì˜ ë¶ˆì•ˆê° | í˜‘ë ¥: ìœ„ê¸° ìƒí™©ì—ì„œì˜ ì—°ëŒ€ê° | í˜¼ë€: ì˜ˆìƒì¹˜ ëª»í•œ ìƒí™©ì— ëŒ€í•œ ë‹¹í™©..."

- **í…Œë§ˆ/ì£¼ì œì˜ ê²½ìš°**: ì£¼ìš” ì£¼ì œì™€ í•˜ìœ„ ì£¼ì œë¥¼ êµ¬ë¶„
  ì˜ˆ: "- í˜‘ë ¥ê³¼ ë°°ì‹ : ë™ë£Œë“¤ ê°„ì˜ ì‹ ë¢° ê´€ê³„ | - ì •ì²´ì„±ì˜ íƒêµ¬: ì¹´ì´ì˜ ìê¸° ë°œê²¬ | - ì „ì„¤ê³¼ í˜„ì‹¤ì˜ ì¶©ëŒ: ì´ìƒê³¼ í˜„ì‹¤ì˜ ê°­..."

- **ìŠ¤íƒ€ì¼/í†¤ì˜ ê²½ìš°**: ë¬¸ì²´ íŠ¹ì§•ê³¼ í†¤ì„ êµ¬ì²´ì ìœ¼ë¡œ ì„¤ëª…
  ì˜ˆ: "ë¬¸ì²´: ì„œì‚¬ì  ë¬¸ì²´, ê¸´ì¥ê° ìˆëŠ” ì„œìˆ  | í†¤: íŒíƒ€ì§€ì  ìš”ì†Œ ê°•ì¡°, ì§„ì§€í•˜ê³  ëª°ì…ë„ ë†’ì€ ë¶„ìœ„ê¸°..."

**âš ï¸ ë°˜ë“œì‹œ ì¤€ìˆ˜**: ë°ì´í„° ë¶€ë¶„ì€ ë‹¨ìˆœ ë‚˜ì—´ì´ ì•„ë‹Œ êµ¬ì¡°í™”ëœ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•˜ë˜, ë„ˆë¬´ ê¸¸ì§€ ì•Šê²Œ í•µì‹¬ë§Œ ê°„ê²°í•˜ê²Œ ì •ë¦¬í•´ì£¼ì„¸ìš”.
` : '';

                // í”„ë¡¬í”„íŠ¸ë¥¼ ì‹œìŠ¤í…œ ë©”ì‹œì§€ì™€ ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ ëª¨ë‘ì— ëª…í™•íˆ ë°˜ì˜
                const systemMessage = `ë‹¹ì‹ ì€ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ êµ¬ì„± ìš”ì†Œ(ì†ì„±)ë“¤ì„ ì¶”ì¶œí•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ì…ë ¥ëœ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ì— í•„ìš”í•œ êµ¬ì„± ìš”ì†Œë“¤ì„ ì°¾ì•„ì£¼ì„¸ìš”. ì˜ˆë¥¼ ë“¤ì–´:
- ë“±ì¥ì¸ë¬¼ (ì£¼ì¸ê³µ, ì¡°ì—°, ì•…ì—­ ë“±)
- ë°°ê²½ ì„¤ì • (ì‹œê°„, ì¥ì†Œ, ì„¸ê³„ê´€)
- ì£¼ìš” ì‚¬ê±´ (í”Œë¡¯, ê°ˆë“±, ì „ê°œ)
- ê°ì •/ë¶„ìœ„ê¸° (ë¶„ìœ„ê¸°, ê°ì • ë³€í™”)
- í…Œë§ˆ/ì£¼ì œ (ë©”ì‹œì§€, êµí›ˆ)
- ìŠ¤íƒ€ì¼/í†¤ (ë¬¸ì²´, í†¤)

${customPrompt ? `\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ ì‚¬ìš©ì ìš”ì²­ì‚¬í•­ (ë°˜ë“œì‹œ ì¤€ìˆ˜) âš ï¸
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${customPrompt}

ìœ„ ìš”ì²­ì‚¬í•­ì„ ë°˜ë“œì‹œ ë°˜ì˜í•˜ì—¬ ì‘ë‹µí•´ì£¼ì„¸ìš”. ì´ ì§€ì‹œì‚¬í•­ì€ ë‹¤ë¥¸ ëª¨ë“  ì§€ì¹¨ë³´ë‹¤ ìš°ì„ í•©ë‹ˆë‹¤.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n` : ''}${outlineInstructions}

**ì‘ë‹µ í˜•ì‹**: ì•„ë˜ í˜•ì‹ì„ ì •í™•íˆ ë”°ë¥´ì„¸ìš”. ê° ì†ì„±ë§ˆë‹¤ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•˜ì„¸ìš”:

ì†ì„± 1: [ì†ì„±ëª…]

ë°ì´í„°: ${isOutlineRequest ? '[âš ï¸ ìœ„ ê°œìš” ì‘ì„± ëª¨ë“œ ì§€ì¹¨ì„ ë°˜ë“œì‹œ ë”°ë¥´ì„¸ìš” - êµ¬ì¡°í™”ë˜ê³  ìƒì„¸í•œ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±]' : '[êµ¬ì²´ì ì¸ ë°ì´í„° ë‚´ìš©]'}

ì´ìœ : [ì´ ì†ì„±ì„ ì¶”ì¶œí•œ ì´ìœ ]

ì†ì„± BIT: -, -

ë°ì´í„° BIT: -, -

---

ì†ì„± 2: [ì†ì„±ëª…]

ë°ì´í„°: ${isOutlineRequest ? '[âš ï¸ ìœ„ ê°œìš” ì‘ì„± ëª¨ë“œ ì§€ì¹¨ì„ ë°˜ë“œì‹œ ë”°ë¥´ì„¸ìš” - êµ¬ì¡°í™”ë˜ê³  ìƒì„¸í•œ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±]' : '[êµ¬ì²´ì ì¸ ë°ì´í„° ë‚´ìš©]'}

ì´ìœ : [ì´ ì†ì„±ì„ ì¶”ì¶œí•œ ì´ìœ ]

ì†ì„± BIT: -, -

ë°ì´í„° BIT: -, -

---

(ê³„ì† ë°˜ë³µ...)

**ì¤‘ìš”**: 
- ìµœì†Œ 3ê°œ ì´ìƒì˜ ì†ì„±ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”.
- ì‚¬ìš©ìê°€ "ì†ì„±ì„ ë” ì¶”ê°€í•´ì£¼ì„¸ìš”" ë˜ëŠ” ìœ ì‚¬í•œ ìš”ì²­ì„ í•˜ë©´, ê¸°ì¡´ ì†ì„± ì™¸ì— ì¶”ê°€ ì†ì„±ë“¤ì„ ë” ì°¾ì•„ì„œ ì œê³µí•´ì£¼ì„¸ìš”.
- ì†ì„± BITì™€ ë°ì´í„° BITëŠ” í•­ìƒ "-, -"ë¡œ í‘œì‹œí•˜ì„¸ìš” (ì‹¤ì œ ê³„ì‚°ì€ ì‹œìŠ¤í…œì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤).
- JSON í˜•ì‹ì´ ì•„ë‹Œ ìœ„ì˜ í…ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•˜ì„¸ìš”.`;

                // í”„ë¡¬í”„íŠ¸ ì…ë ¥ì´ ìˆìœ¼ë©´ í•´ë‹¹ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©, í…ìŠ¤íŠ¸ëŠ” ê·¸ëŒ€ë¡œ í¬í•¨
                // í”„ë¡¬í”„íŠ¸ì— {text} í”Œë ˆì´ìŠ¤í™€ë”ê°€ ìˆìœ¼ë©´ í…ìŠ¤íŠ¸ë¡œ ì¹˜í™˜, ì—†ìœ¼ë©´ í”„ë¡¬í”„íŠ¸ ë’¤ì— í…ìŠ¤íŠ¸ ì¶”ê°€
                let finalPrompt;
                if (customPrompt) {
                    // ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ë¥¼ ëª…í™•íˆ í‘œì‹œ
                    if (customPrompt.includes('{text}')) {
                        // í”„ë¡¬í”„íŠ¸ì— {text} í”Œë ˆì´ìŠ¤í™€ë”ê°€ ìˆìœ¼ë©´ ì¹˜í™˜
                        finalPrompt = customPrompt.replace(/{text}/g, text);
                    } else {
                        // í”Œë ˆì´ìŠ¤í™€ë”ê°€ ì—†ìœ¼ë©´ í”„ë¡¬í”„íŠ¸ë¥¼ ë¨¼ì € ëª…ì‹œí•˜ê³  í…ìŠ¤íŠ¸ ì¶”ê°€
                        finalPrompt = `${customPrompt}\n\n[ìœ„ ìš”ì²­ì‚¬í•­ì— ë”°ë¼ ì•„ë˜ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”]\n\n${text}`;
                    }
                } else {
                    // ê¸°ë³¸ í”„ë¡¬í”„íŠ¸
                    finalPrompt = `ë‹¤ìŒ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ êµ¬ì„± ìš”ì†Œ(ì†ì„±)ë“¤ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”:\n\n"${text}"`;
                }

                const url = getServerUrl('/api/gpt/chat');
                console.log('GPT API ìš”ì²­ ì‹œì‘', { url, promptLength: finalPrompt.length });
                
                const requestBody = {
                    prompt: finalPrompt,
                    systemMessage: systemMessage,
                    model: 'gpt-4o-mini',
                    temperature: 0.3,
                    maxTokens: 1500
                };
                
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('GPT API ì‘ë‹µ ìˆ˜ì‹ ', { status: res.status, statusText: res.statusText });

                if (!res.ok) {
                    console.error('GPT API ì˜¤ë¥˜', { status: res.status });
                    throw new Error(`HTTP ${res.status}`);
                }

                const data = await res.json();
                console.log('GPT API ì‘ë‹µ íŒŒì‹± ì™„ë£Œ', { ok: data.ok, responseLength: data.response?.length || 0 });
                
                if (!data.ok) {
                    console.error('GPT ë¶„ì„ ì‹¤íŒ¨', { error: data.error });
                    throw new Error(data.error || 'GPT ë¶„ì„ ì‹¤íŒ¨');
                }

                console.log('GPT ì‘ë‹µ í…ìŠ¤íŠ¸ íŒŒì‹± ì‹œì‘');

                // í…ìŠ¤íŠ¸ í˜•ì‹ ì‘ë‹µ íŒŒì‹±
                let parsed = [];
                try {
                    const responseText = data.response.trim();
                    
                    // ë¨¼ì € JSON í˜•ì‹ì¸ì§€ í™•ì¸ (í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´)
                    let jsonText = responseText;
                    if (jsonText.startsWith('```json')) {
                        jsonText = jsonText.replace(/```json\s*/, '').replace(/\s*```$/, '');
                    } else if (jsonText.startsWith('```')) {
                        jsonText = jsonText.replace(/```\s*/, '').replace(/\s*```$/, '');
                    }
                    
                    try {
                        const jsonParsed = JSON.parse(jsonText);
                        if (Array.isArray(jsonParsed)) {
                            // JSON í˜•ì‹ìœ¼ë¡œ íŒŒì‹± ì„±ê³µ
                            parsed = jsonParsed.map(item => ({
                                attribute: item.attribute?.trim() || '',
                                data: item.data?.trim() || '',
                                reasoning: item.reasoning?.trim() || ''
                            }));
                        }
                    } catch {
                        // JSONì´ ì•„ë‹ˆë©´ í…ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œ íŒŒì‹±
                        // "ì†ì„± N: ..." íŒ¨í„´ìœ¼ë¡œ ì†ì„±ë“¤ì„ ë¶„ë¦¬
                        // "---" ë˜ëŠ” ë¹ˆ ì¤„ë¡œ êµ¬ë¶„ëœ ì„¹ì…˜ì„ ì°¾ìŒ
                        const sections = responseText.split(/(?:^|\n)---+|\n\n(?=ì†ì„±\s*\d+\s*:)/m);
                        
                        for (const section of sections) {
                            const trimmedSection = section.trim();
                            if (!trimmedSection) continue;
                            
                            // ì†ì„±ëª… ì¶”ì¶œ (ì†ì„± 1: ë˜ëŠ” ì†ì„± N: í˜•ì‹)
                            const attrMatch = trimmedSection.match(/ì†ì„±\s*\d+\s*:\s*(.+?)(?:\n|$)/);
                            if (!attrMatch) continue;
                            const attribute = attrMatch[1].trim();
                            
                            // ë°ì´í„° ì¶”ì¶œ (ë°ì´í„°: ë‹¤ìŒë¶€í„° ì´ìœ : ë˜ëŠ” ì†ì„± BIT: ì „ê¹Œì§€)
                            const dataMatch = trimmedSection.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì´ìœ :|\nì´ìœ :|\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|$)/s);
                            const dataText = dataMatch ? dataMatch[1].trim() : '';
                            
                            // ì´ìœ  ì¶”ì¶œ (ì´ìœ : ë‹¤ìŒë¶€í„° ì†ì„± BIT: ë˜ëŠ” ë°ì´í„° BIT: ì „ê¹Œì§€)
                            const reasonMatch = trimmedSection.match(/ì´ìœ \s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|\n\në°ì´í„°\s*BIT:|\në°ì´í„°\s*BIT:|$)/s);
                            const reasoning = reasonMatch ? reasonMatch[1].trim() : '';
                            
                            if (attribute && dataText) {
                                parsed.push({
                                    attribute: attribute,
                                    data: dataText,
                                    reasoning: reasoning
                                });
                            }
                        }
                        
                        // ì„¹ì…˜ ë¶„ë¦¬ê°€ ì•ˆ ëœ ê²½ìš°, ì§ì ‘ íŒ¨í„´ ë§¤ì¹­ ì‹œë„
                        if (parsed.length === 0) {
                            const attributeMatches = [...responseText.matchAll(/ì†ì„±\s*\d+\s*:\s*(.+?)(?:\n|$)/g)];
                            for (const attrMatch of attributeMatches) {
                                const attribute = attrMatch[1].trim();
                                if (!attribute) continue;
                                
                                // í•´ë‹¹ ì†ì„± ë‹¤ìŒ ë¶€ë¶„ ì°¾ê¸°
                                const attrIndex = attrMatch.index + attrMatch[0].length;
                                const nextSection = responseText.substring(attrIndex);
                                
                                const dataMatch = nextSection.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì´ìœ :|\nì´ìœ :|\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|ì†ì„±\s*\d+\s*:|$)/s);
                                const dataText = dataMatch ? dataMatch[1].trim() : '';
                                
                                const reasonMatch = nextSection.match(/ì´ìœ \s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|\n\në°ì´í„°\s*BIT:|\në°ì´í„°\s*BIT:|ì†ì„±\s*\d+\s*:|$)/s);
                                const reasoning = reasonMatch ? reasonMatch[1].trim() : '';
                                
                                if (attribute && dataText) {
                                    parsed.push({
                                        attribute: attribute,
                                        data: dataText,
                                        reasoning: reasoning
                                    });
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('íŒŒì‹± ì˜¤ë¥˜:', e);
                    throw new Error('GPT ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨: ' + e.message);
                }

                console.log('íŒŒì‹± ì™„ë£Œ', { parsedCount: parsed.length });

                if (!Array.isArray(parsed) || parsed.length === 0) {
                    console.error('ì†ì„± ì¶”ì¶œ ì‹¤íŒ¨: ì¶”ì¶œëœ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                    throw new Error('GPT ì‘ë‹µì—ì„œ ì†ì„±ì„ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‘ë‹µ í˜•ì‹ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }

                console.log('ì¶”ì¶œëœ ì†ì„± ì²˜ë¦¬ ì‹œì‘', { count: parsed.length });

                // ì¶”ì¶œëœ ì†ì„± ì²˜ë¦¬
                extractedAttributesList = parsed.map(item => {
                    const attribute = item.attribute?.trim() || '';
                    const dataText = item.data?.trim() || '';
                    const reasoning = item.reasoning?.trim() || '';
                    
                    if (!attribute || !dataText) {
                        return null;
                    }

                    const attrBits = calculateBitValues(attribute);
                    const dataBits = calculateBitValues(dataText);
                    
                    console.log('ì†ì„± BIT ê³„ì‚°', { 
                        attribute, 
                        attrBitMax: attrBits.max, 
                        attrBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    });
                    
                    return {
                        attribute: attribute,
                        data: dataText,
                        reasoning: reasoning,
                        attributeBitMax: attrBits.max,
                        attributeBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    };
                }).filter(Boolean);

                console.log('ì†ì„± ì²˜ë¦¬ ì™„ë£Œ', { validCount: extractedAttributesList.length });

                if (extractedAttributesList.length === 0) {
                    console.error('ìœ íš¨í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                    throw new Error('ì¶”ì¶œëœ ìœ íš¨í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                }

                // ê²°ê³¼ í‘œì‹œ
                console.log('ë¶„ì„ ê²°ê³¼ í‘œì‹œ', { attributeCount: extractedAttributesList.length });
                $gptResponse.textContent = data.response;
                displayExtractedAttributes();
                $gptResultCard.style.display = 'block';
                $gptStatus.textContent = `âœ“ ë¶„ì„ ì™„ë£Œ: ${extractedAttributesList.length}ê°œ ì†ì„± ì¶”ì¶œë¨. ìë™ ì €ì¥ ì¤‘...`;
                $gptStatus.style.color = '#007bff';

                // ìë™ ì €ì¥ ì‹¤í–‰
                console.log('ìë™ ì €ì¥ ì‹œì‘');
                await saveAllAttributes();
                console.log('GPT ë¶„ì„ ì™„ë£Œ');

            } catch (e) {
                console.error('GPT ë¶„ì„ ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ë¶„ì„ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
                $gptResponse.textContent = `ì˜¤ë¥˜: ${e.message}`;
            } finally {
                $analyzeBtn1.disabled = false;
                $analyzeBtn2.disabled = false;
            }
        }

        // ì¶”ì¶œëœ ì†ì„± í‘œì‹œ
        function displayExtractedAttributes() {
            let html = '<div class="row">';
            extractedAttributesList.forEach((item, idx) => {
                const attrMax = item.attributeBitMax !== null && item.attributeBitMax !== undefined ? item.attributeBitMax.toFixed(15) : '-';
                const attrMin = item.attributeBitMin !== null && item.attributeBitMin !== undefined ? item.attributeBitMin.toFixed(15) : '-';
                const dataMax = item.dataBitMax !== null && item.dataBitMax !== undefined ? item.dataBitMax.toFixed(15) : '-';
                const dataMin = item.dataBitMin !== null && item.dataBitMin !== undefined ? item.dataBitMin.toFixed(15) : '-';
                const saveStatus = item.saveStatus || 'pending'; // pending, saving, success, duplicate, error
                const saveMessage = item.saveMessage || '';
                
                let statusHtml = '';
                if (saveStatus === 'pending') {
                    statusHtml = '<div class="small text-muted mt-2"><em>ì €ì¥ ëŒ€ê¸° ì¤‘...</em></div>';
                } else if (saveStatus === 'saving') {
                    statusHtml = '<div class="small text-info mt-2">ğŸ’¾ ì €ì¥ ì¤‘...</div>';
                } else if (saveStatus === 'success') {
                    statusHtml = `<div class="small text-success mt-2">âœ“ ${saveMessage || 'ì €ì¥ ì™„ë£Œ'}</div>`;
                } else if (saveStatus === 'duplicate') {
                    statusHtml = `<div class="small text-warning mt-2">âš  ${saveMessage || 'ì´ë¯¸ ì €ì¥ë¨'}</div>`;
                } else if (saveStatus === 'error') {
                    statusHtml = `<div class="small text-danger mt-2">âœ— ${saveMessage || 'ì €ì¥ ì‹¤íŒ¨'}</div>`;
                }
                
                html += `
                    <div class="col-md-6 mb-3">
                        <div class="border rounded p-3 attribute-card" 
                             onclick="handleAttributeCardClick(${idx})">
                            <h6 class="text-primary">ì†ì„± ${idx + 1}: ${escapeHtml(item.attribute)}</h6>
                            <div class="mb-2">
                                <strong>ë°ì´í„°:</strong> ${escapeHtml(item.data)}
                            </div>
                            ${item.reasoning ? `<div class="small text-muted mb-2"><strong>ì´ìœ :</strong> ${escapeHtml(item.reasoning)}</div>` : ''}
                            <div class="small text-muted">
                                <strong>ì†ì„± BIT:</strong> MAX ${attrMax}, MIN ${attrMin}<br>
                                <strong>ë°ì´í„° BIT:</strong> MAX ${dataMax}, MIN ${dataMin}
                            </div>
                            ${(item.attributeBitMax === null || item.attributeBitMin === null || item.dataBitMax === null || item.dataBitMin === null) ? 
                                '<div class="text-warning small mt-1">âš  BIT ê°’ ê³„ì‚° ì‹¤íŒ¨</div>' : ''}
                            ${statusHtml}
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            $extractedAttributes.innerHTML = html;
        }
        
        // ì†ì„± ì¹´ë“œ í´ë¦­ í•¸ë“¤ëŸ¬
        window.handleAttributeCardClick = function(idx) {
            const item = extractedAttributesList[idx];
            if (!item) return;
            
            // ì¢Œì¸¡ ì†ì„± ëª©ë¡ì—ì„œ í•´ë‹¹ ì†ì„± ì°¾ê¸°
            if (item.attributeBitMax && item.attributeBitMin) {
                scrollToAttribute(item.attributeBitMax, item.attributeBitMin, item.attribute);
            }
        };

        // ì¢Œì¸¡ ì†ì„± ëª©ë¡ì—ì„œ ì†ì„± ì°¾ì•„ì„œ ìŠ¤í¬ë¡¤í•˜ê³  ê°•ì¡° í‘œì‹œ
        function scrollToAttribute(bitMax, bitMin, attributeText) {
            console.log('ì†ì„± ìŠ¤í¬ë¡¤ ì‹œì‘', { attributeText, bitMax, bitMin });
            
            // ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì œê±°
            const previousHighlighted = document.querySelector('.attribute-item.highlighted');
            if (previousHighlighted) {
                previousHighlighted.classList.remove('highlighted');
            }

            // ëª¨ë“  ì†ì„± ì•„ì´í…œ ì°¾ê¸°
            const attributeItems = document.querySelectorAll('.attribute-item');
            let targetElement = null;

            // BIT ê°’ìœ¼ë¡œ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ì†ì„± ì°¾ê¸°
            attributeItems.forEach(item => {
                const bitMaxText = item.getAttribute('data-bit-max');
                const bitMinText = item.getAttribute('data-bit-min');
                
                if (bitMaxText && bitMinText) {
                    const itemBitMax = parseFloat(bitMaxText);
                    const itemBitMin = parseFloat(bitMinText);
                    
                    // BIT ê°’ì´ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸ (ì†Œìˆ˜ì  ì˜¤ì°¨ í—ˆìš©)
                    if (Math.abs(itemBitMax - bitMax) < 0.0001 && Math.abs(itemBitMin - bitMin) < 0.0001) {
                        targetElement = item;
                    }
                }
            });

            // BIT ê°’ìœ¼ë¡œ ëª» ì°¾ì•˜ìœ¼ë©´ í…ìŠ¤íŠ¸ë¡œ ì°¾ê¸°
            if (!targetElement) {
                attributeItems.forEach(item => {
                    const nameElement = item.querySelector('.attribute-name');
                    if (nameElement && nameElement.textContent.trim() === attributeText.trim()) {
                        targetElement = item;
                    }
                });
            }

            if (targetElement) {
                console.log('ì†ì„± ì°¾ìŒ ë° ìŠ¤í¬ë¡¤', { attributeText });
                // í•˜ì´ë¼ì´íŠ¸ ì¶”ê°€
                targetElement.classList.add('highlighted');
                
                // ìŠ¤í¬ë¡¤í•˜ì—¬ í•´ë‹¹ ìš”ì†Œë¥¼ ë³´ì´ê²Œ í•¨
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });

                // 3ì´ˆ í›„ í•˜ì´ë¼ì´íŠ¸ ì œê±°
                setTimeout(() => {
                    targetElement.classList.remove('highlighted');
                    console.log('ì†ì„± í•˜ì´ë¼ì´íŠ¸ ì œê±°', { attributeText });
                }, 3000);
            } else {
                console.warn('ì†ì„±ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', attributeText);
                // ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨ í›„ ë‹¤ì‹œ ì‹œë„
                console.log('ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨ í›„ ì¬ì‹œë„');
                loadAttributes().then(() => {
                    setTimeout(() => scrollToAttribute(bitMax, bitMin, attributeText), 500);
                });
            }
        }


        // ëª¨ë“  ì†ì„± ì €ì¥ (ìë™ ì €ì¥)
        async function saveAllAttributes() {
            if (extractedAttributesList.length === 0) {
                console.warn('ì €ì¥í•  ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            console.log('ì†ì„± ì €ì¥ ì‹œì‘', { totalCount: extractedAttributesList.length });

            try {
                let successCount = 0;
                let duplicateCount = 0;
                let errorCount = 0;

                // ê° ì†ì„±ë³„ë¡œ ì €ì¥
                for (let idx = 0; idx < extractedAttributesList.length; idx++) {
                    const item = extractedAttributesList[idx];
                    
                    // ì €ì¥ ì¤‘ ìƒíƒœë¡œ í‘œì‹œ
                    item.saveStatus = 'saving';
                    item.saveMessage = 'ì €ì¥ ì¤‘...';
                    displayExtractedAttributes();
                    
                    try {
                        // BIT ê°’ ê²€ì¦
                        if (item.attributeBitMax === null || item.attributeBitMin === null || 
                            item.dataBitMax === null || item.dataBitMin === null) {
                            item.saveStatus = 'error';
                            item.saveMessage = 'BIT ê°’ ê³„ì‚° ì‹¤íŒ¨';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }

                        console.log(`ì†ì„± ì €ì¥ ì‹œë„: ${item.attribute}`);
                        const url = getServerUrl('/api/attributes/data');
                        const res = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                attributeBitMax: item.attributeBitMax,
                                attributeBitMin: item.attributeBitMin,
                                attributeText: item.attribute,
                                text: item.data,
                                dataBitMax: item.dataBitMax,
                                dataBitMin: item.dataBitMin
                            })
                        });

                        console.log(`ì†ì„± ì €ì¥ API ì‘ë‹µ: ${item.attribute}`, { status: res.status });

                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}`);
                        }

                        const data = await res.json();
                        if (data.ok) {
                            if (data.duplicate) {
                                duplicateCount++;
                                item.saveStatus = 'duplicate';
                                item.saveMessage = data.message || 'ì´ë¯¸ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.';
                                console.warn(`ì†ì„± ì¤‘ë³µ: ${item.attribute}`);
                            } else {
                                successCount++;
                                item.saveStatus = 'success';
                                item.saveMessage = 'ì €ì¥ ì™„ë£Œ';
                                console.log(`ì†ì„± ì €ì¥ ì™„ë£Œ: ${item.attribute}`);
                            }
                        } else {
                            throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
                        }
                    } catch (e) {
                        console.error(`ì†ì„± "${item.attribute}" ì €ì¥ ì˜¤ë¥˜:`, e);
                        errorCount++;
                        item.saveStatus = 'error';
                        item.saveMessage = e.message || 'ì €ì¥ ì‹¤íŒ¨';
                    }
                    
                    // ê° í•­ëª© ì €ì¥ í›„ ì¦‰ì‹œ í™”ë©´ ì—…ë°ì´íŠ¸
                    displayExtractedAttributes();
                }

                // ì „ì²´ ì €ì¥ ì™„ë£Œ ìƒíƒœ ì—…ë°ì´íŠ¸
                console.log('ì†ì„± ì €ì¥ ì™„ë£Œ', { success: successCount, duplicate: duplicateCount, error: errorCount });
                $gptStatus.textContent = `âœ“ ì €ì¥ ì™„ë£Œ: ì„±ê³µ ${successCount}ê°œ, ì¤‘ë³µ ${duplicateCount}ê°œ, ì‹¤íŒ¨ ${errorCount}ê°œ`;
                $gptStatus.style.color = '#28a745';
                
                // ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                console.log('ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ì˜ˆì•½');
                setTimeout(() => {
                    loadAttributes();
                }, 500);
            } catch (e) {
                console.error('ì €ì¥ ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
            }
        }

        // GPT ë¶„ì„ ë²„íŠ¼ ì´ë²¤íŠ¸
        $analyzeBtn1.addEventListener('click', () => {
            const prompt = $gptPrompt1.value.trim();
            analyzeWithGPT(prompt);
        });
        
        $analyzeBtn2.addEventListener('click', () => {
            analyzeWithGPT2();
        });

        // GPT ë¶„ì„ í•¨ìˆ˜ 2: ì†ì„± ê²°ì • í›„ í”„ë¡¬í”„íŠ¸ 2 ì ìš©
        async function analyzeWithGPT2() {
            const text = $gptInput.value.trim();
            if (!text) {
                console.warn('GPT ë¶„ì„: ë¶„ì„í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                alert('ë¶„ì„í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            const prompt2 = $gptPrompt2.value.trim();
            if (!prompt2) {
                console.warn('GPT ë¶„ì„ 2: í”„ë¡¬í”„íŠ¸ ì…ë ¥ 2ê°€ ì—†ìŠµë‹ˆë‹¤.');
                alert('í”„ë¡¬í”„íŠ¸ ì…ë ¥ 2ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            console.log('GPT ë¶„ì„ 2 ì‹œì‘', { prompt2, textLength: text.length });

            try {
                // ë‘ ë²„íŠ¼ ëª¨ë‘ ë¹„í™œì„±í™”
                $analyzeBtn1.disabled = true;
                $analyzeBtn2.disabled = true;
                $gptStatus.textContent = 'GPT AI ë¶„ì„ ì¤‘... (ì†ì„± ê²°ì • ì¤‘)';
                $gptStatus.style.color = '#007bff';
                $gptResponse.textContent = 'ë¶„ì„ ì¤‘...';

                // ì²« ë²ˆì§¸ GPT í˜¸ì¶œ: ì†ì„± ê²°ì •
                console.log('1ë‹¨ê³„: ì†ì„± ê²°ì • ì‹œì‘');
                const attributeSystemMessage = `ë‹¹ì‹ ì€ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì–´ë–¤ ì†ì„±(ì†Œì„¤ êµ¬ì„± ìš”ì†Œ)ì„ ë¶„ì„í• ì§€ ê²°ì •í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ì‚¬ìš©ìì˜ ìš”ì²­: "${prompt2}"

ì‚¬ìš©ìì˜ ìš”ì²­ì„ ë°”íƒ•ìœ¼ë¡œ, ë‹¤ìŒ ì¤‘ í•˜ë‚˜ì˜ ì†ì„± ì´ë¦„ì„ ì •í™•íˆ ì„ íƒí•˜ì—¬ ë°˜í™˜í•´ì£¼ì„¸ìš”:
- ë“±ì¥ì¸ë¬¼
- ë°°ê²½ ì„¤ì •
- ì£¼ìš” ì‚¬ê±´
- ê°ì •/ë¶„ìœ„ê¸°
- í…Œë§ˆ/ì£¼ì œ
- ìŠ¤íƒ€ì¼/í†¤

**ì¤‘ìš”**: 
- ì‚¬ìš©ìì˜ ìš”ì²­ì— ê°€ì¥ ì í•©í•œ ì†ì„± ì´ë¦„ í•˜ë‚˜ë§Œ ì„ íƒí•˜ì„¸ìš”.
- ë‹¤ë¥¸ ì„¤ëª… ì—†ì´ ì†ì„± ì´ë¦„ë§Œ ì •í™•íˆ ë°˜í™˜í•˜ì„¸ìš”.
- ì˜ˆ: ì‚¬ìš©ìê°€ "ë“±ì¥ì¸ë¬¼ì„" ë˜ëŠ” "ë“±ì¥ì¸ë¬¼ì— ëŒ€í•´" ìš”ì²­í•˜ë©´ â†’ "ë“±ì¥ì¸ë¬¼"
- ì˜ˆ: ì‚¬ìš©ìê°€ "ë°°ê²½" ë˜ëŠ” "ì„¤ì •"ì„ ìš”ì²­í•˜ë©´ â†’ "ë°°ê²½ ì„¤ì •"
- ì˜ˆ: ì‚¬ìš©ìê°€ "ê°œìš”ë¥¼ ì¨ì¤˜"ë¼ê³  í–ˆì§€ë§Œ ì†ì„±ì„ ëª…ì‹œí•˜ì§€ ì•Šì•˜ë‹¤ë©´, í…ìŠ¤íŠ¸ë¥¼ ë³´ê³  ê°€ì¥ ì í•©í•œ ì†ì„±ì„ ì„ íƒí•˜ì„¸ìš”.`;

                const attributePrompt = `ë‹¤ìŒ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬, ì‚¬ìš©ì ìš”ì²­ "${prompt2}"ì— í•´ë‹¹í•˜ëŠ” ì†ì„± í•˜ë‚˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.\n\n[í…ìŠ¤íŠ¸]\n${text}\n\nìœ„ ìš”ì²­ì— ê°€ì¥ ì í•©í•œ ì†ì„± ì´ë¦„ í•˜ë‚˜ë§Œ ì •í™•íˆ ë°˜í™˜í•˜ì„¸ìš”.`;

                const attributeUrl = getServerUrl('/api/gpt/chat');
                const attributeRes = await fetch(attributeUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: attributePrompt,
                        systemMessage: attributeSystemMessage,
                        model: 'gpt-4o-mini',
                        temperature: 0.3,
                        maxTokens: 100
                    })
                });

                if (!attributeRes.ok) {
                    throw new Error(`HTTP ${attributeRes.status}`);
                }

                const attributeData = await attributeRes.json();
                if (!attributeData.ok) {
                    throw new Error(attributeData.error || 'ì†ì„± ê²°ì • ì‹¤íŒ¨');
                }

                // ì†ì„± ì´ë¦„ ì¶”ì¶œ
                let selectedAttribute = attributeData.response.trim();
                // ì†ì„± ì´ë¦„ë§Œ ì¶”ì¶œ (ë¶ˆí•„ìš”í•œ ì„¤ëª… ì œê±°)
                const lowerResponse = selectedAttribute.toLowerCase();
                
                if (lowerResponse.includes('ë“±ì¥ì¸ë¬¼') || lowerResponse.includes('ì¸ë¬¼')) {
                    selectedAttribute = 'ë“±ì¥ì¸ë¬¼';
                } else if (lowerResponse.includes('ë°°ê²½') && (lowerResponse.includes('ì„¤ì •') || lowerResponse.includes('ì¥ì†Œ') || lowerResponse.includes('ì„¸ê³„'))) {
                    selectedAttribute = 'ë°°ê²½ ì„¤ì •';
                } else if ((lowerResponse.includes('ì£¼ìš”') && lowerResponse.includes('ì‚¬ê±´')) || lowerResponse.includes('ì‚¬ê±´') || lowerResponse.includes('í”Œë¡¯')) {
                    selectedAttribute = 'ì£¼ìš” ì‚¬ê±´';
                } else if ((lowerResponse.includes('ê°ì •') || lowerResponse.includes('ë¶„ìœ„ê¸°')) && !lowerResponse.includes('í…Œë§ˆ')) {
                    selectedAttribute = 'ê°ì •/ë¶„ìœ„ê¸°';
                } else if (lowerResponse.includes('í…Œë§ˆ') || lowerResponse.includes('ì£¼ì œ') || lowerResponse.includes('ë©”ì‹œì§€')) {
                    selectedAttribute = 'í…Œë§ˆ/ì£¼ì œ';
                } else if (lowerResponse.includes('ìŠ¤íƒ€ì¼') || lowerResponse.includes('í†¤') || lowerResponse.includes('ë¬¸ì²´')) {
                    selectedAttribute = 'ìŠ¤íƒ€ì¼/í†¤';
                } else {
                    // ê¸°ë³¸ê°’: ì²« ë²ˆì§¸ ì†ì„± (ë“±ì¥ì¸ë¬¼)
                    console.warn('ì†ì„±ì„ ìë™ìœ¼ë¡œ ê²°ì •í•  ìˆ˜ ì—†ì–´ ë“±ì¥ì¸ë¬¼ë¡œ ì„¤ì •í•©ë‹ˆë‹¤.', { response: selectedAttribute });
                    selectedAttribute = 'ë“±ì¥ì¸ë¬¼';
                }

                console.log('ì„ íƒëœ ì†ì„±', { selectedAttribute, originalResponse: attributeData.response });

                // ë‘ ë²ˆì§¸ GPT í˜¸ì¶œ: ì„ íƒëœ ì†ì„±ì— ëŒ€í•´ í”„ë¡¬í”„íŠ¸ 2 ìš”êµ¬ì‚¬í•­ ë°˜ì˜í•˜ì—¬ ë¶„ì„
                console.log('2ë‹¨ê³„: ì†ì„± ë¶„ì„ ì‹œì‘', { attribute: selectedAttribute });
                $gptStatus.textContent = `GPT AI ë¶„ì„ ì¤‘... (${selectedAttribute} ë¶„ì„ ì¤‘)`;
                
                const analysisSystemMessage = `ë‹¹ì‹ ì€ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ "${selectedAttribute}" ì†ì„±ì— ëŒ€í•œ ì •ë³´ë¥¼ ì¶”ì¶œí•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ì‚¬ìš©ì ìš”ì²­: "${prompt2}"

ìœ„ ìš”ì²­ì‚¬í•­ì„ ë°˜ë“œì‹œ ë°˜ì˜í•˜ì—¬ "${selectedAttribute}" ì†ì„±ì— ëŒ€í•œ ë¶„ì„ ê²°ê³¼ë¥¼ ì œê³µí•´ì£¼ì„¸ìš”.

**ì‘ë‹µ í˜•ì‹**:

ì†ì„±: ${selectedAttribute}

ë°ì´í„°: [í”„ë¡¬í”„íŠ¸ ìš”ì²­ì‚¬í•­ì— ë”°ë¼ ì‘ì„±]

ì†ì„± BIT: -, -

ë°ì´í„° BIT: -, -

**ì¤‘ìš”**: 
- ì‚¬ìš©ì ìš”ì²­ "${prompt2}"ë¥¼ ë°˜ë“œì‹œ ë°˜ì˜í•˜ì—¬ ë°ì´í„°ë¥¼ ì‘ì„±í•˜ì„¸ìš”.
- ì†ì„± BITì™€ ë°ì´í„° BITëŠ” í•­ìƒ "-, -"ë¡œ í‘œì‹œí•˜ì„¸ìš” (ì‹¤ì œ ê³„ì‚°ì€ ì‹œìŠ¤í…œì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤).
- JSON í˜•ì‹ì´ ì•„ë‹Œ ìœ„ì˜ í…ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•˜ì„¸ìš”.`;

                const analysisPrompt = `ë‹¤ìŒ ì†Œì„¤ í…ìŠ¤íŠ¸ì—ì„œ "${selectedAttribute}" ì†ì„±ì— ëŒ€í•œ ì •ë³´ë¥¼ ì¶”ì¶œí•´ì£¼ì„¸ìš”.\n\nì‚¬ìš©ì ìš”ì²­: "${prompt2}"\n\n[í…ìŠ¤íŠ¸]\n${text}\n\nìœ„ ìš”ì²­ì‚¬í•­ì— ë”°ë¼ "${selectedAttribute}" ì†ì„±ì˜ ë°ì´í„°ë¥¼ ì‘ì„±í•´ì£¼ì„¸ìš”.`;

                const analysisUrl = getServerUrl('/api/gpt/chat');
                const analysisRes = await fetch(analysisUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: analysisPrompt,
                        systemMessage: analysisSystemMessage,
                        model: 'gpt-4o-mini',
                        temperature: 0.3,
                        maxTokens: 1500
                    })
                });

                if (!analysisRes.ok) {
                    throw new Error(`HTTP ${analysisRes.status}`);
                }

                const analysisData = await analysisRes.json();
                if (!analysisData.ok) {
                    throw new Error(analysisData.error || 'ì†ì„± ë¶„ì„ ì‹¤íŒ¨');
                }

                console.log('ì†ì„± ë¶„ì„ ì™„ë£Œ');

                // ì‘ë‹µ íŒŒì‹±
                let parsed = [];
                try {
                    const responseText = analysisData.response.trim();
                    
                    // ì†ì„± ì¶”ì¶œ
                    const attrMatch = responseText.match(/ì†ì„±\s*:\s*(.+?)(?:\n|$)/);
                    const attribute = attrMatch ? attrMatch[1].trim() : selectedAttribute;
                    
                    // ë°ì´í„° ì¶”ì¶œ
                    const dataMatch = responseText.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|$)/s);
                    const dataText = dataMatch ? dataMatch[1].trim() : responseText;
                    
                    if (attribute && dataText) {
                        parsed.push({
                            attribute: attribute,
                            data: dataText,
                            reasoning: ''
                        });
                    }
                } catch (e) {
                    console.error('íŒŒì‹± ì˜¤ë¥˜:', e);
                    // íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì „ì²´ ì‘ë‹µì„ ë°ì´í„°ë¡œ ì‚¬ìš©
                    parsed.push({
                        attribute: selectedAttribute,
                        data: analysisData.response,
                        reasoning: ''
                    });
                }

                if (parsed.length === 0) {
                    throw new Error('ë¶„ì„ ê²°ê³¼ë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }

                // ì¶”ì¶œëœ ì†ì„± ì²˜ë¦¬
                extractedAttributesList = parsed.map(item => {
                    const attribute = item.attribute?.trim() || '';
                    const dataText = item.data?.trim() || '';
                    
                    if (!attribute || !dataText) {
                        return null;
                    }

                    const attrBits = calculateBitValues(attribute);
                    const dataBits = calculateBitValues(dataText);
                    
                    console.log('ì†ì„± BIT ê³„ì‚°', { 
                        attribute, 
                        attrBitMax: attrBits.max, 
                        attrBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    });
                    
                    return {
                        attribute: attribute,
                        data: dataText,
                        reasoning: item.reasoning?.trim() || '',
                        attributeBitMax: attrBits.max,
                        attributeBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    };
                }).filter(Boolean);

                if (extractedAttributesList.length === 0) {
                    throw new Error('ì¶”ì¶œëœ ìœ íš¨í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                }

                // ê²°ê³¼ í‘œì‹œ
                console.log('ë¶„ì„ ê²°ê³¼ í‘œì‹œ', { attributeCount: extractedAttributesList.length });
                $gptResponse.textContent = analysisData.response;
                displayExtractedAttributes();
                $gptResultCard.style.display = 'block';
                $gptStatus.textContent = `âœ“ ë¶„ì„ ì™„ë£Œ: ${extractedAttributesList.length}ê°œ ì†ì„± ì¶”ì¶œë¨. ìë™ ì €ì¥ ì¤‘...`;
                $gptStatus.style.color = '#007bff';

                // ìë™ ì €ì¥ ì‹¤í–‰
                console.log('ìë™ ì €ì¥ ì‹œì‘');
                await saveAllAttributes();
                console.log('GPT ë¶„ì„ 2 ì™„ë£Œ');

            } catch (e) {
                console.error('GPT ë¶„ì„ 2 ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ë¶„ì„ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
                $gptResponse.textContent = `ì˜¤ë¥˜: ${e.message}`;
            } finally {
                $analyzeBtn1.disabled = false;
                $analyzeBtn2.disabled = false;
            }
        }


        // ë°ì´í„° ì…ë ¥ ì‹œ BIT ê³„ì‚°
        $newDataInput.addEventListener('input', (e) => {
            const text = e.target.value.trim();
            if (text) {
                const { max, min } = calculateBitValues(text);
                $newDataMax.textContent = max !== null ? max.toFixed(15) : '-';
                $newDataMin.textContent = min !== null ? min.toFixed(15) : '-';
            } else {
                $newDataMax.textContent = '-';
                $newDataMin.textContent = '-';
            }
        });

        // ì†ì„± ëª©ë¡ ë¡œë“œ
        async function loadAttributes() {
            console.log('ì†ì„± ëª©ë¡ ë¡œë“œ ì‹œì‘');
            try {
                $attributesList.innerHTML = '<div class="text-center text-muted">ë¡œë”© ì¤‘...</div>';
                
                // ëª¨ë“  ì†ì„± ëª©ë¡ ì¡°íšŒ
                const url = getServerUrl('/api/attributes/all');
                console.log('ì†ì„± ëª©ë¡ API ìš”ì²­', { url });
                const res = await fetch(url);

                console.log('ì†ì„± ëª©ë¡ API ì‘ë‹µ', { status: res.status });

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }

                const data = await res.json();
                console.log('ì†ì„± ëª©ë¡ ë°ì´í„° ìˆ˜ì‹ ', { ok: data.ok, attributeCount: data.attributes?.length || 0 });
                
                if (!data.ok || !data.attributes || data.attributes.length === 0) {
                    $attributesList.innerHTML = '<div class="text-center text-muted">ì €ì¥ëœ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                    return;
                }

                // ê° ì†ì„±ì˜ ë°ì´í„° ì¡°íšŒ
                const attributePromises = data.attributes.map(async (attr) => {
                    try {
                        const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${attr.bitMax}&bitMin=${attr.bitMin}&limit=100`);
                        const dataRes = await fetch(dataUrl);
                        if (dataRes.ok) {
                            const dataData = await dataRes.json();
                            if (dataData.ok && dataData.items) {
                                // ì†ì„± ìì²´ë¥¼ ë°ì´í„°ë¡œ ì €ì¥í•œ ê²½ìš°ëŠ” ì œì™¸
                                const dataList = dataData.items
                                    .filter(item => item.data && item.data.text && item.data.text !== attr.text)
                                    .map(item => item.data);
                                return {
                                    ...attr,
                                    dataList: dataList,
                                    dataCount: dataList.length
                                };
                            }
                        }
                    } catch (e) {
                        console.warn(`ì†ì„± "${attr.text}" ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:`, e);
                    }
                    return {
                        ...attr,
                        dataList: [],
                        dataCount: 0
                    };
                });

                const attributesWithData = await Promise.all(attributePromises);
                console.log('ì†ì„± ë°ì´í„° ì¡°íšŒ ì™„ë£Œ', { count: attributesWithData.length });

                // ì†ì„± ëª©ë¡ ë Œë”ë§
                console.log('ì†ì„± ëª©ë¡ ë Œë”ë§ ì‹œì‘');
                let html = '';
                attributesWithData.forEach((attr) => {
                    html += `
                        <div class="attribute-item" 
                             data-bit-max="${attr.bitMax}" 
                             data-bit-min="${attr.bitMin}"
                             data-attribute-text="${escapeHtml(attr.text)}">
                            <div class="attribute-header">
                                <div>
                                    <span class="attribute-name">${escapeHtml(attr.text)}</span>
                                </div>
                                <small class="text-muted">
                                    BIT: ${attr.bitMax.toFixed(15)}, ${attr.bitMin.toFixed(15)} | 
                                    ë°ì´í„° ${attr.dataCount}ê°œ
                                </small>
                            </div>
                            <div class="data-list">
                                ${attr.dataList.length > 0 ? attr.dataList.map(data => `
                                    <div class="data-item">
                                        <strong>${escapeHtml(data.text)}</strong>
                                        <small class="text-muted ms-2">
                                            BIT: ${data.bitMax.toFixed(15)}, ${data.bitMin.toFixed(15)}
                                        </small>
                                    </div>
                                `).join('') : '<div class="text-muted small">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>'}
                            </div>
                        </div>
                    `;
                });

                $attributesList.innerHTML = html;
                console.log('ì†ì„± ëª©ë¡ ë Œë”ë§ ì™„ë£Œ', { renderedCount: attributesWithData.length });
            } catch (e) {
                console.error('ì†ì„± ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜:', e);
                $attributesList.innerHTML = `<div class="text-danger">âœ— ë¡œë“œ ì‹¤íŒ¨: ${e.message}</div>`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ë°ì´í„° ì¶”ê°€ ëª¨ë‹¬ ì—´ê¸°
        window.openAddDataModal = function(attributeText, attributeBitMax, attributeBitMin) {
            currentAttribute = {
                text: attributeText,
                bitMax: attributeBitMax,
                bitMin: attributeBitMin
            };
            
            $modalAttributeName.textContent = attributeText;
            $modalAttributeMax.textContent = attributeBitMax.toFixed(15);
            $modalAttributeMin.textContent = attributeBitMin.toFixed(15);
            $newDataInput.value = '';
            $newDataMax.textContent = '-';
            $newDataMin.textContent = '-';
            $saveDataStatus.textContent = '';
            
            addDataModal.show();
        };

        // ë°ì´í„° ì €ì¥
        $saveDataBtn.addEventListener('click', async () => {
            console.log('ë°ì´í„° ì €ì¥ ë²„íŠ¼ í´ë¦­');
            
            if (!currentAttribute) {
                console.warn('ë°ì´í„° ì €ì¥: ì†ì„± ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                $saveDataStatus.textContent = 'âœ— ì†ì„± ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            const dataText = $newDataInput.value.trim();
            if (!dataText) {
                console.warn('ë°ì´í„° ì €ì¥: ë°ì´í„°ê°€ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                $saveDataStatus.textContent = 'âœ— ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            console.log('ë°ì´í„° ì €ì¥ ì‹œì‘', { attribute: currentAttribute.text, dataLength: dataText.length });
            
            const { max, min } = calculateBitValues(dataText);
            console.log('ë°ì´í„° BIT ê³„ì‚°', { max, min });
            
            if (max === null || min === null) {
                console.error('ë°ì´í„° ì €ì¥: BIT ê°’ ê³„ì‚° ì‹¤íŒ¨');
                $saveDataStatus.textContent = 'âœ— BIT ê°’ ê³„ì‚° ì‹¤íŒ¨.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            try {
                $saveDataBtn.disabled = true;
                $saveDataStatus.textContent = 'ì €ì¥ ì¤‘...';
                $saveDataStatus.style.color = '#007bff';

                console.log('ë°ì´í„° ì €ì¥ API ìš”ì²­');
                const url = getServerUrl('/api/attributes/data');
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        attributeText: currentAttribute.text,
                        attributeBitMax: currentAttribute.bitMax,
                        attributeBitMin: currentAttribute.bitMin,
                        text: dataText,
                        dataBitMax: max,
                        dataBitMin: min
                    })
                });

                console.log('ë°ì´í„° ì €ì¥ API ì‘ë‹µ', { status: res.status });

                if (!res.ok) {
                    const errorText = await res.text();
                    console.error('ë°ì´í„° ì €ì¥ API ì˜¤ë¥˜', { status: res.status, error: errorText });
                    throw new Error(`HTTP ${res.status}: ${errorText}`);
                }

                const data = await res.json();
                console.log('ë°ì´í„° ì €ì¥ ê²°ê³¼', { ok: data.ok, duplicate: data.duplicate });
                
                if (!data.ok) {
                    throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
                }

                if (data.duplicate) {
                    console.warn('ë°ì´í„° ì¤‘ë³µ ì €ì¥ ì‹œë„');
                    $saveDataStatus.textContent = 'âš  ì´ë¯¸ ë™ì¼í•œ ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.';
                    $saveDataStatus.style.color = '#ffc107';
                } else {
                    console.log('ë°ì´í„° ì €ì¥ ì™„ë£Œ');
                    $saveDataStatus.textContent = 'âœ“ ë°ì´í„° ì €ì¥ ì™„ë£Œ';
                    $saveDataStatus.style.color = '#28a745';
                    $newDataInput.value = '';
                    $newDataMax.textContent = '-';
                    $newDataMin.textContent = '-';
                    
                    setTimeout(() => {
                        addDataModal.hide();
                        loadAttributes();
                    }, 1000);
                }
            } catch (e) {
                console.error('ë°ì´í„° ì €ì¥ ì˜¤ë¥˜:', e);
                $saveDataStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
                $saveDataStatus.style.color = '#dc3545';
            } finally {
                $saveDataBtn.disabled = false;
            }
        });

        // ì†ì„±ìœ¼ë¡œ ê²€ìƒ‰
        window.searchByAttribute = function(attributeText, attributeBitMax, attributeBitMin) {
            window.location.href = `bit_search.html?attribute=${encodeURIComponent(attributeText)}&bitMax=${attributeBitMax}&bitMin=${attributeBitMin}`;
        };

        // ìƒˆë¡œê³ ì¹¨
        $refreshBtn.addEventListener('click', () => {
            console.log('ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­');
            loadAttributes();
        });

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì†ì„± ëª©ë¡ ë¡œë“œ
        console.log('í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ, ì†ì„± ëª©ë¡ ë¡œë“œ ì‹œì‘');
        loadAttributes();
    </script>
</body>
</html>

