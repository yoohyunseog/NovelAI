<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BIT_MAX / BIT_MIN ì‹¤ì‹œê°„ ê³„ì‚°</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { font-family: Arial, sans-serif; margin: 24px; }
        @media (max-width: 1024px) {
            body > div[style*="display: flex"] { flex-direction: column !important; }
            body > div[style*="display: flex"] > div[style*="flex: 0 0 400px"] { flex: 1 1 auto !important; position: static !important; }
        }
        .row { margin-bottom: 16px; }
        label { display: block; margin-bottom: 8px; font-weight: bold; }
        input[type="text"] { width: 100%; padding: 10px; font-size: 16px; }
        textarea { width: 100%; padding: 10px; font-size: 16px; min-height: 150px; resize: vertical; font-family: inherit; border: 1px solid #ccc; border-radius: 4px; }
        .result { display: flex; gap: 16px; flex-wrap: wrap; }
        .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px 16px; min-width: 220px; }
        .value { font-size: 24px; font-weight: bold; margin-top: 8px; }
        .muted { color: #666; font-size: 12px; }
        .controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-top: 8px; }
        button { padding: 8px 12px; border: 1px solid #bbb; background: #f7f7f7; border-radius: 6px; cursor: pointer; }
        button:hover { background: #eee; }
        .history { margin-top: 16px; }
        details summary { cursor: pointer; user-select: none; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #e5e5e5; padding: 6px 8px; text-align: left; font-size: 12px; }
        th { background: #fafafa; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://xn--9l4b4xi9r.com/_8%EB%B9%84%ED%8A%B8/js/bitCalculation.js" defer></script>
</head>
<body>
    <div class="container-fluid">
        <!-- ì†Œì„¤ ì „ìš© ë ˆì´ì•„ì›ƒ -->
        <!-- ìƒë‹¨: ì†Œì„¤ ì„ íƒ + ì±•í„° ëª©ë¡ (ë†’ì´ ì œí•œ + ìŠ¤í¬ë¡¤) -->
        <div class="row g-3 mb-3">
            <div class="col-12">
                <div class="card">
                    <div class="card-header d-flex align-items-center justify-content-between"><strong>ğŸ“– ì±•í„° ëª©ë¡</strong>
                        <div class="d-flex gap-2 align-items-center">
                            <select id="novelSelect" class="form-select form-select-sm" style="min-width: 220px;"></select>
                            <button id="newNovelBtn" class="btn btn-sm btn-outline-primary">ìƒˆ ì†Œì„¤</button>
                        </div>
                    </div>
                    <div class="card-body p-2" style="max-height: 150px; overflow-y: auto;">
                        <div id="chapterList" class="d-flex gap-2 flex-wrap">
                            <span class="text-muted small">ìƒì„±ëœ ì±•í„°ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ìƒë‹¨: ì†Œì„¤ ì •ë³´ (width 100%) -->
        <div class="row g-3 mb-3">
            <div class="col-12">
                <div class="card">
                    <div class="card-header"><strong>ğŸ“š ì†Œì„¤ ì •ë³´</strong></div>
                    <div class="card-body">
                        <div class="row g-3">
                            <div class="col-12 col-md-4">
                                <label class="form-label">ì œëª©</label>
                                <input id="novelTitle" class="form-control" placeholder="ì˜ˆ: íí—ˆì˜ ì„œì‚¬" />
                            </div>
                            <div class="col-12 col-md-4">
                                <label class="form-label">ì¥ë¥´</label>
                                <input id="novelGenre" class="form-control" placeholder="ì˜ˆ: ë‹¤í¬ íŒíƒ€ì§€" />
                            </div>
                            <div class="col-12 col-md-4">
                                <label class="form-label">ì¥ ìˆ˜</label>
                                <input id="novelChapters" type="number" class="form-control" value="6" min="3" max="20" />
                            </div>
                            <div class="col-12">
                                <label class="form-label">ì£¼ìš” ë“±ì¥ì¸ë¬¼</label>
                                <div id="characterCards" class="row g-2" style="max-height: 180px; overflow-y: auto;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ë³¸ë¬¸ ë ˆì´ì•„ì›ƒ -->
        <div class="row g-3 mb-3">
            <!-- ì¢Œì¸¡: í¸ì§‘ ê°€ëŠ¥í•œ í˜„ì¬ ì†Œì„¤ ì»¨í…ìŠ¤íŠ¸ -->
            <div class="col-12 col-lg-3">
                <div class="card mb-3">
                    <div class="card-header"><strong>ğŸ“ í˜„ì¬ ì†Œì„¤ ì»¨í…ìŠ¤íŠ¸ (í¸ì§‘ ê°€ëŠ¥)</strong></div>
                    <div class="card-body" style="max-height:70vh; overflow:auto;">
                        <div class="mb-3">
                            <label class="form-label">í˜„ì¬ ì±•í„°</label>
                            <input id="currentChapter" class="form-control" placeholder="ì˜ˆ: ì œ1ì¥: ê·¸ë¦¼ìì˜ ì‹œì‘" />
                        </div>
                        <div class="mb-3">
                            <label class="form-label">ì£¼ìš” ìºë¦­í„° ë° ìœ„ì¹˜</label>
                            <textarea id="characterLocations" class="form-control" rows="6" placeholder="ì˜ˆ:&#10;- ì¹´ì´: íí—ˆê°€ ëœ ë§ˆì„, ë™ìª½ ìˆ²&#10;- ì„¸ë¦¬ì—˜: ì—˜í”„ ê°€ë“œ ìº í”„, ì„œìª½ ê³„ê³¡&#10;- ë¦¬ì•„ë‚˜: ë§ˆì„ ê´‘ì¥, ì¤‘ì•™ ë¶„ìˆ˜ëŒ€"></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">í˜„ì¬ ì¥ì†Œ/ë°°ê²½</label>
                            <textarea id="currentPlace" class="form-control" rows="3" placeholder="ì˜ˆ: íí—ˆê°€ ëœ ë§ˆì„ì˜ ì¤‘ì‹¬ë¶€. ë¶€ì„œì§„ ëŒë‹´ê³¼ ë¬´ë„ˆì§„ ì§‘ë“¤ì´ ë°”ëŒì— í”ë“¤ë¦¬ê³  ìˆë‹¤. ì–´ë‘ ì´ ë‚´ë ¤ì•‰ê¸° ì‹œì‘í–ˆë‹¤."></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">ìµœê·¼ ì‚¬ê±´/ìƒí™©</label>
                            <textarea id="recentEvents" class="form-control" rows="4" placeholder="ì˜ˆ: ì—˜í”„ ê°€ë“œê°€ ê·¸ë¦¼ì ì‚¬ëƒ¥ê¾¼ ìì¹´ë¥´ì™€ ëŒ€ì¹˜ ì¤‘. ì¹´ì´ëŠ” ìì‹ ì˜ í˜ì„ ì²˜ìŒ ë°œê²¬í–ˆë‹¤."></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label">ë‹¤ìŒ ì „ê°œ ë°©í–¥ (ì„ íƒ)</label>
                            <input id="nextDirection" class="form-control" placeholder="ì˜ˆ: ì „íˆ¬ ì¥ë©´ìœ¼ë¡œ ì „í™˜" />
                        </div>
                        <div class="alert alert-info small">
                            <strong>ğŸ’¡</strong> ì´ ì •ë³´ê°€ GPT í”„ë¡¬í”„íŠ¸ë¡œ ìë™ ì‚¬ìš©ë©ë‹ˆë‹¤. ì›í•˜ëŠ” ëŒ€ë¡œ ìˆ˜ì •í•˜ì„¸ìš”.
                        </div>
                    </div>
                </div>
            </div>

            <!-- ì¤‘ì•™: ì†Œì„¤ ë³¸ë¬¸ -->
            <div class="col-12 col-lg-6">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <strong>ğŸ—ºï¸ í˜„ì¬ ì§€ë„ ë°°ê²½ + ë³¸ë¬¸</strong>
                        <span id="novelProgress" class="small text-muted"></span>
                    </div>
                    <div class="card-body p-0">
                        <div id="mapBackdrop" style="background: radial-gradient(circle at 20% 30%, #1f2937, #0f172a 60%), url('data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'40\' height=\'40\'><rect width=\'40\' height=\'40\' fill=\'none\' stroke=\'%23222\' stroke-width=\'1\'/></svg>'); background-size: cover, 40px 40px; padding: 16px; min-height: 70vh;">
                            <div id="novelContent" class="bg-dark text-light rounded p-3" style="min-height: 60vh; white-space: pre-wrap; line-height: 1.8;">ì—¬ê¸°ì— ì™„ì„± ì†Œì„¤ì´ ìƒì„±ë©ë‹ˆë‹¤...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ìš°ì¸¡: ì†Œì„¤ ì‹¤í–‰ -->
            <div class="col-12 col-lg-3">
                <div class="card h-100">
                    <div class="card-header"><strong>ğŸ¬ ì†Œì„¤ ì‹¤í–‰</strong></div>
                    <div id="novelExecBody" class="card-body" style="max-height:70vh; overflow:auto;">
                        <div class="d-flex gap-2 align-items-center flex-wrap">
                            <div class="btn-group" role="group" aria-label="chapter-nav">
                                <button id="prevChapterBtn" class="btn btn-outline-secondary">ì´ì „</button>
                                <button id="nextChapterBtn" class="btn btn-outline-secondary">ë‹¤ìŒ</button>
                            </div>
                            <button id="stopNovelBtn" class="btn btn-outline-secondary">ì¤‘ì§€</button>
                        </div>
                        <div class="form-check form-switch mt-2">
                            <input class="form-check-input" type="checkbox" id="autoNovelToggle" checked>
                            <label class="form-check-label small" for="autoNovelToggle">ë¬¸ì ì…ë ¥ ì‹œ ìë™ ìƒì„±</label>
                        </div>
                        <div class="mt-2 small text-muted d-flex align-items-center gap-2" id="novelStatus">
                            <span id="novelStatusText"></span>
                            <span id="novelLoading" class="spinner-border spinner-border-sm text-primary d-none" role="status" aria-hidden="true"></span>
                        </div>
                        <hr />
                        <div class="mb-2">
                            <label for="novelIdeaInput" class="form-label">ìƒˆ ì…ë ¥ë€ (ì†Œì„¤ ì•„ì´ë””ì–´/ë©”ëª¨)</label>
                            <textarea id="novelIdeaInput" class="form-control" placeholder="ì˜ˆ) ë‹¤ìŒ ì¥ë©´ ì•„ì´ë””ì–´, ì¸ë¬¼ ê°ì • ë³€í™”, ë°°ê²½ ì‚¬ìš´ë“œ ë¬˜ì‚¬ ë“±" rows="4"></textarea>
                            <div class="form-text">ì…ë ¥ ì‹œ ìë™ ì €ì¥ë˜ë©° ì»¨í…ìŠ¤íŠ¸ì— ë°˜ì˜ë©ë‹ˆë‹¤.</div>
                            <div class="small text-muted mt-1" id="notesSaveStatus"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row g-3">
            <!-- ì¢Œì¸¡: ë¬¸ì ì…ë ¥ ë° BIT ê³„ì‚° ì˜ì—­ (ì†Œì„¤ ë³¸ë¬¸ ìœ„ìª½ì—ì„œ ì´ë¯¸ ë…¸ì¶œë˜ë¯€ë¡œ í•˜ë‹¨ìœ¼ë¡œ ìš°ì„ ìˆœìœ„ ì¡°ì •) -->
            <div class="col-lg-7 order-2 order-lg-1">
                <!-- ì…ë ¥ ì˜ì—­ì€ í˜ì´ì§€ í•˜ë‹¨ìœ¼ë¡œ ì´ë™ë¨ -->

                <div class="result mb-3">
                    <div class="card d-inline-block me-2 mb-2" style="min-width: 220px;">
                        <div class="card-body">
                            <div class="small">BIT_MAX</div>
                            <div id="bitMax" class="value">-</div>
                            <div class="muted small" id="bitMaxMeta"></div>
                        </div>
                    </div>
                    <div class="card d-inline-block me-2 mb-2" style="min-width: 220px;">
                        <div class="card-body">
                            <div class="small">BIT_MIN</div>
                            <div id="bitMin" class="value">-</div>
                            <div class="muted small" id="bitMinMeta"></div>
                        </div>
                    </div>
                    <div class="card d-inline-block me-2 mb-2" style="min-width: 220px;">
                        <div class="card-body">
                            <div class="small">ì˜ˆì¸¡ NEXT_MAX</div>
                            <div id="predMax" class="value">-</div>
                            <div class="muted small" id="predMaxMeta">ìµœê·¼ ì¶”ì„¸ ê¸°ë°˜</div>
                        </div>
                    </div>
                    <div class="card d-inline-block me-2 mb-2" style="min-width: 220px;">
                        <div class="card-body">
                            <div class="small">ì˜ˆì¸¡ NEXT_MIN</div>
                            <div id="predMin" class="value">-</div>
                            <div class="muted small" id="predMinMeta">ìµœê·¼ ì¶”ì„¸ ê¸°ë°˜</div>
                        </div>
                    </div>
                </div>

                <div class="mb-3">
                    <h5>ì˜ˆì¸¡ ì…ë ¥ê°’</h5>
                    <div id="inputPredictions" class="border rounded p-2" style="max-height: 300px; overflow-y: auto;">
                        <!-- ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                    </div>
                </div>

                <div class="history">
                    <h5>ê¸°ë¡ ë³´ê¸°</h5>
                    <div class="table-responsive">
                        <table class="table table-sm table-bordered">
                            <thead class="table-light">
                                <tr>
                                    <th>#</th>
                                    <th>ì‹œê°„</th>
                                    <th>ì…ë ¥</th>
                                    <th>ASCII_CODES</th>
                                    <th>BIT_MAX</th>
                                    <th>BIT_MIN</th>
                                    <th>ì¶œì²˜</th>
                                </tr>
                            </thead>
                            <tbody id="historyBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- ìš°ì¸¡: GPT AI -->
            <div class="col-lg-5 order-1 order-lg-2" id="gptPanel">
                <div class="sticky-top" style="top: 24px;">
                    <h5 class="mb-3">GPT AI</h5>
                    
                    <!-- GPT ì„¤ì • -->
                    <div class="accordion mb-3" id="gptSettingsAccordion">
                        <div class="accordion-item">
                            <h2 class="accordion-header">
                                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#gptSettingsCollapse">
                                    ì„¤ì • (API í‚¤ ì…ë ¥)
                                </button>
                            </h2>
                            <div id="gptSettingsCollapse" class="accordion-collapse collapse" data-bs-parent="#gptSettingsAccordion">
                                <div class="accordion-body">
                                    <label for="gptApiKey" class="form-label">OpenAI API í‚¤:</label>
                                    <input type="password" id="gptApiKey" class="form-control mb-2" placeholder="sk-..." />
                                    <div class="d-flex align-items-center gap-2">
                                        <button id="saveApiKeyBtn" class="btn btn-sm btn-primary">ì €ì¥</button>
                                        <span id="apiKeyStatus" class="small text-muted"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- GPT í”„ë¡¬í”„íŠ¸ ì…ë ¥ ë° ìƒì„± -->
                    <div class="mb-3">
                        <label for="gptPrompt" class="form-label">í”„ë¡¬í”„íŠ¸ ì…ë ¥:</label>
                        <textarea id="gptPrompt" class="form-control" placeholder="ì˜ˆ) íí—ˆê°€ ëœ ë§ˆì„ì— ìƒˆë¡œìš´ NPCë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.&#10;íí—ˆê°€ ëœ ë§ˆì„ì˜ ìŠ¤í† ë¦¬ë¥¼ ê³„ì† ë°œì „ì‹œì¼œì£¼ì„¸ìš”.&#10;ì—”í„°ë¥¼ ëˆ„ë¥´ë©´ GPTê°€ íí—ˆê°€ ëœ ë§ˆì„ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‘ë‹µí•©ë‹ˆë‹¤." rows="6"></textarea>
                        <div class="mt-2">
                            <div class="btn-group mb-2" role="group">
                                <button id="gptGenerateBtn" class="btn btn-primary">ìƒì„±</button>
                                <button id="gptUseCurrentBtn" class="btn btn-success">í˜„ì¬ ì…ë ¥ ì‚¬ìš©</button>
                            </div>
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="gptUseSystemMsg" checked />
                                <label class="form-check-label" for="gptUseSystemMsg">ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì‚¬ìš©</label>
                            </div>
                            <span id="gptStatus" class="small text-muted ms-2"></span>
                        </div>

                        <!-- ë˜ì „ AI ì»¨íŠ¸ë¡¤ (ê²½ëŸ‰) -->
                        <div class="mt-3 p-2 border rounded" style="background:#f9fafb;">
                            <div class="d-flex align-items-center gap-2 flex-wrap">
                                <strong class="me-2">ë˜ì „ AI</strong>
                        <button id="dungeonStartBtn" class="btn btn-sm btn-outline-dark">ì‹œì‘</button>
                        <button id="dungeonNextBtn" class="btn btn-sm btn-outline-primary">ë‹¤ìŒ í„´</button>
                        <button id="useNovelFlowBtn" class="btn btn-sm btn-success">ì†Œì„¤ ì™„ì„± ì‹œì‘(ì¢Œì¸¡)</button>
                                <span id="dungeonStatus" class="small text-muted"></span>
                            </div>
                        </div>
                        
                        <div class="mt-2">
                            <label class="form-label fw-bold">GPT ì‘ë‹µ:</label>
                            <div id="gptResponse" class="border rounded p-3 bg-light" style="min-height: 200px; max-height: 400px; overflow-y: auto; white-space: pre-wrap; font-family: inherit; font-size: 14px; line-height: 1.6;">ì‘ë‹µì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...</div>
                            <div class="mt-2 d-flex gap-2 align-items-center">
                                <button id="gptCopyBtn" class="btn btn-sm btn-outline-secondary">ë³µì‚¬</button>
                                <button id="gptClearBtn" class="btn btn-sm btn-outline-secondary">ì§€ìš°ê¸°</button>
                                <span id="gptUsageInfo" class="small text-muted"></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- í•˜ë‹¨: ì…ë ¥ & ìƒˆ ì…ë ¥ë€ -->
    <div class="row g-3 mt-3">
        <div class="col-12">
            <div class="card">
                <div class="card-header"><strong>ì…ë ¥ & ê³„ì‚°</strong></div>
                <div class="card-body">
                    <div class="mb-3">
                        <label for="textInput" class="form-label">ë¬¸ìë¥¼ ì…ë ¥í•˜ì„¸ìš” (ì…ë ¥ ì‹œ ì‹¤ì‹œê°„ ê³„ì‚°)</label>
                        <textarea id="textInput" class="form-control" placeholder="ì˜ˆ) ì•ˆë…•í•˜ì„¸ìš” Hello 123&#10;ê¸´ ë¬¸ì¥ì´ë‚˜ ì†Œì„¤ë„ ì…ë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.&#10;ì—”í„°ë¥¼ ëˆ„ë¥´ë©´ GPTê°€ ì‘ë‹µí•©ë‹ˆë‹¤." autocomplete="off" rows="6"></textarea>
                        <div class="controls mt-2">
                            <div class="form-check form-check-inline">
                                <input class="form-check-input" type="checkbox" id="autoSaveToggle" checked />
                                <label class="form-check-label" for="autoSaveToggle">ìë™ ì €ì¥</label>
                            </div>
                            <button id="exportBtn" class="btn btn-sm btn-outline-secondary">ë‚´ë³´ë‚´ê¸°(JSON)</button>
                            <button id="clearBtn" class="btn btn-sm btn-outline-secondary">ê¸°ë¡ ë¹„ìš°ê¸°</button>
                            <span class="muted ms-2" id="historyInfo"></span>
                        </div>
                    </div>

                    <div class="mb-3">
                        <label for="novelIdeaInput" class="form-label">ìƒˆ ì…ë ¥ë€ (ì†Œì„¤ ì•„ì´ë””ì–´/ë©”ëª¨)</label>
                        <textarea id="novelIdeaInput" class="form-control" placeholder="ì˜ˆ) ë‹¤ìŒ ì¥ë©´ ì•„ì´ë””ì–´, ì¸ë¬¼ ê°ì • ë³€í™”, ë°°ê²½ ì‚¬ìš´ë“œ ë¬˜ì‚¬ ë“±" rows="4"></textarea>
                        <div class="form-text">ì´ ì…ë ¥ì€ ì»¨í…ìŠ¤íŠ¸ì— ì°¸ê³ ìš©ìœ¼ë¡œ í¬í•¨ë©ë‹ˆë‹¤.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    // ===== ì„œë²„ URL í—¬í¼ í•¨ìˆ˜ =====
    function getServerUrl(path) {
      // file:// í”„ë¡œí† ì½œì—ì„œ ì—´ë¦° ê²½ìš° localhost:8123 ì‚¬ìš©
      if (window.location.protocol === 'file:') {
        return `http://localhost:8123${path}`;
      }
      // http/https í”„ë¡œí† ì½œì—ì„œëŠ” ìƒëŒ€ ê²½ë¡œ ì‚¬ìš©
      return path;
    }
    
    // ===== ì™¸ë¶€ ìŠ¤í¬ë¦½íŠ¸ ìš°ì„  ì‚¬ìš©, ì—†ìœ¼ë©´ ë¡œì»¬ êµ¬í˜„ìœ¼ë¡œ í´ë°± =====
    (function(){
      if (typeof window.BIT_MAX_NB === 'undefined') {
        const initializeArrays = function(count) {
          const arrays = ['BIT_START_A50', 'BIT_START_A100', 'BIT_START_B50', 'BIT_START_B100', 'BIT_START_NBA100'];
          const initializedArrays = {};
          arrays.forEach(array => {
            initializedArrays[array] = new Array(count).fill(0);
          });
          return initializedArrays;
        };

        const calculateBit = function(nb, bit = 5.5, reverse = false) {
          if (nb.length < 2) {
            return bit / 100;
          }
          const BIT_NB = bit;
          const max = Math.max(...nb);
          const min = Math.min(...nb);
          const COUNT = 50;
          const CONT = 20;
          const range = max - min;
          const negativeRange = min < 0 ? Math.abs(min) : 0;
          const positiveRange = max > 0 ? max : 0;
          const negativeIncrement = negativeRange / (COUNT * nb.length - 1);
          const positiveIncrement = positiveRange / (COUNT * nb.length - 1);
          const arrays = initializeArrays(COUNT * nb.length);
          let count = 0;
          let totalSum = 0;
          for (let value of nb) {
            for (let i = 0; i < COUNT; i++) {
              const BIT_END = 1;
              const A50 = value < 0 ? min + negativeIncrement * (count + 1)
                                    : min + positiveIncrement * (count + 1);
              const A100 = (count + 1) * BIT_NB / (COUNT * nb.length);
              const B50 = value < 0 ? A50 - negativeIncrement * 2 : A50 - positiveIncrement * 2;
              const B100 = value < 0 ? A50 + negativeIncrement : A50 + positiveIncrement;
              const NBA100 = A100 / (nb.length - 1);
              arrays.BIT_START_A50[count] = A50;
              arrays.BIT_START_A100[count] = A100;
              arrays.BIT_START_B50[count] = B50;
              arrays.BIT_START_B100[count] = B100;
              arrays.BIT_START_NBA100[count] = NBA100;
              count++;
            }
            totalSum += value;
          }
          if (reverse) {
            arrays.BIT_START_NBA100.reverse();
          }
          let NB50 = 0;
          for (let value of nb) {
            for (let a = 0; a < arrays.BIT_START_NBA100.length; a++) {
              if (arrays.BIT_START_B50[a] <= value && arrays.BIT_START_B100[a] >= value) {
                NB50 += arrays.BIT_START_NBA100[Math.min(a, arrays.BIT_START_NBA100.length - 1)];
                break;
              }
            }
          }
          if (nb.length === 2) {
            return bit - NB50;
          }
          return NB50;
        };

        let SUPER_BIT = 0;
        const updateSuperBit = function(newValue) { SUPER_BIT = newValue; };
        const BIT_MAX_NB = function(nb, bit = 5.5) {
          let result = calculateBit(nb, bit, false);
          if (!isFinite(result) || isNaN(result) || result > 100 || result < -100) {
            return SUPER_BIT;
          } else {
            updateSuperBit(result);
            return result;
          }
        };
        const BIT_MIN_NB = function(nb, bit = 5.5) {
          let result = calculateBit(nb, bit, true);
          if (!isFinite(result) || isNaN(result) || result > 100 || result < -100) {
            return SUPER_BIT;
          } else {
            updateSuperBit(result);
            return result;
          }
        };

        // expose to window
        window.initializeArrays = initializeArrays;
        window.calculateBit = calculateBit;
        window.BIT_MAX_NB = BIT_MAX_NB;
        window.BIT_MIN_NB = BIT_MIN_NB;
      }
    })();

    // ===== COUNT 200 ì˜¤ë²„ë¼ì´ë“œ =====
    (function(){
      const COUNT = 200;
      function ensureInit(len){
        if (typeof window.initializeArrays === 'function') return window.initializeArrays(len);
        return {
          BIT_START_A50: new Array(len).fill(0),
          BIT_START_A100: new Array(len).fill(0),
          BIT_START_B50: new Array(len).fill(0),
          BIT_START_B100: new Array(len).fill(0),
          BIT_START_NBA100: new Array(len).fill(0),
        };
      }
      function calculateBitOverride(nb, bit = 5.5, reverse = false) {
        if (!nb || nb.length < 2) return bit / 100;
        const BIT_NB = bit;
        const max = Math.max(...nb);
        const min = Math.min(...nb);
        const negativeRange = min < 0 ? Math.abs(min) : 0;
        const positiveRange = max > 0 ? max : 0;
        const negativeIncrement = negativeRange / (COUNT * nb.length - 1);
        const positiveIncrement = positiveRange / (COUNT * nb.length - 1);
        const arrays = ensureInit(COUNT * nb.length);
        let count = 0;
        for (let value of nb) {
          for (let i = 0; i < COUNT; i++) {
            const BIT_END = 1;
            const A50 = value < 0 ? min + negativeIncrement * (count + 1)
                                  : min + positiveIncrement * (count + 1);
            const A100 = (count + 1) * BIT_NB / (COUNT * nb.length);
            const B50 = value < 0 ? A50 - negativeIncrement * 2 : A50 - positiveIncrement * 2;
            const B100 = value < 0 ? A50 + negativeIncrement : A50 + positiveIncrement;
            const NBA100 = A100 / (nb.length - BIT_END);
            arrays.BIT_START_A50[count] = A50;
            arrays.BIT_START_A100[count] = A100;
            arrays.BIT_START_B50[count] = B50;
            arrays.BIT_START_B100[count] = B100;
            arrays.BIT_START_NBA100[count] = NBA100;
            count++;
          }
        }
        if (reverse) arrays.BIT_START_NBA100.reverse();
        let NB50 = 0;
        for (let value of nb) {
          for (let a = 0; a < arrays.BIT_START_NBA100.length; a++) {
            if (arrays.BIT_START_B50[a] <= value && arrays.BIT_START_B100[a] >= value) {
              NB50 += arrays.BIT_START_NBA100[Math.min(a, arrays.BIT_START_NBA100.length - 1)];
              break;
            }
          }
        }
        if (nb.length === 2) return bit - NB50;
        return NB50;
      }
      function updateSuperBit(v){ try { window.SUPER_BIT = v; } catch(e) {} }
      window.BIT_MAX_NB = function(nb, bit = 5.5){
        const result = calculateBitOverride(nb, bit, false);
        if (!isFinite(result) || isNaN(result) || result > 100 || result < -100) {
          return window.SUPER_BIT || 0;
        }
        updateSuperBit(result);
        return result;
      };
      window.BIT_MIN_NB = function(nb, bit = 5.5){
        const result = calculateBitOverride(nb, bit, true);
        if (!isFinite(result) || isNaN(result) || result > 100 || result < -100) {
          return window.SUPER_BIT || 0;
        }
        updateSuperBit(result);
        return result;
      };
    })();

    if (typeof window.wordNbUnicodeFormat !== 'function') {
    function wordNbUnicodeFormat(domain) {
      const defaultPrefix = '';
      if (!domain || domain.length === 0) {
        domain = defaultPrefix;
      } else {
        domain = defaultPrefix + domain;
      }
      const chars = Array.from(domain);
      const langRanges = [
        { range: [0xAC00, 0xD7AF], prefix: 1000000 },
        { range: [0x3040, 0x309F], prefix: 2000000 },
        { range: [0x30A0, 0x30FF], prefix: 3000000 },
        { range: [0x4E00, 0x9FFF], prefix: 4000000 },
        { range: [0x0410, 0x044F], prefix: 5000000 },
        { range: [0x0041, 0x007A], prefix: 6000000 },
        { range: [0x0590, 0x05FF], prefix: 7000000 },
        { range: [0x00C0, 0x00FD], prefix: 8000000 },
        { range: [0x0E00, 0x0E7F], prefix: 9000000 },
      ];
      return chars.map(char => {
        const unicodeValue = char.codePointAt(0);
        const lang = langRanges.find(lang =>
          unicodeValue >= lang.range[0] && unicodeValue <= lang.range[1]
        );
        const prefix = lang ? lang.prefix : 0;
        return prefix + unicodeValue;
      });
    }
    window.wordNbUnicodeFormat = wordNbUnicodeFormat;
    }

    // ===== UI ì—°ê²° =====
    const $input = document.getElementById('textInput');
    const $bitMax = document.getElementById('bitMax');
    const $bitMin = document.getElementById('bitMin');
    const $bitMaxMeta = document.getElementById('bitMaxMeta');
    const $bitMinMeta = document.getElementById('bitMinMeta');
    const $predMax = document.getElementById('predMax');
    const $predMin = document.getElementById('predMin');
    const $predMaxMeta = document.getElementById('predMaxMeta');
    const $predMinMeta = document.getElementById('predMinMeta');
    const $autoSave = document.getElementById('autoSaveToggle');
    const $exportBtn = document.getElementById('exportBtn');
    const $clearBtn = document.getElementById('clearBtn');
    const $historyInfo = document.getElementById('historyInfo');
    const $historyBody = document.getElementById('historyBody');
    const $inputPredictions = document.getElementById('inputPredictions');
    
    // GPT ê´€ë ¨ ìš”ì†Œ
    const $gptApiKey = document.getElementById('gptApiKey');
    const $saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
    const $apiKeyStatus = document.getElementById('apiKeyStatus');
    const $gptPrompt = document.getElementById('gptPrompt');
    const $gptGenerateBtn = document.getElementById('gptGenerateBtn');
    const $gptUseCurrentBtn = document.getElementById('gptUseCurrentBtn');
    const $gptUseSystemMsg = document.getElementById('gptUseSystemMsg');
    const $gptStatus = document.getElementById('gptStatus');
    const $gptResponse = document.getElementById('gptResponse');
    const $gptCopyBtn = document.getElementById('gptCopyBtn');
    const $gptClearBtn = document.getElementById('gptClearBtn');
    const $gptUsageInfo = document.getElementById('gptUsageInfo');

    // LocalStorage ì œê±°: ì„¸ì…˜ íˆìŠ¤í† ë¦¬ë§Œ ìœ ì§€, ì˜ì† ì €ì¥ì€ íŒŒì¼ì—ë§Œ ìˆ˜í–‰
    const sessionHistory = [];
    const DECIMALS = 15;
    const fmt = (v) => Number(v).toFixed(DECIMALS);
    const SETTINGS_KEY = 'bitui:settings';
    const DB_NAME = 'bitui';
    const DB_STORE = 'fsHandles';
    const DB_KEY_HISTORY = 'historyFile';
    const DB_HIST_NAME = 'bituiHist';
    const DB_HIST_STORE = 'records';

    

    // ===== IndexedDB helpers for persisting file handle =====
    function idbOpen() { return Promise.resolve(null); }
    async function idbPutHandle() { return; }
    async function idbGetHandle() { return null; }

    // ===== IndexedDB history (no file permission needed) =====
    function idbHistOpen() { return Promise.resolve(null); }
    async function idbHistAdd() { return; }
    async function idbHistClear() { return; }
    async function idbHistLoadAll() { return []; }

    // ===== Reload history from file on startup =====
    

    function asciiCodesFromString(str) {
      if (!str) return [];
      const chars = Array.from(str);
      const codes = [];
      for (const ch of chars) {
        const cp = ch.codePointAt(0);
        codes.push(cp);
      }
      return codes;
    }

    function renderHistoryInfo(history) {
      $historyInfo.textContent = `ê¸°ë¡ ${history.length}ê°œ`;
    }

    function renderHistoryTable(history) {
      $historyBody.innerHTML = '';
      const count = Math.min(history.length, 25); // ìµœê·¼ 25ê°œë§Œ í‘œì‹œ
      for (let r = 0; r < count; r++) {
        const h = history[history.length - 1 - r]; // ìµœì‹ ë¶€í„° ì—­ìˆœ
        const tr = document.createElement('tr');
        const idxTd = document.createElement('td'); idxTd.textContent = String(r + 1); // ìµœì‹ ì´ 1ë²ˆ
        const tTd = document.createElement('td'); tTd.textContent = new Date(h.t).toLocaleString();
        const sTd = document.createElement('td'); sTd.textContent = h.s;
        const asciiTd = document.createElement('td');
        const asciiList = Array.isArray(h.ascii) ? h.ascii : [];
        const fullAscii = `[${asciiList.join(', ')}]`;
        const shortAscii = asciiList.length > 30 ? `[${asciiList.slice(0,30).join(', ')} ...]` : fullAscii;
        asciiTd.textContent = shortAscii;
        asciiTd.title = fullAscii;
        const maxTd = document.createElement('td'); maxTd.textContent = fmt(h.max);
        const minTd = document.createElement('td'); minTd.textContent = fmt(h.min);
        const sourceTd = document.createElement('td');
        const source = h.source || 'ì €ì¥';
        sourceTd.textContent = source === 'saved' ? 'ì €ì¥' : source === 'fetched' ? 'ì¡°íšŒ' : source;
        sourceTd.style.color = source === 'saved' ? '#28a745' : source === 'fetched' ? '#007bff' : '#666';
        tr.appendChild(idxTd); tr.appendChild(tTd); tr.appendChild(sTd); tr.appendChild(asciiTd); tr.appendChild(maxTd); tr.appendChild(minTd); tr.appendChild(sourceTd);
        $historyBody.appendChild(tr);
      }
    }

    function appendHistoryRow(h, indexOneBased) {
      const tr = document.createElement('tr');
      tr.dataset.recordId = h.t; // ë ˆì½”ë“œ IDë¡œ ì‹ë³„
      const idxTd = document.createElement('td'); idxTd.textContent = String(indexOneBased);
      const tTd = document.createElement('td'); tTd.textContent = new Date(h.t).toLocaleString();
      const sTd = document.createElement('td'); sTd.textContent = h.s;
      const asciiTd = document.createElement('td');
      const asciiList = Array.isArray(h.ascii) ? h.ascii : [];
      const fullAscii = `[${asciiList.join(', ')}]`;
      const shortAscii = asciiList.length > 30 ? `[${asciiList.slice(0,30).join(', ')} ...]` : fullAscii;
      asciiTd.textContent = shortAscii;
      asciiTd.title = fullAscii;
      const maxTd = document.createElement('td'); maxTd.textContent = fmt(h.max);
      const minTd = document.createElement('td'); minTd.textContent = fmt(h.min);
      const sourceTd = document.createElement('td');
      sourceTd.className = 'source-cell';
      const source = h.source || 'checking';
      sourceTd.textContent = source === 'saved' ? 'ì €ì¥' : source === 'fetched' ? 'ì¡°íšŒ' : source === 'checking' ? 'í™•ì¸ì¤‘...' : source;
      sourceTd.style.color = source === 'saved' ? '#28a745' : source === 'fetched' ? '#007bff' : '#666';
      tr.appendChild(idxTd); tr.appendChild(tTd); tr.appendChild(sTd); tr.appendChild(asciiTd); tr.appendChild(maxTd); tr.appendChild(minTd); tr.appendChild(sourceTd);
      // ìµœì‹ ì´ 1ë²ˆì´ë¯€ë¡œ ìœ„ì— ë¶™ì´ê¸°
      if ($historyBody.firstChild) {
        $historyBody.insertBefore(tr, $historyBody.firstChild);
      } else {
        $historyBody.appendChild(tr);
      }
      // 25ê°œ ì´ˆê³¼ ì‹œ ë§ˆì§€ë§‰ í–‰ ì œê±°
      if ($historyBody.children.length > 25) {
        $historyBody.removeChild($historyBody.lastChild);
      }
      return tr; // í–‰ ì°¸ì¡° ë°˜í™˜
    }

    function linearPredict(values, useCount) {
      // values: number[]
      const n = Math.min(values.length, useCount);
      if (n < 2) return null;
      // x: 0..n-1, y: last n values
      let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
      for (let i = 0; i < n; i++) {
        const x = i;
        const y = values[values.length - n + i];
        sumX += x; sumY += y; sumXY += x * y; sumXX += x * x;
      }
      const denom = n * sumXX - sumX * sumX;
      if (denom === 0) return null;
      const a = (n * sumXY - sumX * sumY) / denom; // slope
      const b = (sumY - a * sumX) / n;             // intercept
      const nextX = n; // next index
      return a * nextX + b;
    }

    let lastTimer = null;
    let lastPredictAt = 0;
    let predictionTimer = null; // ì˜ˆì¸¡ ì…ë ¥ê°’ ê³„ì‚°ìš© ë³„ë„ íƒ€ì´ë¨¸
    const PREDICT_THROTTLE_MS = 250;
    function update() {
      const text = $input.value || '';
      const arr = (window.wordNbUnicodeFormat || wordNbUnicodeFormat)(text);
      if (arr.length === 0) {
        $bitMax.textContent = '-';
        $bitMin.textContent = '-';
        $bitMaxMeta.textContent = '';
        $bitMinMeta.textContent = '';
        $predMax.textContent = '-';
        $predMin.textContent = '-';
        if (predictionTimer) clearTimeout(predictionTimer);
        $inputPredictions.innerHTML = '';
        return;
      }
      try {
        const maxVal = (window.BIT_MAX_NB || (()=>0))(arr);
        const minVal = (window.BIT_MIN_NB || (()=>0))(arr);
        $bitMax.textContent = fmt(maxVal);
        $bitMin.textContent = fmt(minVal);
        $bitMaxMeta.textContent = `len=${arr.length}`;
        $bitMinMeta.textContent = `len=${arr.length}`;
        
        // ì˜ˆì¸¡ ì…ë ¥ê°’ ê³„ì‚° (ë¶€ë¶„ ë¬¸ìì—´ë“¤ì˜ BIT ê°’) - ë””ë°”ìš´ì‹± ë° ìµœì í™”
        if (predictionTimer) clearTimeout(predictionTimer);
        predictionTimer = setTimeout(() => {
          $inputPredictions.innerHTML = '';
          const currentText = $input.value || '';
          if (currentText.length > 0) {
            const chars = Array.from(currentText); // ìœ ë‹ˆì½”ë“œ ì•ˆì „ ë¶„í• 
            const totalLen = chars.length;
            
            // í‘œì‹œí•  ì¸ë±ìŠ¤ ê³„ì‚°: ì²˜ìŒ 15ê°œ, ì¤‘ê°„ 15ê°œ, ë§ˆì§€ë§‰ 15ê°œ
            const indicesToProcess = new Set();
            
            if (totalLen <= 45) {
              // 45ê°œ ì´í•˜ë©´ ëª¨ë‘ í‘œì‹œ
              for (let i = 1; i <= totalLen; i++) {
                indicesToProcess.add(i);
              }
            } else {
              // ì²˜ìŒ 15ê°œ
              for (let i = 1; i <= 15; i++) {
                indicesToProcess.add(i);
              }
              
              // ì¤‘ê°„ 15ê°œ (ì¤‘ê°„ ì§€ì  ê¸°ì¤€)
              const midPoint = Math.floor(totalLen / 2);
              const midStart = Math.max(16, midPoint - 7);
              const midEnd = Math.min(totalLen - 15, midStart + 14);
              for (let i = midStart; i <= midEnd; i++) {
                indicesToProcess.add(i);
              }
              
              // ë§ˆì§€ë§‰ 15ê°œ
              for (let i = Math.max(1, totalLen - 14); i <= totalLen; i++) {
                indicesToProcess.add(i);
              }
            }
            
            // ì¸ë±ìŠ¤ë¥¼ ì •ë ¬í•˜ì—¬ ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬
            const sortedIndices = Array.from(indicesToProcess).sort((a, b) => a - b);
            
            // ë¹„ë™ê¸° ì²˜ë¦¬ë¡œ UI ë¸”ë¡œí‚¹ ë°©ì§€
            const processBatch = (indexArray, startIdx) => {
              requestAnimationFrame(() => {
                const batchSize = 10; // í•œ ë²ˆì— 10ê°œì”© ì²˜ë¦¬
                const endIdx = Math.min(startIdx + batchSize, indexArray.length);
                
                for (let j = startIdx; j < endIdx; j++) {
                  const i = indexArray[j];
                  const partialText = chars.slice(0, i).join('');
                  const partialArr = (window.wordNbUnicodeFormat || wordNbUnicodeFormat)(partialText);
                  if (partialArr.length > 0) {
                    try {
                      const partialMax = (window.BIT_MAX_NB || (()=>0))(partialArr);
                      const partialMin = (window.BIT_MIN_NB || (()=>0))(partialArr);
                      const card = document.createElement('div');
                      card.style.cssText = 'border: 1px solid #ddd; border-radius: 6px; padding: 8px 12px; display: flex; justify-content: space-between; align-items: center;';
                      card.innerHTML = `
                        <div style="flex: 1;">
                          <strong style="font-size: 14px;">"${partialText.replace(/</g, '&lt;').replace(/>/g, '&gt;')}"</strong>
                          <span style="color: #666; font-size: 12px; margin-left: 8px;">(ê¸¸ì´ ${i})</span>
                        </div>
                        <div style="display: flex; gap: 16px; align-items: center;">
                          <div style="text-align: right;">
                            <div style="font-size: 11px; color: #666;">MAX</div>
                            <div style="font-size: 13px; font-weight: bold;">${fmt(partialMax)}</div>
                          </div>
                          <div style="text-align: right;">
                            <div style="font-size: 11px; color: #666;">MIN</div>
                            <div style="font-size: 13px; font-weight: bold;">${fmt(partialMin)}</div>
                          </div>
                        </div>
                      `;
                      $inputPredictions.appendChild(card);
                    } catch (e) {
                      // ê³„ì‚° ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ
                    }
                  }
                }
                
                // ë‹¤ìŒ ë°°ì¹˜ ì²˜ë¦¬
                if (endIdx < indexArray.length) {
                  processBatch(indexArray, endIdx);
                }
              });
            };
            
            // ì²« ë°°ì¹˜ë¶€í„° ì‹œì‘
            if (sortedIndices.length > 0) {
              processBatch(sortedIndices, 0);
            }
          }
        }, 300); // 300ms ë””ë°”ìš´ì‹±

        if ($autoSave.checked) {
          const ascii = asciiCodesFromString(text);
          const rec = { t: Date.now(), s: text, ascii, max: maxVal, min: minVal, source: 'checking' }; // ì¡°íšŒ ì¤‘ìœ¼ë¡œ ì´ˆê¸° ì„¤ì •
          sessionHistory.push(rec);
          renderHistoryInfo(sessionHistory);
          const row = appendHistoryRow(rec, 1);
          // save to IndexedDB (auto-save without file)
          idbHistAdd(rec);
          
          // ë¨¼ì € ì„œë²„ì—ì„œ ì¡°íšŒ ì‹œë„
          (async () => {
            try {
              // ì¡°íšŒ: ê°™ì€ max, min ê°’ì„ ê°€ì§„ ë°ì´í„° í™•ì¸
              const queryUrl = getServerUrl(`/api/log/by-max?nb_max=${encodeURIComponent(maxVal)}&n=100`);
              const queryRes = await fetch(queryUrl);
              const queryData = await queryRes.json();
              
              // ì¡°íšŒ ê²°ê³¼ì—ì„œ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ë°ì´í„° ì°¾ê¸°
              let found = false;
              if (queryData && queryData.items && Array.isArray(queryData.items)) {
                for (const item of queryData.items) {
                  if ((item.s ?? '') === (rec.s ?? '') &&
                      Math.abs(Number(item.max || 0) - maxVal) < 1e-10 &&
                      Math.abs(Number(item.min || 0) - minVal) < 1e-10) {
                    found = true;
                    break;
                  }
                }
              }
              
              if (found) {
                // ì¡°íšŒ ê²°ê³¼ê°€ ìˆìœ¼ë©´ "ì¡°íšŒ"ë¡œ í‘œì‹œí•˜ê³  ì €ì¥í•˜ì§€ ì•ŠìŒ
                rec.source = 'fetched';
                if (row) {
                  const sourceTd = row.querySelector('.source-cell') || row.children[6];
                  if (sourceTd) {
                    sourceTd.textContent = 'ì¡°íšŒ';
                    sourceTd.style.color = '#007bff';
                  }
                }
              } else {
                // ì¡°íšŒ ê²°ê³¼ê°€ ì—†ìœ¼ë©´ ì €ì¥í•˜ê³  "ì €ì¥"ìœ¼ë¡œ í‘œì‹œ
                rec.source = 'saved';
                if (row) {
                  const sourceTd = row.querySelector('.source-cell') || row.children[6];
                  if (sourceTd) {
                    sourceTd.textContent = 'ì €ì¥';
                    sourceTd.style.color = '#28a745';
                  }
                }
                // ì„œë²„ì— ì €ì¥
                try {
                  await fetch(getServerUrl('/api/log'), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ t: rec.t, s: rec.s, max: rec.max, min: rec.min })
                  });
                } catch (e) {
                  // ì €ì¥ ì‹¤íŒ¨ ë¬´ì‹œ
                }
              }
            } catch (e) {
              // ì¡°íšŒ ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ê°’ "ì €ì¥"ìœ¼ë¡œ ì²˜ë¦¬í•˜ê³  ì €ì¥ ì‹œë„
              rec.source = 'saved';
              if (row) {
                const sourceTd = row.querySelector('.source-cell') || row.children[6];
                if (sourceTd) {
                  sourceTd.textContent = 'ì €ì¥';
                  sourceTd.style.color = '#28a745';
                }
              }
              try {
                await fetch(getServerUrl('/api/log'), {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ t: rec.t, s: rec.s, max: rec.max, min: rec.min })
                });
              } catch (err) {
                // ì €ì¥ ì‹¤íŒ¨ ë¬´ì‹œ
              }
            }
          })();
          const now = performance.now();
          if (now - lastPredictAt >= PREDICT_THROTTLE_MS) {
            lastPredictAt = now;
            const useN = 20;
            const maxSeries = sessionHistory.map(h => Number(h.max)).filter(v => isFinite(v));
            const minSeries = sessionHistory.map(h => Number(h.min)).filter(v => isFinite(v));
            const predMax = linearPredict(maxSeries, useN);
            const predMin = linearPredict(minSeries, useN);
            $predMax.textContent = predMax == null ? '-' : fmt(predMax);
            $predMin.textContent = predMin == null ? '-' : fmt(predMin);
            $predMaxMeta.textContent = `ìµœê·¼ ${Math.min(maxSeries.length, useN)}ê°œ ê¸°ì¤€`;
            $predMinMeta.textContent = `ìµœê·¼ ${Math.min(minSeries.length, useN)}ê°œ ê¸°ì¤€`;
          }
        }
      } catch (e) {
        $bitMax.textContent = 'ì—ëŸ¬';
        $bitMin.textContent = 'ì—ëŸ¬';
        $bitMaxMeta.textContent = '';
        $bitMinMeta.textContent = '';
        $predMax.textContent = '-';
        $predMin.textContent = '-';
        console.error(e);
      }
    }

    function debouncedUpdate() {
      const DELAY = 120; // ms
      if (lastTimer) clearTimeout(lastTimer);
      lastTimer = setTimeout(update, DELAY);
    }

    $input.addEventListener('input', debouncedUpdate);

    // ===== GPT AI ê¸°ëŠ¥ =====
    // API í‚¤ ìƒíƒœ í™•ì¸
    async function checkApiKeyStatus() {
      try {
        const res = await fetch(getServerUrl('/api/gpt/key'));
        const data = await res.json();
        if (data.ok && data.hasKey) {
          $apiKeyStatus.textContent = 'âœ“ API í‚¤ê°€ ì„¤ì •ë˜ì–´ ìˆìŠµë‹ˆë‹¤';
          $apiKeyStatus.style.color = '#28a745';
        } else {
          $apiKeyStatus.textContent = 'âš  API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤';
          $apiKeyStatus.style.color = '#dc3545';
        }
      } catch (e) {
        $apiKeyStatus.textContent = 'âš  API í‚¤ í™•ì¸ ì‹¤íŒ¨';
        $apiKeyStatus.style.color = '#dc3545';
      }
    }

    // API í‚¤ ì €ì¥
    $saveApiKeyBtn.addEventListener('click', async () => {
      const apiKey = $gptApiKey.value.trim();
      if (!apiKey) {
        alert('API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”');
        return;
      }
      try {
        $saveApiKeyBtn.disabled = true;
        $saveApiKeyBtn.textContent = 'ì €ì¥ ì¤‘...';
        const res = await fetch(getServerUrl('/api/gpt/key'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ apiKey })
        });
        const data = await res.json();
        if (data.ok) {
          $apiKeyStatus.textContent = 'âœ“ API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤';
          $apiKeyStatus.style.color = '#28a745';
          $gptApiKey.value = '';
          alert('API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤');
        } else {
          alert('API í‚¤ ì €ì¥ ì‹¤íŒ¨: ' + (data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'));
        }
      } catch (e) {
        alert('API í‚¤ ì €ì¥ ì‹¤íŒ¨: ' + e.message);
      } finally {
        $saveApiKeyBtn.disabled = false;
        $saveApiKeyBtn.textContent = 'ì €ì¥';
      }
    });

    // í˜„ì¬ ì…ë ¥ í…ìŠ¤íŠ¸ë¥¼ í”„ë¡¬í”„íŠ¸ì— ì‚¬ìš©
    $gptUseCurrentBtn.addEventListener('click', () => {
      const currentText = $input.value.trim();
      if (currentText) {
        $gptPrompt.value = currentText;
      } else {
        alert('ì…ë ¥ëœ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤');
      }
    });

    // ìë™ ìºë¦­í„° ìƒì„± ë° ì„¸ê³„ê´€ ì €ì¥ (ì‚¬ìš©ì ì •ë³´ í¬í•¨)
    async function processInputForWorld(inputText, bitMax, bitMin, userId = 'user_default') {
      try {
        // 1. GPT ë¶„ì„ (í™”ì ì¶”ì¶œ + ì‚¬ìš©ì ì •ë³´ ë¶„ì„)
        const analyzeRes = await fetch(getServerUrl('/api/gpt/analyze'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ input: inputText, bitMax, bitMin, userId })
        });
        
        const analyzeData = await analyzeRes.json();
        if (!analyzeData.ok || !analyzeData.analysis) {
          return null;
        }
        
        const analysis = analyzeData.analysis;
        
        // 2. ìºë¦­í„°ê°€ ìˆìœ¼ë©´ ìƒì„±/ê°±ì‹  (ë‹¨, ì‚¬ìš©ì ì´ë¦„ê³¼ ê°™ìœ¼ë©´ NPCë¡œ ì €ì¥í•˜ì§€ ì•ŠìŒ)
        let npcId = null;
        const userName = analysis.user?.name || null;
        const whoName = analysis.who || null;
        
        // ì‚¬ìš©ì ì´ë¦„ê³¼ ë‹¤ë¥¸ ìºë¦­í„°ë§Œ NPCë¡œ ì €ì¥
        if (analysis.hasCharacter && whoName && whoName !== userName) {
          // ê¸°ì¡´ ìºë¦­í„°ë¥¼ ì´ë¦„ìœ¼ë¡œ ì°¾ê¸°
          const allCharsRes = await fetch(getServerUrl('/api/characters'));
          const allCharsData = await allCharsRes.json();
          
          let existingCharId = null;
          if (allCharsData.ok && allCharsData.characters) {
            const existingChar = allCharsData.characters.find(c => 
              c.name === whoName && !c.id?.startsWith('user_')
            );
            if (existingChar && existingChar.id) {
              existingCharId = existingChar.id;
            }
          }
          
          // ê¸°ì¡´ ìºë¦­í„°ê°€ ìˆìœ¼ë©´ ê·¸ ID ì‚¬ìš©, ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„±
          npcId = existingCharId || `npc_${Date.now()}_${whoName.replace(/[^a-zA-Z0-9ê°€-í£]/g, '_')}`;
          
          await fetch(getServerUrl('/api/characters'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              npcId,
              name: whoName,
              firstScene: analysis.place || 'ì•Œ ìˆ˜ ì—†ìŒ',
              emotion: analysis.emotion,
              tone: analysis.tone,
              bitState: { max: bitMax, min: bitMin },
              speaks: {
                input: inputText,
                bit: { max: bitMax, min: bitMin }
              }
            })
          });
        }
        
        // 3. ì¥ì†Œê°€ ìˆìœ¼ë©´ World Layerì— ì €ì¥ (ì—†ìœ¼ë©´ ê¸°ë³¸ê°’: íí—ˆê°€ ëœ ë§ˆì„)
        const defaultPlace = 'íí—ˆê°€ ëœ ë§ˆì„';
        const placeToUse = (analysis.hasPlace && analysis.place) ? analysis.place : defaultPlace;
        
        // í•­ìƒ ì¥ì†Œ ì •ë³´ ì €ì¥ (ê¸°ë³¸ê°’ì´ê±°ë‚˜ ë¶„ì„ëœ ì¥ì†Œ)
          await fetch(getServerUrl('/api/world'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
            place: placeToUse,
              coords: { x: bitMax, y: bitMin },
              npcIds: npcId ? [npcId] : []
            })
          });
        
        // ê¸°ë³¸ ì¥ì†Œ(íí—ˆê°€ ëœ ë§ˆì„) ì •ë³´ë„ ìƒˆë¡œê³ ì¹¨
        if (placeToUse === defaultPlace) {
          // ì‹¤ì‹œê°„ ë§ˆì„ ì •ë³´ ìƒˆë¡œê³ ì¹¨ ì œê±°ë¨
        }
        
        // 4. Memory DBì— ê¸°ë¡ ì €ì¥
        await fetch(getServerUrl('/api/memory'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            input: inputText,
            npcSpeaker: npcId,
            place: analysis.place || null,
            bit: { max: bitMax, min: bitMin }
          })
        });
        
        return { npcId, analysis };
      } catch (e) {
        console.error('[World] error:', e);
        return null;
      }
    }

    // GPT ìƒì„± í•¨ìˆ˜ (íí—ˆê°€ ëœ ë§ˆì„ ì •ë³´ ì¤‘ì‹¬)
    async function generateGptResponse() {
      let prompt = $gptPrompt.value.trim();
      
      // í”„ë¡¬í”„íŠ¸ê°€ ì—†ìœ¼ë©´ íí—ˆê°€ ëœ ë§ˆì„ ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í™•ì¥ ìš”ì²­
      if (!prompt) {
        prompt = 'íí—ˆê°€ ëœ ë§ˆì„ì˜ ìŠ¤í† ë¦¬ë¥¼ ê³„ì†í•´ì„œ ë°œì „ì‹œì¼œì£¼ì„¸ìš”. ìƒˆë¡œìš´ ì¥ë©´, NPC, ë˜ëŠ” ì‚¬ê±´ì„ ì¶”ê°€í•˜ì—¬ íí—ˆê°€ ëœ ë§ˆì„ì˜ ì„¸ê³„ê´€ì„ í™•ì¥í•´ì£¼ì„¸ìš”.';
      }

      try {
        $gptGenerateBtn.disabled = true;
        $gptStatus.textContent = 'ìƒì„± ì¤‘...';
        $gptStatus.style.color = '#007bff';
        $gptResponse.textContent = 'ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...';

        // íí—ˆê°€ ëœ ë§ˆì„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ê¸°ë³¸ ì»¨í…ìŠ¤íŠ¸)
        let villageContext = '';
        try {
          const villageName = 'íí—ˆê°€ ëœ ë§ˆì„';
          const villageRes = await fetch(getServerUrl(`/api/world/${encodeURIComponent(villageName)}`));
          if (villageRes.ok) {
            const villageData = await villageRes.json();
            if (villageData.ok && villageData.world) {
              const world = villageData.world;
              villageContext = `[íí—ˆê°€ ëœ ë§ˆì„ - í˜„ì¬ ì •ë³´]\n`;
              villageContext += `ì¥ì†Œ: ${world.place}\n`;
              if (world.coords) {
                villageContext += `ì¢Œí‘œ: X=${world.coords.x}, Y=${world.coords.y}\n`;
              }
              if (world.npc_ids && world.npc_ids.length > 0) {
                villageContext += `ë“±ë¡ëœ NPC ìˆ˜: ${world.npc_ids.length}ëª…\n`;
              } else {
                villageContext += `ë“±ë¡ëœ NPC: ì—†ìŒ\n`;
              }
              villageContext += `\n`;
            }
          }
        } catch (e) {
          // ë§ˆì„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ì •ë³´ ì‚¬ìš©
          villageContext = `[íí—ˆê°€ ëœ ë§ˆì„ - ê¸°ë³¸ ì¥ì†Œ]\nëª¨ë“  ìŠ¤í† ë¦¬ëŠ” ì´ íí—ˆê°€ ëœ ë§ˆì„ì„ ì¤‘ì‹¬ìœ¼ë¡œ ì „ê°œë©ë‹ˆë‹¤.\n\n`;
        }
        
        // ì¶”ê°€ ì„¸ê³„ê´€ ì»¨í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
        let worldContext = '';
        try {
          const contextRes = await fetch(getServerUrl('/api/world/context'));
          const contextData = await contextRes.json();
          if (contextData.ok && contextData.context) {
            worldContext = contextData.context;
          }
        } catch (e) {
          // ì»¨í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ
        }
        
        // ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ìœ ì‚¬í•œ ì˜ˆì‹œ ê²€ìƒ‰ (RAG)
        let similarExamples = '';
        try {
          const promptArr = (window.wordNbUnicodeFormat || wordNbUnicodeFormat)(prompt || '');
          const promptBitMax = promptArr.length > 0 ? (window.BIT_MAX_NB || (()=>0))(promptArr) : undefined;
          const promptBitMin = promptArr.length > 0 ? (window.BIT_MIN_NB || (()=>0))(promptArr) : undefined;
          
          const similarRes = await fetch(getServerUrl('/api/training/similar'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              query: prompt,
              queryBitMax: promptBitMax,
              queryBitMin: promptBitMin,
              limit: 2  // ìƒìœ„ 2ê°œ ìœ ì‚¬ ì˜ˆì‹œ ì‚¬ìš©
            })
          });
          const similarData = await similarRes.json();
          if (similarData.ok && similarData.items && similarData.items.length > 0) {
            similarExamples = '\n[ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì°¾ì€ ìœ ì‚¬í•œ ìŠ¤í† ë¦¬ ì˜ˆì‹œ]\n';
            similarData.items.forEach((ex, idx) => {
              if (ex.input && ex.response) {
                similarExamples += `ì˜ˆì‹œ ${idx + 1}:\nì…ë ¥: ${ex.input.substring(0, 120)}${ex.input.length > 120 ? '...' : ''}\nì‘ë‹µ: ${ex.response.substring(0, 200)}${ex.response.length > 200 ? '...' : ''}\n\n`;
              }
            });
          }
        } catch (e) {
          console.error('[GPT] Similar search error:', e);
        }

        // ìµœì¢… ì»¨í…ìŠ¤íŠ¸ëŠ” íí—ˆê°€ ëœ ë§ˆì„ ì •ë³´ë¥¼ ë¨¼ì €, ê·¸ ë‹¤ìŒ ì¼ë°˜ ì„¸ê³„ê´€ ì •ë³´, ë§ˆì§€ë§‰ìœ¼ë¡œ ìœ ì‚¬ ì˜ˆì‹œ
        const fullContext = villageContext + 
          (worldContext ? `\n[ì „ì²´ ì„¸ê³„ê´€]\n${worldContext}` : '') + 
          (similarExamples ? `\n${similarExamples}` : '');

        const systemMessage = $gptUseSystemMsg.checked ? 
          'ë‹¹ì‹ ì€ íŒíƒ€ì§€ ì†Œì„¤ ì‘ê°€ì´ì ì„¸ê³„ê´€ êµ¬ì¶• ì—”ì§„ì…ë‹ˆë‹¤. ì§ˆë¬¸í•˜ê±°ë‚˜ ë˜ë¬»ì§€ ë§ê³  ì¦‰ì‹œ íŒíƒ€ì§€ ì´ì•¼ê¸°ë¥¼ ì‘ì„±í•˜ì„¸ìš”. ëª¨ë“  ìŠ¤í† ë¦¬ëŠ” "íí—ˆê°€ ëœ ë§ˆì„"ì„ ì¤‘ì‹¬ìœ¼ë¡œ ì „ê°œë©ë‹ˆë‹¤. ì‚¬ìš©ìê°€ ì œê³µí•œ í…ìŠ¤íŠ¸ì™€ íí—ˆê°€ ëœ ë§ˆì„ì˜ ì‹¤ì‹œê°„ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìƒˆë¡œìš´ ì¥ë©´, NPC, ëŒ€í™”, ì‚¬ê±´ì„ ì¦‰ì‹œ ìƒì„±í•©ë‹ˆë‹¤. ì´ì•¼ê¸°ë¥¼ ë©ˆì¶”ê±°ë‚˜ ì§ˆë¬¸í•˜ì§€ ë§ê³  ê³„ì†í•´ì„œ ìŠ¤í† ë¦¬ë¥¼ ë°œì „ì‹œí‚¤ì„¸ìš”. íí—ˆê°€ ëœ ë§ˆì„ì— ìƒˆë¡œìš´ NPCë¥¼ ì¶”ê°€í•˜ê±°ë‚˜, ë§ˆì„ì˜ ìƒí™©ì„ ë°œì „ì‹œì¼œ ì„¸ê³„ê´€ì„ í™•ì¥í•˜ì„¸ìš”. ê° ì‘ë‹µì€ ìµœì†Œ 200ì ì´ìƒì˜ ì™„ì„±ëœ ìŠ¤í† ë¦¬ì—¬ì•¼ í•©ë‹ˆë‹¤. ë°ì´í„°ë² ì´ìŠ¤ì˜ ìœ ì‚¬í•œ ì˜ˆì‹œë¥¼ ì°¸ê³ í•˜ë˜, ì™„ì „íˆ ë™ì¼í•˜ì§€ ì•Šê²Œ ì°½ì˜ì ìœ¼ë¡œ ë³€í˜•í•˜ì„¸ìš”.\n\n**ë§ˆì„ ì •ë³´ ìˆ˜ì • ë°©ë²•:**\nìŠ¤í† ë¦¬ì—ì„œ ìƒˆë¡œìš´ NPCë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ë§ˆì„ ì¢Œí‘œë¥¼ ë³€ê²½í•  ë•ŒëŠ” ì‘ë‹µ ëì— ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì§€ì‹œë¥¼ ì¶”ê°€í•˜ì„¸ìš”:\n[VILLAGE_UPDATE]{"action": "add_npc", "name": "NPCì´ë¦„", "emotion": "ê°ì •", "tone": "í†¤", "coords": {"x": ìˆ«ì, "y": ìˆ«ì}}\në˜ëŠ” ì¢Œí‘œë§Œ ë³€ê²½:\n[VILLAGE_UPDATE]{"action": "update_coords", "coords": {"x": ìˆ«ì, "y": ìˆ«ì}}\nì˜ˆì‹œ: [VILLAGE_UPDATE]{"action": "add_npc", "name": "ë¦¬ì•„", "emotion": "ê¸°ì¨", "tone": "ì¹œê·¼í•¨"}' : 
          null;

        const res = await fetch(getServerUrl('/api/gpt/chat'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt,
            systemMessage,
            context: fullContext,
            model: 'gpt-4o-mini',
            temperature: 0.7,
            maxTokens: 2000
          })
        });

        const data = await res.json();
        if (data.ok) {
          let responseText = data.response || '(ì‘ë‹µ ì—†ìŒ)';
          
          // GPT ì‘ë‹µì—ì„œ ë§ˆì„ ìˆ˜ì • ì§€ì‹œ íŒŒì‹± ë° ì‹¤í–‰
          const villageUpdateMatch = responseText.match(/\[VILLAGE_UPDATE\](.+?)(?=\[VILLAGE_UPDATE\]|$)/s);
          if (villageUpdateMatch) {
            try {
              const updateJson = JSON.parse(villageUpdateMatch[1].trim());
              await processVillageUpdate(updateJson);
              
              // ì‘ë‹µì—ì„œ ë§ˆì„ ìˆ˜ì • ì§€ì‹œ ë¶€ë¶„ ì œê±° (ì‚¬ìš©ìì—ê²ŒëŠ” ë³´ì´ì§€ ì•Šê²Œ)
              responseText = responseText.replace(/\[VILLAGE_UPDATE\].+?$/s, '').trim();
            } catch (e) {
              console.error('[Village] Update parse error:', e);
            }
          }
          
          $gptResponse.textContent = responseText;
          if (data.usage) {
            $gptUsageInfo.textContent = `í† í° ì‚¬ìš©: ${data.usage.prompt_tokens || 0} (ì…ë ¥) + ${data.usage.completion_tokens || 0} (ì¶œë ¥) = ${data.usage.total_tokens || 0} (ì´í•©)`;
          }
          
          // GPT ì‘ë‹µì˜ BIT ê°’ì„ ê³„ì‚°í•˜ì—¬ í•™ìŠµ ë°ì´í„°ë¡œ ì €ì¥ (ë§ˆì„ ìƒíƒœ ì •ë³´ í¬í•¨)
          try {
            const responseArr = (window.wordNbUnicodeFormat || wordNbUnicodeFormat)(responseText);
            if (responseArr.length > 0) {
              const responseBitMax = (window.BIT_MAX_NB || (()=>0))(responseArr);
              const responseBitMin = (window.BIT_MIN_NB || (()=>0))(responseArr);
              
              // í•™ìŠµ ë°ì´í„°ë¡œ ì €ì¥ (ë§ˆì„ ìƒíƒœ ì •ë³´ëŠ” ì„œë²„ì—ì„œ ìë™ìœ¼ë¡œ ì¶”ê°€ë¨)
              await fetch(getServerUrl('/api/training/gpt-response'), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  input: prompt,
                  response: responseText,
                  bitMax: responseBitMax,
                  bitMin: responseBitMin,
                  context: fullContext,  // ì „ì²´ ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš© (íí—ˆê°€ ëœ ë§ˆì„ ì •ë³´ í¬í•¨)
                  model: data.model || 'gpt-4o-mini'
                })
              });
            }
          } catch (e) {
            console.error('Error saving training data:', e);
          }
          
          $gptStatus.textContent = 'âœ“ ìƒì„± ì™„ë£Œ';
          $gptStatus.style.color = '#28a745';
        } else {
          $gptResponse.textContent = `ì˜¤ë¥˜: ${data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`;
          $gptStatus.textContent = 'âœ— ìƒì„± ì‹¤íŒ¨';
          $gptStatus.style.color = '#dc3545';
        }
      } catch (e) {
        $gptResponse.textContent = `ì˜¤ë¥˜: ${e.message}`;
        $gptStatus.textContent = 'âœ— ìƒì„± ì‹¤íŒ¨';
        $gptStatus.style.color = '#dc3545';
      } finally {
        $gptGenerateBtn.disabled = false;
      }
    }

    // GPT ìƒì„± ë²„íŠ¼ í´ë¦­
    $gptGenerateBtn.addEventListener('click', generateGptResponse);

    // ë¬¸ì ì…ë ¥ textareaì—ì„œ ì—”í„° í‚¤ (Shift+EnterëŠ” ì¤„ë°”ê¿ˆ, Enterë§Œ ëˆ„ë¥´ë©´ GPT ì‘ë‹µ + ìë™ ìºë¦­í„° ìƒì„±)
    $input.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        const currentText = $input.value.trim();
        if (currentText) {
          // í˜„ì¬ BIT ê°’ ê³„ì‚°
          const arr = (window.wordNbUnicodeFormat || wordNbUnicodeFormat)(currentText);
          if (arr.length > 0) {
            try {
              const bitMax = (window.BIT_MAX_NB || (()=>0))(arr);
              const bitMin = (window.BIT_MIN_NB || (()=>0))(arr);
              
              // ìë™ ìºë¦­í„° ìƒì„± ë° ì„¸ê³„ê´€ ì €ì¥ (ì‚¬ìš©ì ì •ë³´ í¬í•¨)
              $gptStatus.textContent = 'ë¶„ì„ ì¤‘...';
              $gptStatus.style.color = '#007bff';
              await processInputForWorld(currentText, bitMax, bitMin, 'user_default');
              
              // íí—ˆê°€ ëœ ë§ˆì„ ì •ë³´ë„ ìƒˆë¡œê³ ì¹¨ (ê¸°ë³¸ ì¥ì†Œì´ë¯€ë¡œ)
              // ì‹¤ì‹œê°„ ë§ˆì„ ì •ë³´ ìƒˆë¡œê³ ì¹¨ ì œê±°ë¨
              
              // GPT í”„ë¡¬í”„íŠ¸ì— ì…ë ¥ í…ìŠ¤íŠ¸ë§Œ ì„¤ì •í•˜ê³  ì‘ë‹µ ìƒì„± (íí—ˆê°€ ëœ ë§ˆì„ ì •ë³´ëŠ” ìë™ í¬í•¨)
              $gptPrompt.value = currentText;
              await generateGptResponse();
            } catch (err) {
              console.error('Error processing input:', err);
              // ì‹¤íŒ¨í•´ë„ GPT ì‘ë‹µì€ ì‹œë„
              $gptPrompt.value = currentText;
              await generateGptResponse();
            }
          } else {
            // BIT ê°’ì´ ì—†ì–´ë„ ì…ë ¥ í…ìŠ¤íŠ¸ë§Œ ì‚¬ìš©
            $gptPrompt.value = currentText;
            await generateGptResponse();
          }
        }
      }
    });

    // GPT í”„ë¡¬í”„íŠ¸ ì…ë ¥ì—ì„œ ì—”í„° í‚¤ (Shift+EnterëŠ” ì¤„ë°”ê¿ˆ, Enterë§Œ ëˆ„ë¥´ë©´ GPT ì‘ë‹µ)
    $gptPrompt.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        generateGptResponse();
      }
    });

    // GPT ì‘ë‹µ ë³µì‚¬
    $gptCopyBtn.addEventListener('click', () => {
      const text = $gptResponse.textContent;
      if (text && text !== 'ì‘ë‹µì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...' && text !== 'ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...') {
        navigator.clipboard.writeText(text).then(() => {
          $gptCopyBtn.textContent = 'ë³µì‚¬ë¨!';
          setTimeout(() => {
            $gptCopyBtn.textContent = 'ë³µì‚¬';
          }, 2000);
        }).catch(() => {
          alert('ë³µì‚¬ ì‹¤íŒ¨');
        });
      }
    });

    // GPT ì‘ë‹µ ì§€ìš°ê¸°
    $gptClearBtn.addEventListener('click', () => {
      if (confirm('ì‘ë‹µì„ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?')) {
        $gptResponse.textContent = 'ì‘ë‹µì´ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤...';
        $gptUsageInfo.textContent = '';
      }
    });

    // í˜ì´ì§€ ë¡œë“œ ì‹œ API í‚¤ ìƒíƒœ í™•ì¸
    checkApiKeyStatus();

    // íí—ˆê°€ ëœ ë§ˆì„ ì‹¤ì‹œê°„ ì •ë³´ ìƒˆë¡œê³ ì¹¨
    // ì‹¤ì‹œê°„ ë§ˆì„ ì •ë³´ ê´€ë ¨ ì½”ë“œ ì œê±°ë¨ (UIì—ì„œ í•´ë‹¹ ì„¹ì…˜ì´ ì œê±°ë˜ì–´ ë” ì´ìƒ í•„ìš”í•˜ì§€ ì•ŠìŒ)

    // export / clear
    $exportBtn.addEventListener('click', () => {
      const blob = new Blob([JSON.stringify(sessionHistory, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'bit_history.json';
      a.click();
      URL.revokeObjectURL(url);
    });

    $clearBtn.addEventListener('click', () => {
      if (!confirm('ê¸°ë¡ì„ ëª¨ë‘ ì‚­ì œí• ê¹Œìš”?')) return;
      sessionHistory.length = 0;
      renderHistoryInfo(sessionHistory);
      renderHistoryTable(sessionHistory);
      idbHistClear();
    });

    

    // ì´ˆê¸° ìƒíƒœ (ì„¸ì…˜ íˆìŠ¤í† ë¦¬ ì‚¬ìš©)
    renderHistoryInfo(sessionHistory);
    renderHistoryTable(sessionHistory);

    // ì´ˆê¸° ë Œë”
    update();

    

    // íŒŒì¼ ì—°ê²° ì—†ì´ë„ IndexedDBì—ì„œ ìë™ ë³µì›
    (async () => {
      if (sessionHistory.length > 0) return; // already loaded from file
      const all = await idbHistLoadAll();
      if (all && all.length) {
        // ensure sorted by time
        all.sort((a,b)=> a.t - b.t);
        sessionHistory.push(...all);
        renderHistoryInfo(sessionHistory);
        renderHistoryTable(sessionHistory);
      }
    })();
    
    // ===== ë§ˆì„ ì •ë³´ ìë™ ì—…ë°ì´íŠ¸ =====
    async function processVillageUpdate(updateJson) {
      const villageName = 'íí—ˆê°€ ëœ ë§ˆì„';
      try {
        if (updateJson.action === 'add_npc') {
          // NPC ìƒì„±
          const npcId = `npc_${Date.now()}_${updateJson.name || 'npc'}`;
          const createRes = await fetch(getServerUrl('/api/characters'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              npcId,
              name: updateJson.name || 'ì´ë¦„ì—†ìŒ',
              firstScene: villageName,
              emotion: updateJson.emotion || 'ì¤‘ë¦½',
              tone: updateJson.tone || 'ì°¨ë¶„í•¨',
              bitState: updateJson.bitState || { max: 0.9, min: 4.7 }
            })
          });
          
          if (createRes.ok) {
            // ë§ˆì„ì— NPC ì¶”ê°€
            await fetch(getServerUrl('/api/world'), {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                place: villageName,
                npcIds: [npcId]
              })
            });
            
            console.log('[Village] NPC ì¶”ê°€ë¨:', updateJson.name);
          }
        }
        
        if (updateJson.action === 'update_coords' && updateJson.coords) {
          // ì¢Œí‘œ ì—…ë°ì´íŠ¸
          await fetch(getServerUrl('/api/world'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              place: villageName,
              coords: updateJson.coords
            })
          });
          
          console.log('[Village] ì¢Œí‘œ ì—…ë°ì´íŠ¸:', updateJson.coords);
        }
        
        // ë§ˆì„ ì •ë³´ ìƒˆë¡œê³ ì¹¨
        // ì‹¤ì‹œê°„ ë§ˆì„ ì •ë³´ ìƒˆë¡œê³ ì¹¨ ì œê±°ë¨
      } catch (e) {
        console.error('[Village] Update error:', e);
      }
    }

    // ===== ë˜ì „ AI (ê²½ëŸ‰) =====
    let dungeonSession = [];

    async function fetchWorldContextText() {
      try {
        const res = await fetch(getServerUrl('/api/world_context'));
        const data = await res.json();
        if (data.ok && data.context) return data.context;
      } catch (e) {}
      return '';
    }

    async function fetchRecentMemory(n = 10) {
      // í˜„ì¬ ì„œë²„ì— ë©”ëª¨ë¦¬ ì¡°íšŒ APIê°€ ì—†ìœ¼ë¯€ë¡œ, ì»¨í…ìŠ¤íŠ¸ë¡œ world/context ì¤‘ì‹¬ ì‚¬ìš©
      // í•„ìš” ì‹œ ë³„ë„ API ì¶”ê°€ ê°€ëŠ¥
      return [];
    }

    function buildDungeonSystemMessage() {
      return 'ë‹¹ì‹ ì€ í•œêµ­ì–´ í…ìŠ¤íŠ¸ ê¸°ë°˜ ë˜ì „ ë§ˆìŠ¤í„°ì…ë‹ˆë‹¤. í”Œë ˆì´ì–´ì˜ ì…ë ¥ì„ ë°›ì•„ ì„œìˆ , ì„ íƒì§€, ê²°ê³¼ë¥¼ í•œêµ­ì–´ë¡œ ê°„ê²°í•˜ê³  ëª°ì…ê° ìˆê²Œ ì§„í–‰í•˜ì„¸ìš”. ë¶ˆí•„ìš”í•œ ì§ˆë¬¸ì„ ìµœì†Œí™”í•˜ê³ , ì¥ë©´Â·í–‰ë™Â·ê²°ê³¼Â·í›„ì† ì„ íƒì§€ë¥¼ 2~4ê°œ ì œì‹œí•˜ì„¸ìš”. ê¸ˆì§€: í”Œë ˆì´ì–´ì˜ ì„ íƒì„ ëŒ€ì‹  ê²°ì •í•˜ì§€ ë§ˆì„¸ìš”.\n\n**ë§ˆì„ ì •ë³´ ìˆ˜ì • ë°©ë²•:**\nìƒˆë¡œìš´ NPCë¥¼ ì¶”ê°€í•˜ê±°ë‚˜ ë§ˆì„ ì¢Œí‘œë¥¼ ë³€ê²½í•  ë•ŒëŠ” ì‘ë‹µ ëì— ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ì§€ì‹œë¥¼ ì¶”ê°€í•˜ì„¸ìš”:\n[VILLAGE_UPDATE]{"action": "add_npc", "name": "NPCì´ë¦„", "emotion": "ê°ì •", "tone": "í†¤"}\në˜ëŠ” ì¢Œí‘œë§Œ ë³€ê²½:\n[VILLAGE_UPDATE]{"action": "update_coords", "coords": {"x": ìˆ«ì, "y": ìˆ«ì}}';
    }

    async function dungeonTurn(inputText) {
      const $status = document.getElementById('dungeonStatus');
      try {
        $status.textContent = 'ì§„í–‰ ì¤‘...';
        
        // 1. ì…ë ¥ í…ìŠ¤íŠ¸ì˜ BIT ê°’ ê³„ì‚°
        const queryArr = (window.wordNbUnicodeFormat || wordNbUnicodeFormat)(inputText || '');
        const queryBitMax = queryArr.length > 0 ? (window.BIT_MAX_NB || (()=>0))(queryArr) : undefined;
        const queryBitMin = queryArr.length > 0 ? (window.BIT_MIN_NB || (()=>0))(queryArr) : undefined;
        
        // 2. ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ìœ ì‚¬í•œ ì˜ˆì‹œ ê²€ìƒ‰ (RAG)
        let similarExamples = '';
        try {
          const similarRes = await fetch(getServerUrl('/api/training/similar'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              query: inputText,
              queryBitMax,
              queryBitMin,
              limit: 3  // ìƒìœ„ 3ê°œ ìœ ì‚¬ ì˜ˆì‹œ ì‚¬ìš©
            })
          });
          const similarData = await similarRes.json();
          if (similarData.ok && similarData.items && similarData.items.length > 0) {
            similarExamples = '\n[ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì°¾ì€ ìœ ì‚¬í•œ ì˜ˆì‹œ]\n';
            similarData.items.forEach((ex, idx) => {
              if (ex.input && ex.response) {
                similarExamples += `ì˜ˆì‹œ ${idx + 1}:\nì…ë ¥: ${ex.input.substring(0, 100)}${ex.input.length > 100 ? '...' : ''}\nì‘ë‹µ: ${ex.response.substring(0, 150)}${ex.response.length > 150 ? '...' : ''}\n\n`;
              }
            });
          }
        } catch (e) {
          console.error('[Dungeon] Similar search error:', e);
        }
        
        // 3. ì„¸ê³„ê´€ ì»¨í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
        const worldCtx = await fetchWorldContextText();
        
        // 4. ì „ì²´ ì»¨í…ìŠ¤íŠ¸ êµ¬ì„±
        const context = [
          '[ë°°ê²½: íí—ˆê°€ ëœ ë§ˆì„ì„ ì¤‘ì‹¬ìœ¼ë¡œ ì§„í–‰]',
          worldCtx || '',
          similarExamples
        ].filter(Boolean).join('\n\n');

        const systemMessage = buildDungeonSystemMessage();
        const prompt = inputText && inputText.trim() ? inputText.trim() : 'ë˜ì „ì„ ì‹œì‘í•œë‹¤. ê°„ë‹¨í•œ ì˜¤í”„ë‹ ì¥ë©´ê³¼ 2~4ê°œì˜ ì„ íƒì§€ë¥¼ ì œì‹œí•´ë¼.';

        const res = await fetch(getServerUrl('/api/gpt/chat'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            prompt,
            systemMessage,
            context,
            model: 'gpt-4o-mini',
            temperature: 0.9,
            maxTokens: 1200
          })
        });
        const data = await res.json();
        if (!data.ok) throw new Error(data.error || 'ìƒì„± ì‹¤íŒ¨');

        let responseText = data.response || '';
        
        // GPT ì‘ë‹µì—ì„œ ë§ˆì„ ìˆ˜ì • ì§€ì‹œ íŒŒì‹± ë° ì‹¤í–‰
        const villageUpdateMatch = responseText.match(/\[VILLAGE_UPDATE\](.+?)(?=\[VILLAGE_UPDATE\]|$)/s);
        if (villageUpdateMatch) {
          try {
            const updateJson = JSON.parse(villageUpdateMatch[1].trim());
            await processVillageUpdate(updateJson);
            
            // ì‘ë‹µì—ì„œ ë§ˆì„ ìˆ˜ì • ì§€ì‹œ ë¶€ë¶„ ì œê±° (ì‚¬ìš©ìì—ê²ŒëŠ” ë³´ì´ì§€ ì•Šê²Œ)
            responseText = responseText.replace(/\[VILLAGE_UPDATE\].+?$/s, '').trim();
          } catch (e) {
            console.error('[Dungeon] Village update parse error:', e);
          }
        }
        
        $gptResponse.textContent = responseText;
        if (data.usage) {
          $gptUsageInfo.textContent = `í† í° ì‚¬ìš©: ${data.usage.total_tokens || 0}`;
        }

        // ì„¸ì…˜ ê¸°ë¡
        dungeonSession.push({ input: prompt, response: responseText, t: Date.now() });

        // ë©”ëª¨ë¦¬/í•™ìŠµ ì €ì¥ (ë°ì´í„°ë² ì´ìŠ¤ì— ê¸°ë¡)
        try {
          await fetch(getServerUrl('/api/memory'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              input: prompt + '\n\n' + responseText,
              npcSpeaker: null,
              place: 'íí—ˆê°€ ëœ ë§ˆì„',
              bit: { max: queryBitMax, min: queryBitMin }
            })
          });
        } catch (e) {}

        try {
          const responseArr = (window.wordNbUnicodeFormat || wordNbUnicodeFormat)(responseText);
          const responseBitMax = responseArr.length > 0 ? (window.BIT_MAX_NB || (()=>0))(responseArr) : 0;
          const responseBitMin = responseArr.length > 0 ? (window.BIT_MIN_NB || (()=>0))(responseArr) : 0;
          await fetch(getServerUrl('/api/training/gpt-response'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              input: prompt,
              response: responseText,
              bitMax: responseBitMax,
              bitMin: responseBitMin,
              context,
              model: data.model || 'gpt-4o-mini'
            })
          });
        } catch (e) {}

        $status.textContent = 'ì™„ë£Œ';
      } catch (e) {
        $status.textContent = 'ì‹¤íŒ¨';
        $gptResponse.textContent = `ì˜¤ë¥˜: ${e.message}`;
      }
    }

    document.getElementById('dungeonStartBtn').addEventListener('click', async () => {
      dungeonSession = [];
      await dungeonTurn(document.getElementById('gptPrompt').value);
    });
    document.getElementById('dungeonNextBtn').addEventListener('click', async () => {
      await dungeonTurn(document.getElementById('gptPrompt').value);
    });

    // ===== ì†Œì„¤ ì™„ì„± í”Œë¡œìš° =====
    let novelAbort = false;
    let isGenerating = false; // ì¤‘ë³µ ìƒì„± ë°©ì§€
    let novelChapters = {}; // {1: "ë‚´ìš©", 2: "ë‚´ìš©", ...}
    let savedChapters = new Set(); // ì„œë²„ì— ì €ì¥ëœ ì¥ ë²ˆí˜¸/ê°œìš” ì¶”ì  ('0'ì€ ê°œìš”)
    let autosaveTimer = null;
    let localSaveTimer = null;
    let currentNovelId = null;
    const $novelTitle = document.getElementById('novelTitle');
    const $novelGenre = document.getElementById('novelGenre');
    const $novelChapters = document.getElementById('novelChapters');
    const $novelContent = document.getElementById('novelContent');
    const $novelStatus = document.getElementById('novelStatus');
    const $novelProgress = document.getElementById('novelProgress');
    const $characterCards = document.getElementById('characterCards');
    const $chapterList = document.getElementById('chapterList');
    // ì§€ì—° í‰ê°€ë¡œ ë³€ê²½ (DOM ì¤€ë¹„ í›„ ì¡°íšŒ)
    const $novelSelect = () => document.getElementById('novelSelect');
    const $newNovelBtn = () => document.getElementById('newNovelBtn');
    // ì¢Œì¸¡ í¸ì§‘ ê°€ëŠ¥í•œ ì»¨í…ìŠ¤íŠ¸ ìš”ì†Œ
    const $currentChapter = document.getElementById('currentChapter');
    const $characterLocations = document.getElementById('characterLocations');
    const $currentPlace = document.getElementById('currentPlace');
    const $recentEvents = document.getElementById('recentEvents');
    const $nextDirection = document.getElementById('nextDirection');

    // ì±•í„° ëª©ë¡ ì—…ë°ì´íŠ¸
    function extractChapterTitle(text) {
      if (!text) return '';
      const firstLine = String(text).split(/\r?\n/)[0].trim();
      return firstLine.length > 0 ? firstLine : '';
    }

    function extractChapterSummary(text, maxLen = 140) {
      if (!text) return '';
      const clean = String(text).replace(/\s+/g, ' ').trim();
      return clean.length > maxLen ? clean.slice(0, maxLen) + 'â€¦' : clean;
    }

    let currentChapterNum = null;

    function getSortedChapters() {
      return Object.keys(novelChapters).map(Number).sort((a,b)=>a-b);
    }

    function showChapter(num) {
      if (novelChapters[num] === undefined) return;
      currentChapterNum = num;
      const text = novelChapters[num];
      $novelContent.textContent = text;
      if ($currentChapter) $currentChapter.value = num === 0 ? 'ê°œìš”' : (extractChapterTitle(text) || `ì œ${num}ì¥`);
      if ($recentEvents) $recentEvents.value = extractChapterSummary(text, 200);
      if ($chapterList) {
        $chapterList.querySelectorAll('button').forEach(b => {
          b.classList.remove('btn-primary', 'btn-outline-primary');
          b.classList.add('btn-outline-primary');
        });
        const btns = Array.from($chapterList.querySelectorAll('button'));
        const idx = getSortedChapters().indexOf(num);
        if (idx >= 0 && btns[idx]) {
          btns[idx].classList.remove('btn-outline-primary');
          btns[idx].classList.add('btn-primary');
        }
      }
      // ë§ˆì§€ë§‰ ë³¸ ì±•í„° ì €ì¥ (ì†Œì„¤ë³„)
      try {
        if (currentNovelId) localStorage.setItem(`novel:${currentNovelId}:lastChapter`, String(num));
      } catch {}
    }

    function updateChapterList() {
      $chapterList.innerHTML = '';
      const chapters = Object.keys(novelChapters).map(Number).sort((a, b) => a - b);
      if (chapters.length === 0) {
        $chapterList.innerHTML = '<span class="text-muted small">ìƒì„±ëœ ì±•í„°ê°€ ì—†ìŠµë‹ˆë‹¤...</span>';
        return;
      }
      chapters.forEach(num => {
        const btn = document.createElement('button');
        btn.className = 'btn btn-sm btn-outline-primary';
        btn.textContent = num === 0 ? 'ê°œìš”' : `ì œ${num}ì¥`;
        btn.onclick = () => {
          showChapter(num);
        };
        $chapterList.appendChild(btn);
      });
      if (currentChapterNum === null && chapters.length > 0) {
        showChapter(chapters.find(n=>n>0) ?? chapters[0]);
      } else if (currentChapterNum !== null && novelChapters[currentChapterNum] !== undefined) {
        showChapter(currentChapterNum);
      }

      // ëª©ë¡ ê°±ì‹  í›„ ìë™ ì €ì¥ í˜¸ì¶œ (ë””ë°”ìš´ìŠ¤)
      queueAutosaveAllChapters();
      // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ë°±ì—… ì €ì¥ (ë””ë°”ìš´ìŠ¤)
      queueLocalBackupSave();
    }

    function queueAutosaveAllChapters() {
      if (autosaveTimer) clearTimeout(autosaveTimer);
      autosaveTimer = setTimeout(autosaveAllChapters, 400);
    }

    async function autosaveAllChapters() {
      try {
        if (!currentNovelId) return;
        const keys = Object.keys(novelChapters).map(n => Number(n)).sort((a,b)=>a-b);
        for (const num of keys) {
          const key = String(num);
          if (savedChapters.has(key)) continue;
          const text = novelChapters[num];
          if (!text || text.trim().length === 0) continue;
          if (num === 0) {
            // ê°œìš” ì €ì¥
            await fetch(getServerUrl(`/api/novels/${encodeURIComponent(currentNovelId)}/chapters`), {
              method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ isOutline: true, text })
            });
          } else {
            await fetch(getServerUrl(`/api/novels/${encodeURIComponent(currentNovelId)}/chapters`), {
              method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ num, text })
            });
          }
          savedChapters.add(key);
        }
      } catch (e) {
        console.warn('[Novel] Autosave failed:', e);
      }
    }

    function queueLocalBackupSave() {
      if (!currentNovelId) return;
      if (localSaveTimer) clearTimeout(localSaveTimer);
      localSaveTimer = setTimeout(saveLocalBackup, 300);
    }

    function saveLocalBackup() {
      try {
        if (!currentNovelId) return;
        const data = { chapters: novelChapters, t: Date.now() };
        localStorage.setItem(`novel:${currentNovelId}:chapters`, JSON.stringify(data));
      } catch {}
    }

    function loadLocalBackup(novelId) {
      try {
        const raw = localStorage.getItem(`novel:${novelId}:chapters`);
        if (!raw) return null;
        const data = JSON.parse(raw);
        if (data && data.chapters && typeof data.chapters === 'object') return data.chapters;
      } catch {}
      return null;
    }

    // ===== ì†Œì„¤ ì„ íƒ/ë¡œë“œ =====
    async function fetchNovels() {
      try {
        const res = await fetch(getServerUrl('/api/novels'));
        const data = await res.json();
        return data.ok ? (data.items || []) : [];
      } catch { return []; }
    }

    async function populateNovelSelect() {
      const $select = $novelSelect();
      if (!$select) {
        console.warn('[Novel] novelSelect element not found');
        return;
      }
      const items = await fetchNovels();
      $select.innerHTML = '';
      if (items.length === 0) {
        const opt = document.createElement('option');
        opt.value = '';
        opt.textContent = 'ì†Œì„¤ ì—†ìŒ - ìƒˆ ì†Œì„¤ì„ ìƒì„±í•˜ì„¸ìš”';
        $select.appendChild(opt);
        return;
      }
      items.forEach(n => {
        const opt = document.createElement('option');
        opt.value = n.id;
        opt.textContent = `${n.title} (${n.chapters}ì¥)`;
        $select.appendChild(opt);
      });
      // ì €ì¥ëœ ì†Œì„¤ì´ ìˆìœ¼ë©´ ì„ íƒ, ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ì†Œì„¤ ìë™ ì„ íƒ
      const saved = localStorage.getItem('currentNovelId');
      let selectedId = null;
      if (saved && items.some(i=>i.id===saved)) {
        selectedId = saved;
      } else if (items.length > 0) {
        selectedId = items[0].id;
        localStorage.setItem('currentNovelId', selectedId);
      }
      if (selectedId) {
        $select.value = selectedId;
        currentNovelId = selectedId;
        await loadNovelChapters(selectedId);
      }
    }

    async function createNewNovel() {
      const title = prompt('ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”', $novelTitle ? $novelTitle.value || 'ì œëª© ë¯¸ì •' : 'ì œëª© ë¯¸ì •');
      if (!title) return;
      const genre = prompt('ì¥ë¥´ë¥¼ ì…ë ¥í•˜ì„¸ìš”', $novelGenre ? $novelGenre.value || '' : '');
      try {
        const res = await fetch(getServerUrl('/api/novels'), { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ title, genre }) });
        const data = await res.json();
        if (data.ok && data.novel) {
          currentNovelId = data.novel.id;
          localStorage.setItem('currentNovelId', currentNovelId);
          await populateNovelSelect();
          if ($novelSelect) $novelSelect.value = currentNovelId;
          novelChapters = {};
          updateChapterList();
        }
      } catch {}
    }

    async function loadNovelChapters(novelId) {
      try {
        // ì „ì²´ í…ìŠ¤íŠ¸ë¡œ ë¡œë“œ
        const metaRes = await fetch(getServerUrl(`/api/novels/${encodeURIComponent(novelId)}/chapters?full=true`));
        const meta = await metaRes.json();
        novelChapters = {};
        savedChapters = new Set();
        if (meta.ok) {
          if (meta.outline) novelChapters[0] = meta.outline;
          (meta.chapters || []).forEach(ch => {
            novelChapters[ch.num] = ch.text; // ì „ì²´ í…ìŠ¤íŠ¸ ì‚¬ìš©
            savedChapters.add(String(ch.num));
          });
          if (meta.outline) savedChapters.add('0');
        }
        // ì„œë²„ì— ì•„ë¬´ ê²ƒë„ ì—†ìœ¼ë©´ ë¡œì»¬ ë°±ì—… ë³µì› ì‹œë„
        if ((!meta.ok) || ((meta.chapters || []).length === 0 && !meta.outline)) {
          const local = loadLocalBackup(novelId);
          if (local) {
            novelChapters = local;
          }
        }
        updateChapterList();
        // ë§ˆì§€ë§‰ ë³¸ ì±•í„°ë¡œ ìë™ ì´ë™
        try {
          const last = localStorage.getItem(`novel:${novelId}:lastChapter`);
          const lastNum = last != null ? Number(last) : null;
          if (lastNum != null && !Number.isNaN(lastNum) && novelChapters[lastNum] !== undefined) {
            showChapter(lastNum);
          }
        } catch {}
        // ì†Œì„¤ ì •ë³´ë„ ì—…ë°ì´íŠ¸
        if (meta.ok && meta.outline) {
          const titleMatch = meta.outline.match(/ì œëª©:\s*(.+)/);
          const genreMatch = meta.outline.match(/ì¥ë¥´:\s*(.+)/);
          if (titleMatch && $novelTitle) $novelTitle.value = titleMatch[1].trim();
          if (genreMatch && $novelGenre) $novelGenre.value = genreMatch[1].trim();
        }
        // ë…¸íŠ¸ ë¡œë“œ
        try {
          const notesRes = await fetch(getServerUrl(`/api/novels/${encodeURIComponent(novelId)}/notes`));
          const notesData = await notesRes.json();
          const $notes = document.getElementById('novelIdeaInput');
          if (notesData.ok && $notes) $notes.value = notesData.text || '';
        } catch {}
        // ë³µì›í•œ ë¡œì»¬ ë°ì´í„°ê°€ ìˆê³  ì„œë²„ì— ì—†ì—ˆë‹¤ë©´ ì„œë²„ë¡œ ë™ê¸°í™”
        queueAutosaveAllChapters();
      } catch (e) {
        console.error('[Novel] Load error:', e);
      }
    }

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ (DOM ì¤€ë¹„ í›„)
    (function setupNovelSelectListeners() {
      const setup = () => {
        const $select = $novelSelect();
        if ($select && !$select.dataset.listenerAttached) {
          $select.dataset.listenerAttached = 'true';
          $select.addEventListener('change', async () => {
            currentNovelId = $select.value || null;
            if (currentNovelId) localStorage.setItem('currentNovelId', currentNovelId);
            await loadNovelChapters(currentNovelId);
          });
        }
        const $btn = $newNovelBtn();
        if ($btn && !$btn.dataset.listenerAttached) {
          $btn.dataset.listenerAttached = 'true';
          $btn.addEventListener('click', createNewNovel);
        }
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setup);
      } else {
        setup();
      }
    })();
    
    // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ í˜¸ì¶œ (DOM ì¤€ë¹„ í›„)
    (function initNovelSelect() {
      let retries = 0;
      const maxRetries = 10;
      const tryInit = async () => {
        const $select = $novelSelect();
        if ($select) {
          console.log('[Novel] Initializing novel selector...');
          await populateNovelSelect();
          console.log('[Novel] Novel selector initialized');
        } else if (retries < maxRetries) {
          retries++;
          setTimeout(tryInit, 200);
        } else {
          console.error('[Novel] Failed to find novelSelect element after retries');
        }
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          setTimeout(tryInit, 100);
        });
      } else {
        setTimeout(tryInit, 100);
      }
    })();

    async function loadCharactersList() {
      try {
        const res = await fetch(getServerUrl('/api/characters'));
        const data = await res.json();
        if ($characterCards) $characterCards.innerHTML = '';
        if (data.ok && Array.isArray(data.characters) && $characterCards) {
          data.characters.slice(0, 30).forEach(c => {
            const col = document.createElement('div');
            col.className = 'col-12 col-sm-6 col-md-4 col-lg-3';
            col.innerHTML = `
              <div class="card h-100 shadow-sm">
                <div class="card-body p-2">
                  <div class="fw-bold">${c.name || 'ì´ë¦„ì—†ìŒ'}</div>
                  <div class="text-muted small">${c.first_scene || 'ì¥ì†Œ ë¯¸ìƒ'}</div>
                  ${c.emotion ? `<span class="badge bg-light text-dark mt-1">${c.emotion}</span>` : ''}
                </div>
              </div>`;
            $characterCards.appendChild(col);
          });
        }
      } catch (e) {}
    }
    loadCharactersList();

    function buildNovelSystem() {
      return 'ë„ˆëŠ” í•œêµ­ì–´ ì¥í¸ ì†Œì„¤ ì‘ê°€ì´ì ì‹œë„¤ë§ˆí‹± ì—°ì¶œê°€ë‹¤. ê° ì¥ì€ ì˜í™”ì²˜ëŸ¼ ì¥ë©´ ë¬˜ì‚¬(ê³µê°„/ì¡°ëª…/ì‚¬ìš´ë“œ/ì¹´ë©”ë¼ ë¬´ë¹™ ëŠë‚Œ)ì™€ ë“±ì¥ì¸ë¬¼ì˜ ìƒìƒí•œ ëŒ€ì‚¬ë¥¼ ë°˜ë“œì‹œ í¬í•¨í•˜ë¼. ì „ê°œê°€ ëŠê¸°ì§€ ì•Šë„ë¡ ì„œì‚¬/ëŒ€ì‚¬/ë¬˜ì‚¬ë¥¼ ê· í˜• ìˆê²Œ êµ¬ì„±í•˜ë˜, ë¶ˆí•„ìš”í•œ ì„¤ëª…ì€ ì¤„ì´ê³  í˜„ì¥ê°ì„ ë†’ì—¬ë¼. ê° ì¥ì€ 400~800ì ë‚´ì™¸. ë©”íƒ€ ë°œì–¸, í”„ë¡¬í”„íŠ¸ ì–¸ê¸‰ ê¸ˆì§€.';
    }

    async function gptCall(prompt, context, temperature = 0.8, maxTokens = 1400) {
      const res = await fetch(getServerUrl('/api/gpt/chat'), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt, systemMessage: buildNovelSystem(), context, model: 'gpt-4o-mini', temperature, maxTokens })
      });
      const data = await res.json();
      if (!data.ok) throw new Error(data.error || 'GPT ìƒì„± ì‹¤íŒ¨');
      return data.response || '';
    }

    // ì¢Œì¸¡ ì»¨í…ìŠ¤íŠ¸ë¥¼ í”„ë¡¬í”„íŠ¸ë¡œ ë³€í™˜
    function buildContextPrompt() {
      const parts = [];
      // ì‚¬ìš©ì ì…ë ¥ í…ìŠ¤íŠ¸ë¥¼ ì»¨í…ìŠ¤íŠ¸ì— í¬í•¨
      const $textInput = document.getElementById('textInput');
      const $novelIdeaInput = document.getElementById('novelIdeaInput');
      if ($textInput && $textInput.value && $textInput.value.trim().length > 0) {
        parts.push(`[ì‚¬ìš©ì ì…ë ¥]\n${$textInput.value.trim()}`);
      }
      if ($novelIdeaInput && $novelIdeaInput.value && $novelIdeaInput.value.trim().length > 0) {
        parts.push(`[ì¶”ê°€ ì•„ì´ë””ì–´]\n${$novelIdeaInput.value.trim()}`);
      }
      if ($currentChapter && $currentChapter.value) {
        parts.push(`[í˜„ì¬ ì±•í„°]\n${$currentChapter.value}`);
      }
      if ($characterLocations && $characterLocations.value) {
        parts.push(`[ì£¼ìš” ìºë¦­í„° ë° ìœ„ì¹˜]\n${$characterLocations.value}`);
      }
      if ($currentPlace && $currentPlace.value) {
        parts.push(`[í˜„ì¬ ì¥ì†Œ/ë°°ê²½]\n${$currentPlace.value}`);
      }
      if ($recentEvents && $recentEvents.value) {
        parts.push(`[ìµœê·¼ ì‚¬ê±´/ìƒí™©]\n${$recentEvents.value}`);
      }
      if ($nextDirection && $nextDirection.value) {
        parts.push(`[ë‹¤ìŒ ì „ê°œ ë°©í–¥]\n${$nextDirection.value}`);
      }
      return parts.join('\n\n');
    }

    async function generateFullNovel() {
      if (isGenerating) return; // ì´ë¯¸ ìƒì„± ì¤‘ì´ë©´ ë¬´ì‹œ
      isGenerating = true;
      novelAbort = false;
      const $statusWrap = document.getElementById('novelStatus');
      const $statusText = document.getElementById('novelStatusText');
      const $loading = document.getElementById('novelLoading');
      if ($statusText) $statusText.textContent = '';
      if ($loading) $loading.classList.remove('d-none');
      // ì´ˆê¸° ìƒíƒœì—ì„œë§Œ ê°œìš”/ì±•í„° ì´ˆê¸°í™”
      const hasAnyChapter = Object.keys(novelChapters).map(Number).some(n => n > 0);
      const hasOutline = novelChapters[0] !== undefined;
      try {

      const title = ($novelTitle.value || 'ì œëª© ë¯¸ì •').trim();
      const genre = ($novelGenre.value || 'íŒíƒ€ì§€').trim();
      const chapters = Math.max(3, Math.min(20, parseInt($novelChapters.value || '6', 10)));

      // ì¢Œì¸¡ ì»¨í…ìŠ¤íŠ¸ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
      const contextInfo = buildContextPrompt();
      const worldCtx = await fetchWorldContextText();
      
      // ì „ì²´ ì»¨í…ìŠ¤íŠ¸ ì¡°í•©
      const fullContext = [
        worldCtx ? `[ì „ì²´ ì„¸ê³„ê´€]\n${worldCtx}` : '',
        contextInfo ? `[í˜„ì¬ ì†Œì„¤ ìƒíƒœ]\n${contextInfo}` : ''
      ].filter(Boolean).join('\n\n');

      // 1) ê°œìš”ê°€ ì—†ìœ¼ë©´ ê°œìš”ë§Œ 1íšŒ ìƒì„±
      if (!hasOutline) {
        if ($statusText) $statusText.textContent = 'ê°œìš” ìƒì„± ì¤‘...';
        const outlinePrompt = `ì œëª©: ${title}\nì¥ë¥´: ${genre}${contextInfo ? '\n\n' + contextInfo : ''}\nìš”ì²­: ìœ„ ì„¤ì •ê³¼ í˜„ì¬ ìƒíƒœë¥¼ ì°¸ê³ í•˜ì—¬ ${chapters}ì¥ êµ¬ì„±ì˜ ì†Œì„¤ ê°œìš”(ì¥ ì œëª©+í•œ ì¤„ ìš”ì•½)ë¥¼ ë§Œë“¤ì–´ë¼.`;
        const outline = await gptCall(outlinePrompt, fullContext, 0.6, 800);
        if (novelAbort) return;
        novelChapters[0] = `ì œëª©: ${title}\nì¥ë¥´: ${genre}\n\n[ê°œìš”]\n${outline}`;
        updateChapterList();
        // save outline to DB if novel selected
      // ì†Œì„¤ì´ ì„ íƒë˜ì–´ ìˆìœ¼ë©´ ìë™ ì €ì¥ (ì—†ìœ¼ë©´ ì œëª©/ì¥ë¥´ë¡œ ìƒˆ ì†Œì„¤ ìƒì„±)
      if (!currentNovelId && title && genre) {
        try {
          const createRes = await fetch(getServerUrl('/api/novels'), {
            method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ title, genre })
          });
          const createData = await createRes.json();
          if (createData.ok && createData.novel) {
            currentNovelId = createData.novel.id;
            localStorage.setItem('currentNovelId', currentNovelId);
            const $select = $novelSelect();
            if ($select) {
              await populateNovelSelect();
              $select.value = currentNovelId;
            }
          }
        } catch {}
      }
      if (currentNovelId) {
        try {
          await fetch(getServerUrl(`/api/novels/${encodeURIComponent(currentNovelId)}/chapters`), {
            method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ isOutline: true, text: novelChapters[0] })
          });
        } catch {}
      }
      }

      // 2) ì´ë²ˆ í˜¸ì¶œì—ì„œëŠ” "ë‹¤ìŒ í•œ ì¥"ë§Œ ìƒì„±
      // ë‹¤ìŒ ì¥ ë²ˆí˜¸ ê³„ì‚°
      const existingNums = Object.keys(novelChapters).map(Number).filter(n => n > 0).sort((a,b)=>a-b);
      const nextNum = existingNums.length ? Math.max(...existingNums) + 1 : 1;
      if (nextNum > chapters) {
        if ($statusText) $statusText.textContent = 'ëª¨ë“  ì¥ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.';
        return;
      }

      if ($statusText) $statusText.textContent = `${nextNum}ì¥ ì‘ì„± ì¤‘...`;
      $novelProgress.textContent = `${Math.min(nextNum, chapters)}/${chapters}`;

      // ìµœì‹  ì¢Œì¸¡ ì»¨í…ìŠ¤íŠ¸ ë°˜ì˜
      const latestContext = buildContextPrompt();
      const latestFullContext = [
        worldCtx ? `[ì „ì²´ ì„¸ê³„ê´€]\n${worldCtx}` : '',
        latestContext ? `[í˜„ì¬ ì†Œì„¤ ìƒíƒœ]\n${latestContext}` : ''
      ].filter(Boolean).join('\n\n');
      const outlineText = novelChapters[0] || '';
      const chapterPrompt = `ì œëª©: ${title}\nì¥ë¥´: ${genre}\nê°œìš”:\n${outlineText}${latestContext ? '\n\n' + latestContext : ''}\nìš”ì²­: ìœ„ ê°œìš”ì™€ í˜„ì¬ ìƒíƒœë¥¼ ê¸°ì¤€ìœ¼ë¡œ ${nextNum}ì¥ì„ ì™„ì„±í•˜ë¼. ì¥ ì œëª©ì„ í¬í•¨í•˜ê³ , 400~800ì ë‚´ë¡œ ì„œì‚¬/ëŒ€ì‚¬/ë¬˜ì‚¬ë¥¼ ê· í˜•ìˆê²Œ.`;
      const chapter = await gptCall(chapterPrompt, latestFullContext, 0.85, 1500);
      if (novelAbort) return;
      novelChapters[nextNum] = chapter;
      updateChapterList();
      $novelContent.textContent = chapter;
      try {
        const arr = (window.wordNbUnicodeFormat || wordNbUnicodeFormat)(chapter);
        const responseBitMax = (window.BIT_MAX_NB || (()=>0))(arr);
        const responseBitMin = (window.BIT_MIN_NB || (()=>0))(arr);
        await fetch(getServerUrl('/api/training/gpt-response'), {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ input: chapterPrompt, response: chapter, bitMax: responseBitMax, bitMin: responseBitMin, context: latestFullContext, model: 'gpt-4o-mini' })
        });
        if (currentNovelId) {
          try {
            await fetch(getServerUrl(`/api/novels/${encodeURIComponent(currentNovelId)}/chapters`), {
              method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ num: nextNum, text: chapter })
            });
          } catch {}
        }
      } catch (e) {}

      if ($statusText) $statusText.textContent = novelAbort ? 'ì¤‘ì§€ë¨' : 'ì™„ë£Œ';
      // ì™„ë£Œ ì‹œ ì²« ë²ˆì§¸ ì±•í„° í‘œì‹œ
      if (!novelAbort && Object.keys(novelChapters).length > 0) {
        const chapters = getSortedChapters();
        const firstChapter = chapters.find(n=>n>0) ?? chapters[0];
        if (firstChapter !== undefined) showChapter(firstChapter);
      }
    } catch (e) {
      const $statusText = document.getElementById('novelStatusText');
      if ($statusText) $statusText.textContent = `ì˜¤ë¥˜: ${e.message || e}`;
    }
    isGenerating = false;
    var _l = document.getElementById('novelLoading');
    if (_l) _l.classList.add('d-none');
    }

    // ì‹œì‘ ë²„íŠ¼ ì œê±°ë¨
    document.getElementById('stopNovelBtn').addEventListener('click', () => { novelAbort = true; });
    const $useNovelFlowBtn = document.getElementById('useNovelFlowBtn');
    if ($useNovelFlowBtn) $useNovelFlowBtn.addEventListener('click', generateFullNovel);

    // ë¬¸ì ì…ë ¥ ìë™ í˜¸ì¶œ (ë””ë°”ìš´ìŠ¤)
    (function setupAutoCall(){
      const $textInput = document.getElementById('textInput');
      const $autoToggle = document.getElementById('autoNovelToggle');
      if (!$textInput) return;
      let timer = null;
      const debounceMs = 1000;
      function queue() {
        if (!$autoToggle || !$autoToggle.checked) return;
        if (isGenerating) return;
        // ì´ë¯¸ í•œ ì¥ ì´ìƒ ìƒì„±ëœ ê²½ìš° ìë™ í˜¸ì¶œ ì œí•œ
        const hasAnyChapter = Object.keys(novelChapters).map(Number).some(n => n > 0);
        if (hasAnyChapter) return;
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => {
          if ($textInput.value && $textInput.value.trim().length > 0 && !isGenerating) {
            generateFullNovel();
          }
        }, debounceMs);
      }
      $textInput.addEventListener('input', queue);
      $textInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && ($autoToggle && $autoToggle.checked)) {
          e.preventDefault();
          if (timer) clearTimeout(timer);
          const hasAnyChapter = Object.keys(novelChapters).map(Number).some(n => n > 0);
          if (!isGenerating && !hasAnyChapter) generateFullNovel();
        }
      });
    })();

    // ì´ì „/ë‹¤ìŒ ë„¤ë¹„ê²Œì´ì…˜
    (function setupPrevNext(){
      const prevBtn = document.getElementById('prevChapterBtn');
      const nextBtn = document.getElementById('nextChapterBtn');
      if (!prevBtn || !nextBtn) return;
      prevBtn.addEventListener('click', () => {
        const chapters = getSortedChapters();
        if (!chapters.length) return;
        if (currentChapterNum === null) { showChapter(chapters[0]); return; }
        const idx = chapters.indexOf(currentChapterNum);
        const prevIdx = Math.max(0, idx - 1);
        showChapter(chapters[prevIdx]);
      });
      nextBtn.addEventListener('click', () => {
        const chapters = getSortedChapters();
        if (!chapters.length) { generateFullNovel(); return; }
        if (currentChapterNum === null) { showChapter(chapters[0]); return; }
        const idx = chapters.indexOf(currentChapterNum);
        const nextIdx = Math.min(chapters.length - 1, idx + 1);
        if (nextIdx === idx) {
          // ëì´ë©´ ìƒˆë¡œ ìƒì„± ìœ ë„
          if (!isGenerating && confirm('ë‹¤ìŒ ì¥ì´ ì—†ìŠµë‹ˆë‹¤. ìƒˆë¡œ ìƒì„±í• ê¹Œìš”?')) generateFullNovel();
        } else {
          showChapter(chapters[nextIdx]);
        }
      });
    })();

    // ===== ë ˆì´ì•„ì›ƒ ì¬ë°°ì¹˜: ì…ë ¥/ GPT íŒ¨ë„ì„ ì†Œì„¤ ì‹¤í–‰ ì¹´ë“œë¡œ ì´ë™ =====
    (function relocatePanels(){
      try {
        const execBody = document.getElementById('novelExecBody');
        if (!execBody) return;
        // ë¬¸ì ì…ë ¥ ë¸”ë¡ ì´ë™ ë¡œì§ ì œê±°ë¨ (í•˜ë‹¨ ê³ ì •)
        // 2) GPT íŒ¨ë„ ì´ë™ (ë‚´ìš©ë§Œ ì´ë™)
        const gptPanel = document.getElementById('gptPanel');
        if (gptPanel) {
          const panelInner = gptPanel.querySelector('.sticky-top');
          if (panelInner && !execBody.contains(panelInner)) {
            const wrapper = document.createElement('div');
            wrapper.className = 'mt-3';
            wrapper.appendChild(panelInner);
            execBody.appendChild(wrapper);
          }
        }

        // 3) ì˜ˆì¸¡ ì…ë ¥ê°’ ë¸”ë¡ì„ í•˜ë‹¨ ì…ë ¥ ì¹´ë“œ ìƒë‹¨ìœ¼ë¡œ ì´ë™
        const textInput = document.getElementById('textInput');
        const predictions = document.getElementById('inputPredictions');
        if (textInput && predictions) {
          const bottomCardBody = textInput.closest('.card-body');
          if (bottomCardBody && !bottomCardBody.contains(predictions)) {
            // ì›ë˜ ìœ„ì¹˜ì˜ ì œëª©ì€ ì œê±°í•˜ê³ , ìƒˆ ì„¹ì…˜ì— ì œëª© ìƒì„±
            const section = document.createElement('div');
            section.className = 'mb-3';
            const h = document.createElement('h6');
            h.textContent = 'ì˜ˆì¸¡ ì…ë ¥ê°’';
            h.className = 'mb-2';
            section.appendChild(h);
            // ìŠ¤íƒ€ì¼ ìœ ì§€
            predictions.classList.add('border','rounded','p-2');
            section.appendChild(predictions);
            bottomCardBody.prepend(section);
            // ë¹„ì–´ìˆë‹¤ë©´ ì˜ˆì‹œ chip ì¶”ê°€
            if (!predictions.hasChildNodes() || predictions.innerText.trim().length === 0) {
              const chip = document.createElement('span');
              chip.className = 'badge bg-secondary me-2 mb-2';
              chip.textContent = 'ì†Œ (ê¸¸ì´ 1)';
              predictions.appendChild(chip);
            }
          }
        }
      } catch (e) {
        console.warn('Relocate panels error:', e);
      }
    })();

    // ===== ì•„ì´ë””ì–´ ìë™ ì €ì¥ =====
    (function setupNotesAutosave(){
      const $notes = document.getElementById('novelIdeaInput');
      const $status = document.getElementById('notesSaveStatus');
      if (!$notes) return;
      let t = null;
      const save = async () => {
        if (!currentNovelId) return;
        try {
          if ($status) $status.textContent = 'ì €ì¥ ì¤‘...';
          const res = await fetch(getServerUrl(`/api/novels/${encodeURIComponent(currentNovelId)}/notes`), {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: $notes.value || '' })
          });
          const data = await res.json();
          if (data.ok && $status) $status.textContent = 'ì €ì¥ë¨';
        } catch (e) {
          if ($status) $status.textContent = 'ì €ì¥ ì‹¤íŒ¨';
        }
      };
      const queue = () => {
        if (t) clearTimeout(t);
        t = setTimeout(save, 600);
      };
      $notes.addEventListener('input', queue);
      $notes.addEventListener('blur', save);
    })();
    
    </script>
</body>
</html>


