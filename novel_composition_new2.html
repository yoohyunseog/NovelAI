<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì†Œì„¤ êµ¬ì„± ìš”ì†Œ ê´€ë¦¬</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f5f5f5;
            padding: 0;
            margin: 0;
            width: 100%;
        }
        .main-container {
            width: 100%;
            margin: 0;
            padding: 0;
        }
        .card {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 0;
        }
        .attribute-item {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: white;
        }
        .attribute-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .attribute-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #007bff;
        }
        .bit-display {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
        }
        .data-item {
            background: #f8f9fa;
            padding: 10px;
            margin: 8px 0;
            border-left: 3px solid #28a745;
            border-radius: 4px;
        }
        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }
        .status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
        }
        .status-success {
            background-color: #d4edda;
            color: #155724;
        }
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .attribute-card {
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }
        .attribute-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
            border-color: #007bff !important;
        }
        .attribute-card:active {
            transform: translateY(0);
        }
        .attribute-item.highlighted {
            background-color: #fff3cd;
            border: 2px solid #ffc107;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
            animation: highlight-pulse 2s ease-in-out;
        }
        @keyframes highlight-pulse {
            0%, 100% {
                box-shadow: 0 0 15px rgba(255, 193, 7, 0.5);
            }
            50% {
                box-shadow: 0 0 25px rgba(255, 193, 7, 0.8);
            }
        }
        .log-container {
            width: 100%;
            background-color: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            border-top: 2px solid #333;
        }
        .log-entry {
            margin-bottom: 4px;
            padding: 2px 0;
            border-bottom: 1px solid #222;
        }
        .log-entry:first-child {
            border-top: 1px solid #333;
        }
        .log-time {
            color: #888;
            margin-right: 8px;
        }
        .log-message {
            color: #0f0;
        }
        .log-error {
            color: #f00;
        }
        .log-warn {
            color: #ff0;
        }
        .log-info {
            color: #0ff;
        }
        .log-entry {
            cursor: pointer;
        }
        .log-entry:hover {
            background-color: #1a1a1a;
        }
        .chapter-item {
            background-color: #f8f9fa;
            transition: all 0.2s ease;
        }
        .chapter-item:hover {
            background-color: #e9ecef;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1 class="mb-4 p-3">ğŸ“š ì†Œì„¤ êµ¬ì„± ìš”ì†Œ ê´€ë¦¬ (GPT ìë™ ì •ë¦¬)</h1>

        <!-- ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„± ì„¹ì…˜ -->
        <div class="card mb-3" style="border-radius: 0;">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h5 class="mb-0">ğŸ“– ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„±</h5>
                <button id="saveNovelConfigBtn" class="btn btn-sm btn-light">ğŸ’¾ ì €ì¥</button>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4 mb-3">
                        <label class="form-label fw-bold">ì†Œì„¤ ì œëª©</label>
                        <input 
                            type="text" 
                            id="novelTitle" 
                            class="form-control" 
                            placeholder="ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
                        >
                        <div class="mt-2">
                            <small class="text-muted">
                                <strong>BIT MAX:</strong> <span id="novelTitleBitMax">-</span><br>
                                <strong>BIT MIN:</strong> <span id="novelTitleBitMin">-</span>
                            </small>
                        </div>
                    </div>
                    <div class="col-md-8">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <label class="form-label fw-bold mb-0">ì±•í„° êµ¬ì„±</label>
                            <button id="addChapterBtn" class="btn btn-sm btn-success">â• ì±•í„° ì¶”ê°€</button>
                        </div>
                        <div id="chaptersList" class="border rounded p-2" style="min-height: 100px; max-height: 300px; overflow-y: auto;">
                            <div class="text-muted text-center">ì±•í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì±•í„°ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row g-0">
            <!-- ì¢Œì¸¡: ì†ì„± ëª©ë¡ ì„¹ì…˜ -->
            <div class="col-md-3">
                <div class="card h-100" style="border-radius: 0;">
                    <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">ğŸ“‹ ì €ì¥ëœ ì†ì„± ëª©ë¡</h5>
                        <button id="refreshBtn" class="btn btn-sm btn-light">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
                    </div>
                    <div class="card-body" style="max-height: calc(100vh - 200px); overflow-y: auto;">
                        <!-- ì†ì„± ê²€ìƒ‰ í•„í„° -->
                        <div class="mb-3 pb-3 border-bottom">
                            <label class="form-label fw-bold small mb-1">ì†ì„± N/B AI í•„í„°</label>
                            <input 
                                type="text" 
                                id="attributeFilterInput" 
                                class="form-control form-control-sm" 
                                placeholder="ì†Œì„¤ ì œëª© ë° ì±•í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”... (ì˜ˆ: ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 1: ê°œìš”)"
                            >
                            <small class="text-muted">ì…ë ¥í•˜ë©´ ìë™ìœ¼ë¡œ ì†ì„± ëª©ë¡ì´ ë¶ˆëŸ¬ì™€ì§‘ë‹ˆë‹¤.</small>
                        </div>
                        <div id="attributesList"></div>
                    </div>
                </div>
            </div>

            <!-- ê°€ìš´ë°: GPT ë¶„ì„ ê²°ê³¼ -->
            <div class="col-md-6">
                <!-- GPT ë¶„ì„ ê²°ê³¼ -->
                <div class="card" id="gptResultCard" style="display: none; border-radius: 0;">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0">ğŸ“‹ GPT ë¶„ì„ ê²°ê³¼</h5>
                    </div>
                    <div class="card-body">
                        <div id="gptResponse" class="mb-3 p-3 bg-light rounded" style="white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></div>
                        <div id="extractedAttributes" class="mb-3"></div>
                    </div>
                </div>
            </div>

            <!-- ìš°ì¸¡: GPT ë¶„ì„ ì…ë ¥ ì„¹ì…˜ -->
            <div class="col-md-3">
                <!-- GPT ìë™ ë¶„ì„ ì„¹ì…˜ -->
                <div class="card h-100" style="border-radius: 0;">
                    <div class="card-header bg-gradient text-white" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        <h5 class="mb-0">ğŸ¤– GPT AI ìë™ ì†ì„± ì¶”ì¶œ</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">ë¶„ì„í•  í…ìŠ¤íŠ¸ ì…ë ¥</label>
                            <textarea 
                                id="gptInput" 
                                class="form-control" 
                                placeholder="ì†Œì„¤ ê´€ë ¨ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”. GPTê°€ ìë™ìœ¼ë¡œ ì†ì„±(ì†Œì„¤ êµ¬ì„± ìš”ì†Œ)ë“¤ì„ ì¶”ì¶œí•˜ê³  ì •ë¦¬í•©ë‹ˆë‹¤.&#10;ì˜ˆ: ì†Œì„¤ì˜ ë‚´ìš©, ë“±ì¥ì¸ë¬¼ ì„¤ëª…, ë°°ê²½ ì„¤ì •, ì£¼ìš” ì‚¬ê±´ ë“±..."
                                rows="6"
                            ></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">í”„ë¡¬í”„íŠ¸ ì…ë ¥ 1</label>
                            <textarea 
                                id="gptPrompt1" 
                                class="form-control mb-2" 
                                placeholder="GPTì—ê²Œ ì¶”ê°€ ì§€ì‹œì‚¬í•­ì„ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ: 'ì†ì„±ì„ ë” ì¶”ê°€í•´ì£¼ì„¸ìš”', 'ì†Œì„¤ì˜ ë“±ì¥ì¸ë¬¼ê³¼ ë°°ê²½ë§Œ ì¶”ì¶œí•´ì£¼ì„¸ìš”', 'ì¥ë¥´ì™€ ì£¼ì œë¡œ ë¶„ë¥˜í•´ì£¼ì„¸ìš”' ë“±..."
                                rows="2"
                            ></textarea>
                        </div>
                        <button id="analyzeBtn1" class="btn btn-primary btn-lg w-100 mb-3">
                            ğŸ” GPT AIë¡œ ë¶„ì„ (í”„ë¡¬í”„íŠ¸ 1)
                        </button>
                        <div class="mb-3">
                            <label class="form-label fw-bold">í”„ë¡¬í”„íŠ¸ ì…ë ¥ 2</label>
                            <textarea 
                                id="gptPrompt2" 
                                class="form-control mb-2" 
                                placeholder="GPTì—ê²Œ ì¶”ê°€ ì§€ì‹œì‚¬í•­ì„ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ: 'ê°œìš”ë¥¼ ì¨ë‹¬ë¼', 'ìƒì„¸í•˜ê²Œ êµ¬ì¡°í™”í•´ì„œ ì‘ì„±í•´ì£¼ì„¸ìš”' ë“±..."
                                rows="2"
                            ></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold small mb-1">ì†ì„± (ìë™ ì…ë ¥)</label>
                            <input 
                                type="text" 
                                id="selectedAttributeInput" 
                                class="form-control form-control-sm" 
                                placeholder="GPT ë¶„ì„ í›„ ìë™ìœ¼ë¡œ ì…ë ¥ë©ë‹ˆë‹¤..."
                                readonly
                            >
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold small mb-1">GPT í”„ë¡¬í”„íŠ¸ ë¡œê·¸ (ë°ì´í„° ì œì™¸)</label>
                            <textarea 
                                id="gptPromptLog" 
                                class="form-control form-control-sm" 
                                placeholder="GPTì— ì „ë‹¬ëœ í”„ë¡¬í”„íŠ¸ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ (ë°ì´í„° í•„ë“œëŠ” ì œì™¸)..."
                                rows="4"
                                readonly
                                style="font-family: monospace; font-size: 0.85em;"
                            ></textarea>
                        </div>
                        <button id="analyzeBtn2" class="btn btn-success btn-lg w-100">
                            ğŸ” GPT AIë¡œ ë¶„ì„ (í”„ë¡¬í”„íŠ¸ 2)
                        </button>
                        <div id="gptStatus" class="mt-2 small"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ë¡œê·¸ ì¶œë ¥ ì˜ì—­ -->
        <div class="log-container" id="logContainer"></div>

        <!-- ì±•í„° ì¶”ê°€/í¸ì§‘ ëª¨ë‹¬ -->
        <div class="modal fade" id="chapterModal" tabindex="-1">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="chapterModalTitle">ì±•í„° ì¶”ê°€</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì±•í„° ë²ˆí˜¸ ë˜ëŠ” ì´ë¦„</label>
                            <input 
                                type="text" 
                                id="chapterNumberInput" 
                                class="form-control" 
                                placeholder="ì˜ˆ: ì±•í„° 1, ì œ1ì¥ ë“±"
                            >
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì±•í„° ì œëª©</label>
                            <input 
                                type="text" 
                                id="chapterTitleInput" 
                                class="form-control" 
                                placeholder="ì±•í„° ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
                            >
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì±•í„° ì„¤ëª… (ì„ íƒì‚¬í•­)</label>
                            <textarea 
                                id="chapterDescriptionInput" 
                                class="form-control" 
                                rows="3"
                                placeholder="ì±•í„°ì— ëŒ€í•œ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”"
                            ></textarea>
                        </div>
                        <div id="chapterModalStatus" class="small text-danger"></div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">ì·¨ì†Œ</button>
                        <button type="button" id="chapterModalSaveBtn" class="btn btn-primary">ì €ì¥</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì†ì„±ë³„ ë°ì´í„° ì¶”ê°€ ëª¨ë‹¬ -->
        <div class="modal fade" id="addDataModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">ë°ì´í„° ì¶”ê°€</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì†ì„±:</label>
                            <div id="modalAttributeName" class="fw-bold text-primary"></div>
                            <small class="text-muted">
                                BIT MAX: <span id="modalAttributeMax">-</span> | 
                                BIT MIN: <span id="modalAttributeMin">-</span>
                            </small>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ë°ì´í„° ì¶”ê°€ (ì´ ì†ì„±ì— ì†í•˜ëŠ” êµ¬ì²´ì ì¸ ë‚´ìš©)</label>
                            <textarea 
                                id="newDataInput" 
                                class="form-control" 
                                rows="3"
                                placeholder="ì˜ˆ: 'ì£¼ì¸ê³µì˜ ë‚´ì  ê°ˆë“±', 'ë§ˆë²• ì„¸ê³„ì˜ ë²•ì¹™' ë“±..."
                            ></textarea>
                            <div class="row mt-2">
                                <div class="col-md-6">
                                    <div class="bit-display">
                                        <strong>ë°ì´í„° BIT MAX:</strong> <span id="newDataMax">-</span>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="bit-display">
                                        <strong>ë°ì´í„° BIT MIN:</strong> <span id="newDataMin">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button id="saveDataBtn" class="btn btn-success">ë°ì´í„° ì €ì¥</button>
                        <span id="saveDataStatus" class="ms-2 small"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://xn--9l4b4xi9r.com/_8%EB%B9%84%ED%8A%B8/js/bitCalculation.js" defer></script>
    <script>
        // DOM ìš”ì†Œ
        const $novelTitle = document.getElementById('novelTitle');
        const $novelTitleBitMax = document.getElementById('novelTitleBitMax');
        const $novelTitleBitMin = document.getElementById('novelTitleBitMin');
        const $addChapterBtn = document.getElementById('addChapterBtn');
        const $chaptersList = document.getElementById('chaptersList');
        const $saveNovelConfigBtn = document.getElementById('saveNovelConfigBtn');
        
        const $gptPrompt1 = document.getElementById('gptPrompt1');
        const $gptPrompt2 = document.getElementById('gptPrompt2');
        const $gptInput = document.getElementById('gptInput');
        const $analyzeBtn1 = document.getElementById('analyzeBtn1');
        const $analyzeBtn2 = document.getElementById('analyzeBtn2');
        const $gptStatus = document.getElementById('gptStatus');
        const $selectedAttributeInput = document.getElementById('selectedAttributeInput');
        const $gptPromptLog = document.getElementById('gptPromptLog');
        const $gptResultCard = document.getElementById('gptResultCard');
        const $gptResponse = document.getElementById('gptResponse');
        const $extractedAttributes = document.getElementById('extractedAttributes');

        const $attributesList = document.getElementById('attributesList');
        const $refreshBtn = document.getElementById('refreshBtn');
        const $attributeFilterInput = document.getElementById('attributeFilterInput');
        
        // ë¡œê·¸ ê´€ë ¨
        const $logContainer = document.getElementById('logContainer');
        const MAX_LOG_ENTRIES = 50;

        // ì±•í„° ê´€ë¦¬
        let chapters = [];
        let currentChapterIdx = null; // í˜„ì¬ ì„ íƒëœ ì±•í„° ì¸ë±ìŠ¤
        
        // localStorage í‚¤
        const STORAGE_KEY_NOVEL_TITLE = 'novel_composition_novel_title';
        const STORAGE_KEY_CHAPTERS = 'novel_composition_chapters';
        const STORAGE_KEY_CURRENT_CHAPTER = 'novel_composition_current_chapter';
        
        // localStorageì— ì†Œì„¤ ì œëª© ì €ì¥
        function saveNovelTitle() {
            const title = $novelTitle.value.trim();
            if (title) {
                localStorage.setItem(STORAGE_KEY_NOVEL_TITLE, title);
                console.log('ì†Œì„¤ ì œëª© ì €ì¥:', title);
            } else {
                localStorage.removeItem(STORAGE_KEY_NOVEL_TITLE);
            }
        }
        
        // localStorageì— ì±•í„° ëª©ë¡ ì €ì¥
        function saveChapters() {
            try {
                console.log('saveChapters ì‹¤í–‰ ì‹œì‘', { chaptersCount: chapters.length, currentChapterIdx });
                const chaptersJson = JSON.stringify(chapters);
                localStorage.setItem(STORAGE_KEY_CHAPTERS, chaptersJson);
                localStorage.setItem(STORAGE_KEY_CURRENT_CHAPTER, String(currentChapterIdx));
                console.log('ì±•í„° ëª©ë¡ ì €ì¥ ì™„ë£Œ:', { 
                    chaptersCount: chapters.length, 
                    currentChapterIdx,
                    saved: localStorage.getItem(STORAGE_KEY_CHAPTERS) ? 'ì„±ê³µ' : 'ì‹¤íŒ¨'
                });
            } catch (e) {
                console.error('saveChapters ì˜¤ë¥˜:', e);
            }
        }
        
        // localStorageì—ì„œ ì†Œì„¤ ì œëª© ë³µì›
        function loadNovelTitle() {
            const savedTitle = localStorage.getItem(STORAGE_KEY_NOVEL_TITLE);
            if (savedTitle) {
                $novelTitle.value = savedTitle;
                console.log('ì†Œì„¤ ì œëª© ë³µì›:', savedTitle);
            }
        }
        
        // localStorageì—ì„œ ì±•í„° ëª©ë¡ ë³µì›
        function loadChapters() {
            try {
                const savedChapters = localStorage.getItem(STORAGE_KEY_CHAPTERS);
                if (savedChapters) {
                    chapters = JSON.parse(savedChapters);
                    console.log('ì±•í„° ëª©ë¡ ë³µì›:', chapters);
                }
                
                const savedCurrentChapter = localStorage.getItem(STORAGE_KEY_CURRENT_CHAPTER);
                if (savedCurrentChapter !== null) {
                    const idx = parseInt(savedCurrentChapter);
                    if (idx >= 0 && idx < chapters.length) {
                        currentChapterIdx = idx;
                        console.log('ì„ íƒëœ ì±•í„° ë³µì›:', idx);
                    }
                }
                
                renderChapters();
            } catch (e) {
                console.error('ì±•í„° ë³µì› ì‹¤íŒ¨:', e);
            }
        }
        
        // ì±•í„° ëª©ë¡ ë Œë”ë§
        function renderChapters() {
            if (chapters.length === 0) {
                $chaptersList.innerHTML = '<div class="text-muted text-center">ì±•í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì±•í„°ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš”.</div>';
                return;
            }
            
            console.log('ì±•í„° ë Œë”ë§ ì‹œì‘', { chaptersCount: chapters.length, currentChapterIdx });
            
            // BIT ìŠ¤í¬ë¦½íŠ¸ê°€ ë¡œë“œë˜ì—ˆëŠ”ì§€ ë¨¼ì € í™•ì¸
            if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
                console.log('BIT ìŠ¤í¬ë¦½íŠ¸ ë¡œë“œ ëŒ€ê¸° ì¤‘, ì ì‹œ í›„ ë‹¤ì‹œ ë Œë”ë§');
                setTimeout(() => renderChapters(), 200);
                return;
            }
            
            let html = '';
            chapters.forEach((chapter, idx) => {
                // currentChapterIdxê°€ 0ì¼ ë•Œë„ ì„ íƒëœ ê²ƒìœ¼ë¡œ ì²˜ë¦¬ (ëª…ì‹œì ìœ¼ë¡œ !== null && !== undefined ì²´í¬)
                const isSelected = (currentChapterIdx !== null && currentChapterIdx !== undefined && currentChapterIdx === idx);
                console.log(`ì±•í„° ${idx} ì„ íƒ ìƒíƒœ:`, { isSelected, currentChapterIdx, idx, type: typeof currentChapterIdx });
                
                // ì±•í„° BIT ê³„ì‚° (ì±•í„° ë²ˆí˜¸ + ì œëª©)
                const chapterText = `${chapter.number || ''} ${chapter.title || ''}`.trim();
                let chapterBitMax = '-';
                let chapterBitMin = '-';
                
                if (chapterText) {
                    const chapterBits = calculateBitValues(chapterText);
                    chapterBitMax = chapterBits.max !== null && chapterBits.max !== undefined ? chapterBits.max.toFixed(10) : '-';
                    chapterBitMin = chapterBits.min !== null && chapterBits.min !== undefined ? chapterBits.min.toFixed(10) : '-';
                    console.log(`ì±•í„° ${idx} BIT ê³„ì‚°:`, { chapterText, bitMax: chapterBitMax, bitMin: chapterBitMin });
                }
                
                html += `
                    <div class="d-flex align-items-center mb-2 p-2 border rounded chapter-item ${isSelected ? 'bg-primary text-white' : ''}" data-chapter-idx="${idx}">
                        <div class="flex-grow-1">
                            <div class="fw-bold">${escapeHtml(chapter.number || `ì±•í„° ${idx + 1}`)}: ${escapeHtml(chapter.title || '(ì œëª© ì—†ìŒ)')}</div>
                            ${chapter.description ? `<div class="small ${isSelected ? 'text-white-50' : 'text-muted'} mt-1">${escapeHtml(chapter.description)}</div>` : ''}
                            <div class="small ${isSelected ? 'text-white-50' : 'text-muted'} mt-1">
                                <strong>BIT MAX:</strong> ${chapterBitMax} | 
                                <strong>BIT MIN:</strong> ${chapterBitMin}
                            </div>
                            ${isSelected ? '<div class="small mt-1" style="font-weight: bold; color: white;"><strong>âœ“ í˜„ì¬ ì‘ì—… ì¤‘ì¸ ì±•í„°</strong></div>' : ''}
                        </div>
                        <div class="ms-2">
                            <button class="btn btn-sm ${isSelected ? 'btn-light' : 'btn-outline-primary'} select-chapter-btn" data-idx="${idx}">${isSelected ? 'âœ“ ì„ íƒë¨' : 'ì„ íƒ'}</button>
                            <button class="btn btn-sm ${isSelected ? 'btn-light' : 'btn-outline-primary'} edit-chapter-btn" data-idx="${idx}">âœï¸ í¸ì§‘</button>
                            <button class="btn btn-sm ${isSelected ? 'btn-outline-light' : 'btn-outline-danger'} delete-chapter-btn" data-idx="${idx}">ğŸ—‘ï¸ ì‚­ì œ</button>
                        </div>
                    </div>
                `;
            });
            $chaptersList.innerHTML = html;
            
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            $chaptersList.querySelectorAll('.select-chapter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.getAttribute('data-idx'));
                    selectChapter(idx);
                });
            });
            
            $chaptersList.querySelectorAll('.edit-chapter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.getAttribute('data-idx'));
                    openEditChapterModal(idx);
                });
            });
            
            $chaptersList.querySelectorAll('.delete-chapter-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(e.target.getAttribute('data-idx'));
                    deleteChapter(idx);
                });
            });
        }
        
        // ì±•í„° ì„ íƒ
        function selectChapter(idx) {
            if (idx < 0 || idx >= chapters.length) {
                console.warn('ì˜ëª»ëœ ì±•í„° ì¸ë±ìŠ¤:', idx);
                return;
            }
            currentChapterIdx = idx;
            console.log('ì±•í„° ì„ íƒ:', { idx, currentChapterIdx, chapter: chapters[idx] });
            renderChapters();
            saveChapters(); // ìë™ ì €ì¥
            
            // í•„í„° ì…ë ¥ë€ì— ë™ê¸°í™”
            syncFilterInputs();
            
            // ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨ (ì„ íƒëœ ì±•í„° ê¸°ì¤€ìœ¼ë¡œ)
            if (chapters.length > 0) {
                loadAttributes();
            }
        }
        
        // í•„í„° ì…ë ¥ë€ì— ì†Œì„¤ ì œëª© ë° ì±•í„° ë™ê¸°í™”
        function syncFilterInputs() {
            if (!$attributeFilterInput) return;
            
            // ì†Œì„¤ ì œëª© ê°€ì ¸ì˜¤ê¸°
            const novelTitle = $novelTitle.value.trim();
            
            // ì„ íƒëœ ì±•í„° ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            let chapterText = '';
            if (currentChapterIdx !== null && currentChapterIdx !== undefined && currentChapterIdx >= 0 && currentChapterIdx < chapters.length) {
                const selectedChapter = chapters[currentChapterIdx];
                chapterText = `${selectedChapter.number || `ì±•í„° ${currentChapterIdx + 1}`}${selectedChapter.title ? `: ${selectedChapter.title}` : ''}`;
            }
            
            // "ì†Œì„¤ ì œëª© â†’ ì±•í„° ë²ˆí˜¸: ì±•í„° ì œëª©" í˜•ì‹ìœ¼ë¡œ í†µí•©
            if (novelTitle && chapterText) {
                $attributeFilterInput.value = `${novelTitle} â†’ ${chapterText}`;
            } else if (novelTitle) {
                $attributeFilterInput.value = novelTitle;
            } else {
                $attributeFilterInput.value = '';
            }
            
            console.log('í•„í„° ì…ë ¥ë€ ë™ê¸°í™”:', { novelTitle, chapterText, value: $attributeFilterInput.value });
        }
        
        // ì±•í„° ì¶”ê°€ ëª¨ë‹¬ ì—´ê¸°
        function openAddChapterModal() {
            editingChapterIdx = null;
            $chapterModalTitle.textContent = 'ì±•í„° ì¶”ê°€';
            $chapterNumberInput.value = `ì±•í„° ${chapters.length + 1}`;
            $chapterTitleInput.value = '';
            $chapterDescriptionInput.value = '';
            $chapterModalStatus.textContent = '';
            chapterModal.show();
        }
        
        // ì±•í„° í¸ì§‘ ëª¨ë‹¬ ì—´ê¸°
        function openEditChapterModal(idx) {
            if (idx < 0 || idx >= chapters.length) return;
            
            const chapter = chapters[idx];
            editingChapterIdx = idx;
            $chapterModalTitle.textContent = 'ì±•í„° í¸ì§‘';
            $chapterNumberInput.value = chapter.number || '';
            $chapterTitleInput.value = chapter.title || '';
            $chapterDescriptionInput.value = chapter.description || '';
            $chapterModalStatus.textContent = '';
            chapterModal.show();
        }
        
        // ì±•í„° ì €ì¥ (ì¶”ê°€/í¸ì§‘)
        function saveChapter() {
            console.log('saveChapter í•¨ìˆ˜ í˜¸ì¶œë¨');
            try {
                const number = $chapterNumberInput.value.trim();
                const title = $chapterTitleInput.value.trim();
                const description = $chapterDescriptionInput.value.trim();
                
                console.log('ì…ë ¥ê°’ í™•ì¸:', { number, title, description });
                
                if (!number) {
                    $chapterModalStatus.textContent = 'ì±•í„° ë²ˆí˜¸ ë˜ëŠ” ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.';
                    $chapterModalStatus.style.display = 'block';
                    console.warn('ì±•í„° ë²ˆí˜¸ ì—†ìŒ');
                    return;
                }
                
                if (!title) {
                    $chapterModalStatus.textContent = 'ì±•í„° ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.';
                    $chapterModalStatus.style.display = 'block';
                    console.warn('ì±•í„° ì œëª© ì—†ìŒ');
                    return;
                }
                
                $chapterModalStatus.textContent = '';
                $chapterModalStatus.style.display = 'none';
                
                const chapterData = {
                    number: number,
                    title: title,
                    description: description
                };
                
                if (editingChapterIdx !== null) {
                    // í¸ì§‘
                    chapters[editingChapterIdx] = chapterData;
                    console.log('ì±•í„° í¸ì§‘:', { idx: editingChapterIdx, chapter: chapterData });
                } else {
                    // ì¶”ê°€
                    chapters.push(chapterData);
                    console.log('ì±•í„° ì¶”ê°€:', chapterData);
                }
                
                console.log('ì±•í„° ëª©ë¡ ì—…ë°ì´íŠ¸ í›„:', chapters);
                renderChapters();
                
                console.log('saveChapters í•¨ìˆ˜ í˜¸ì¶œ ì‹œì‘');
                saveChapters(); // ìë™ ì €ì¥
                console.log('saveChapters í•¨ìˆ˜ í˜¸ì¶œ ì™„ë£Œ');
                
                // í•„í„° ì…ë ¥ë€ì— ë™ê¸°í™”
                syncFilterInputs();
                
                chapterModal.hide();
                console.log('ëª¨ë‹¬ ë‹«ê¸° ì™„ë£Œ');
            } catch (e) {
                console.error('saveChapter ì˜¤ë¥˜:', e);
                $chapterModalStatus.textContent = `ì˜¤ë¥˜: ${e.message}`;
                $chapterModalStatus.style.display = 'block';
            }
        }
        
        // ì±•í„° ì‚­ì œ
        function deleteChapter(idx) {
            if (idx < 0 || idx >= chapters.length) return;
            
            const chapter = chapters[idx];
            chapters.splice(idx, 1);
            
            // ì„ íƒëœ ì±•í„°ê°€ ì‚­ì œëœ ê²½ìš° ì¸ë±ìŠ¤ ì¡°ì •
            if (currentChapterIdx === idx) {
                currentChapterIdx = null;
            } else if (currentChapterIdx > idx) {
                currentChapterIdx--;
            }
            
            renderChapters();
            saveChapters(); // ìë™ ì €ì¥
            console.log('ì±•í„° ì‚­ì œ:', { idx, chapter: chapter });
            
            // ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨
            loadAttributes();
        }
        
        // ì±•í„° ì¶”ê°€ ë²„íŠ¼ ì´ë²¤íŠ¸
        $addChapterBtn.addEventListener('click', () => {
            console.log('ì±•í„° ì¶”ê°€ ë²„íŠ¼ í´ë¦­');
            openAddChapterModal();
        });
        
        // ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„± ì €ì¥ ë²„íŠ¼
        $saveNovelConfigBtn.addEventListener('click', () => {
            console.log('ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„± ì €ì¥ ë²„íŠ¼ í´ë¦­');
            const novelTitle = $novelTitle.value.trim();
            
            if (!novelTitle) {
                alert('ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.');
                $novelTitle.focus();
                return;
            }
            
            if (chapters.length === 0) {
                const confirmAdd = confirm('ì±•í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì±•í„°ë¥¼ ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?');
                if (confirmAdd) {
                    openAddChapterModal();
                    return;
                }
            }
            
            // ì €ì¥ ì‹¤í–‰
            saveNovelTitle();
            saveChapters();
            
            // í”¼ë“œë°± í‘œì‹œ
            const originalText = $saveNovelConfigBtn.textContent;
            $saveNovelConfigBtn.textContent = 'âœ“ ì €ì¥ ì™„ë£Œ';
            $saveNovelConfigBtn.classList.remove('btn-light');
            $saveNovelConfigBtn.classList.add('btn-success');
            
            setTimeout(() => {
                $saveNovelConfigBtn.textContent = originalText;
                $saveNovelConfigBtn.classList.remove('btn-success');
                $saveNovelConfigBtn.classList.add('btn-light');
            }, 2000);
            
            console.log('ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„± ì €ì¥ ì™„ë£Œ', { 
                novelTitle, 
                chaptersCount: chapters.length,
                currentChapterIdx 
            });
            addLog('info', `ì†Œì„¤ ì œëª© ë° ì±•í„° êµ¬ì„± ì €ì¥ ì™„ë£Œ: ${novelTitle} (ì±•í„° ${chapters.length}ê°œ)`);
        });
        
        // ì†Œì„¤ ì œëª© ì…ë ¥ ì‹œ BIT ê°’ ê³„ì‚° ë° í‘œì‹œ
        $novelTitle.addEventListener('input', () => {
            const title = $novelTitle.value.trim();
            updateNovelTitleBits(title);
            
            saveNovelTitle(); // ìë™ ì €ì¥
            
            // í•„í„° ì…ë ¥ë€ì— ë™ê¸°í™”
            syncFilterInputs();
            
            if (title) {
                loadAttributes();
            }
        });
        
        // ì†Œì„¤ ì œëª© BIT ê°’ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateNovelTitleBits(title) {
            if (!title) {
                $novelTitleBitMax.textContent = '-';
                $novelTitleBitMin.textContent = '-';
                return;
            }
            
            // BIT ê³„ì‚° í•¨ìˆ˜ê°€ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
            if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
                // ì•„ì§ ë¡œë“œë˜ì§€ ì•ŠìŒ, ì ì‹œ í›„ ì¬ì‹œë„
                setTimeout(() => updateNovelTitleBits(title), 100);
                console.log('BIT ê³„ì‚° í•¨ìˆ˜ ë¡œë“œ ëŒ€ê¸° ì¤‘...');
                return;
            }
            
            const bits = calculateBitValues(title);
            $novelTitleBitMax.textContent = bits.max !== null && bits.max !== undefined ? bits.max.toFixed(10) : '-';
            $novelTitleBitMin.textContent = bits.min !== null && bits.min !== undefined ? bits.min.toFixed(10) : '-';
        }
        
        // ì†Œì„¤ ì œëª© ë³€ê²½ ì‹œ ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨
        $novelTitle.addEventListener('change', () => {
            saveNovelTitle(); // ìë™ ì €ì¥
            loadAttributes();
        });

        // ë¡œê·¸ ì¶”ê°€ í•¨ìˆ˜
        function addLog(type, ...args) {
            const timestamp = new Date().toLocaleTimeString();
            let fullMessage = args.map(arg => {
                if (typeof arg === 'object') {
                    try {
                        return JSON.stringify(arg, null, 2);
                    } catch (e) {
                        return String(arg);
                    }
                }
                return String(arg);
            }).join(' ');

            // í‘œì‹œìš© ë©”ì‹œì§€ ê¸¸ì´ 50ìë¡œ ì œí•œ
            let displayMessage = fullMessage;
            const isTruncated = fullMessage.length > 50;
            if (isTruncated) {
                displayMessage = fullMessage.substring(0, 47) + '...';
            }

            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry';
            logEntry.setAttribute('data-full-message', fullMessage);
            logEntry.setAttribute('data-timestamp', timestamp);
            logEntry.setAttribute('data-type', type);
            
            const timeSpan = document.createElement('span');
            timeSpan.className = 'log-time';
            timeSpan.textContent = `[${timestamp}]`;
            
            const messageSpan = document.createElement('span');
            messageSpan.className = `log-message log-${type}`;
            messageSpan.textContent = displayMessage;
            
            logEntry.appendChild(timeSpan);
            logEntry.appendChild(messageSpan);
            
            // í´ë¦­ ì´ë²¤íŠ¸: ì „ì²´ ë©”ì‹œì§€ ë³´ê¸°
            if (isTruncated || fullMessage.length > 0) {
                logEntry.addEventListener('click', () => {
                    showLogDetail(fullMessage, timestamp, type);
                });
            }
            
            // prepend: ìƒˆ ë©”ì‹œì§€ë¥¼ ë§¨ ìœ„ì— ì¶”ê°€
            const firstChild = $logContainer.firstChild;
            if (firstChild) {
                $logContainer.insertBefore(logEntry, firstChild);
            } else {
                $logContainer.appendChild(logEntry);
            }
            
            // ìµœëŒ€ 50ê°œê¹Œì§€ë§Œ ìœ ì§€ (ë§¨ ì•„ë˜ë¶€í„° ì œê±°)
            const allEntries = $logContainer.querySelectorAll('.log-entry');
            if (allEntries.length > MAX_LOG_ENTRIES) {
                // ë§¨ ì•„ë˜(ê°€ì¥ ì˜¤ë˜ëœ) í•­ëª© ì œê±°
                const oldestEntry = allEntries[allEntries.length - 1];
                if (oldestEntry && oldestEntry.parentNode) {
                    oldestEntry.parentNode.removeChild(oldestEntry);
                }
            }
        }

        // ë¡œê·¸ ìƒì„¸ ë‚´ìš© í‘œì‹œ
        function showLogDetail(fullMessage, timestamp, type) {
            const typeLabels = {
                'message': 'ì •ë³´',
                'error': 'ì—ëŸ¬',
                'warn': 'ê²½ê³ ',
                'info': 'ì •ë³´'
            };
            
            // HTML ì´ìŠ¤ì¼€ì´í”„ í—¬í¼ í•¨ìˆ˜
            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
            
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.setAttribute('tabindex', '-1');
            
            const modalContent = document.createElement('div');
            modalContent.className = 'modal-dialog modal-lg';
            
            const content = document.createElement('div');
            content.className = 'modal-content bg-dark text-light';
            
            // í—¤ë”
            const header = document.createElement('div');
            header.className = 'modal-header border-secondary';
            header.innerHTML = `
                <h5 class="modal-title">ë¡œê·¸ ìƒì„¸ ë‚´ìš©</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            `;
            
            // ë°”ë””
            const body = document.createElement('div');
            body.className = 'modal-body';
            
            const timeDiv = document.createElement('div');
            timeDiv.className = 'mb-2';
            timeDiv.innerHTML = `<strong>ì‹œê°„:</strong> ${escapeHtml(timestamp)}`;
            
            const typeDiv = document.createElement('div');
            typeDiv.className = 'mb-2';
            typeDiv.innerHTML = `<strong>íƒ€ì…:</strong> <span class="log-${type}">${typeLabels[type] || type}</span>`;
            
            const labelDiv = document.createElement('div');
            labelDiv.className = 'mb-2';
            labelDiv.innerHTML = `<strong>ì „ì²´ ë©”ì‹œì§€:</strong>`;
            
            const messageDiv = document.createElement('div');
            messageDiv.className = 'p-3 bg-black rounded';
            messageDiv.style.cssText = 'max-height: 400px; overflow-y: auto; font-family: monospace; white-space: pre-wrap; word-break: break-all; color: #0f0;';
            messageDiv.textContent = fullMessage;
            
            body.appendChild(timeDiv);
            body.appendChild(typeDiv);
            body.appendChild(labelDiv);
            body.appendChild(messageDiv);
            
            // í‘¸í„°
            const footer = document.createElement('div');
            footer.className = 'modal-footer border-secondary';
            
            const closeBtn = document.createElement('button');
            closeBtn.type = 'button';
            closeBtn.className = 'btn btn-secondary';
            closeBtn.setAttribute('data-bs-dismiss', 'modal');
            closeBtn.textContent = 'ë‹«ê¸°';
            
            footer.appendChild(closeBtn);
            
            content.appendChild(header);
            content.appendChild(body);
            content.appendChild(footer);
            modalContent.appendChild(content);
            modal.appendChild(modalContent);
            
            document.body.appendChild(modal);
            
            const bsModal = new bootstrap.Modal(modal);
            bsModal.show();
            
            // ëª¨ë‹¬ì´ ë‹«íˆë©´ DOMì—ì„œ ì œê±°
            modal.addEventListener('hidden.bs.modal', () => {
                if (modal.parentNode) {
                    document.body.removeChild(modal);
                }
            });
        }


        // console ë©”ì„œë“œ ì¸í„°ì…‰ì…˜
        (function() {
            const originalLog = console.log;
            const originalError = console.error;
            const originalWarn = console.warn;
            const originalInfo = console.info;

            console.log = function(...args) {
                originalLog.apply(console, args);
                addLog('message', ...args);
            };

            console.error = function(...args) {
                originalError.apply(console, args);
                addLog('error', ...args);
            };

            console.warn = function(...args) {
                originalWarn.apply(console, args);
                addLog('warn', ...args);
            };

            console.info = function(...args) {
                originalInfo.apply(console, args);
                addLog('info', ...args);
            };
        })();

        // ì „ì—­ ì—ëŸ¬ í•¸ë“¤ëŸ¬
        window.addEventListener('error', (event) => {
            console.error('ì „ì—­ ì—ëŸ¬:', event.error || event.message, event.filename, event.lineno);
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('ì²˜ë¦¬ë˜ì§€ ì•Šì€ Promise ê±°ë¶€:', event.reason);
        });

        // Fetch ì—ëŸ¬ ì¸í„°ì…‰ì…˜ (ì„ íƒì )
        const originalFetch = window.fetch;
        window.fetch = async function(...args) {
            try {
                const response = await originalFetch.apply(this, args);
                return response;
            } catch (error) {
                console.error('Fetch ì—ëŸ¬:', error, args[0]);
                throw error;
            }
        };
        
        // ëª¨ë‹¬ ê´€ë ¨
        const chapterModal = new bootstrap.Modal(document.getElementById('chapterModal'));
        const $chapterModalTitle = document.getElementById('chapterModalTitle');
        const $chapterNumberInput = document.getElementById('chapterNumberInput');
        const $chapterTitleInput = document.getElementById('chapterTitleInput');
        const $chapterDescriptionInput = document.getElementById('chapterDescriptionInput');
        const $chapterModalSaveBtn = document.getElementById('chapterModalSaveBtn');
        const $chapterModalStatus = document.getElementById('chapterModalStatus');
        let editingChapterIdx = null; // í¸ì§‘ ì¤‘ì¸ ì±•í„° ì¸ë±ìŠ¤
        
        // ì±•í„° ëª¨ë‹¬ ì €ì¥ ë²„íŠ¼ ì´ë²¤íŠ¸
        $chapterModalSaveBtn.addEventListener('click', () => {
            console.log('ì±•í„° ëª¨ë‹¬ ì €ì¥ ë²„íŠ¼ í´ë¦­ë¨');
            saveChapter();
        });
        
        // ëª¨ë‹¬ì—ì„œ Enter í‚¤ë¡œ ì €ì¥
        $chapterNumberInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                $chapterTitleInput.focus();
            }
        });
        
        $chapterTitleInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveChapter();
            }
        });
        
        $chapterDescriptionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && e.ctrlKey) {
                e.preventDefault();
                saveChapter();
            }
        });
        
        const addDataModal = new bootstrap.Modal(document.getElementById('addDataModal'));
        const $modalAttributeName = document.getElementById('modalAttributeName');
        const $modalAttributeMax = document.getElementById('modalAttributeMax');
        const $modalAttributeMin = document.getElementById('modalAttributeMin');
        const $newDataInput = document.getElementById('newDataInput');
        const $newDataMax = document.getElementById('newDataMax');
        const $newDataMin = document.getElementById('newDataMin');
        const $saveDataBtn = document.getElementById('saveDataBtn');
        const $saveDataStatus = document.getElementById('saveDataStatus');

        let currentAttribute = null;
        let extractedAttributesList = [];

        function getServerUrl(path) {
            if (window.location.protocol === 'file:') {
                return `http://localhost:8123${path}`;
            }
            return path;
        }

        function calculateBitValues(text) {
            if (!text || typeof text !== 'string' || text.trim() === '') {
                return { max: null, min: null };
            }
            try {
                if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
                    console.warn('BIT ê³„ì‚° í•¨ìˆ˜ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                    return { max: null, min: null };
                }
                const unicodeArray = wordNbUnicodeFormat(text);
                const max = BIT_MAX_NB(unicodeArray);
                const min = BIT_MIN_NB(unicodeArray);
                return { max: isFinite(max) ? max : null, min: isFinite(min) ? min : null };
            } catch (e) {
                console.error('BIT ê³„ì‚° ì˜¤ë¥˜:', e);
                return { max: null, min: null };
            }
        }

        // ë§ˆí¬ë‹¤ìš´ ë¬¸ì ì œê±° í•¨ìˆ˜ (ì•ˆì „í•œ ë°©ì‹ - í…ìŠ¤íŠ¸ ë‚´ìš© ì†ìƒ ë°©ì§€)
        function removeMarkdownChars(text) {
            if (!text || typeof text !== 'string') {
                return text;
            }
            
            // ë¨¼ì € ì¤„ë³„ë¡œ ì²˜ë¦¬í•˜ì—¬ í—¤ë”ë§Œ ì •í™•íˆ ì œê±°
            let lines = text.split('\n');
            lines = lines.map(line => {
                // ì¤„ ì‹œì‘ì— ìˆëŠ” í—¤ë”ë§Œ ì œê±° (#ìœ¼ë¡œ ì‹œì‘í•˜ê³  ê³µë°±ì´ ë’¤ë”°ë¥´ëŠ” ê²½ìš°ë§Œ)
                if (/^#{1,6}\s+/.test(line)) {
                    return line.replace(/^#{1,6}\s+/, '');
                }
                return line;
            });
            
            let result = lines.join('\n');
            
            // ë³¼ë“œ/ì´íƒ¤ë¦­ì€ í…ìŠ¤íŠ¸ë¥¼ ê°ì‹¸ëŠ” ê²½ìš°ë§Œ ì œê±° (ë‹¨ë…ìœ¼ë¡œ ìˆëŠ” *ëŠ” ì œê±°í•˜ì§€ ì•ŠìŒ)
            // ***text*** í˜•íƒœ (ê³µë°± ì—†ëŠ” ê²½ìš°ë§Œ)
            result = result.replace(/\*\*\*([^*\s][^*]*?[^*\s])\*\*\*/g, '$1');
            // **text** í˜•íƒœ
            result = result.replace(/\*\*([^*\s][^*]*?[^*\s])\*\*/g, '$1');
            // *text* í˜•íƒœ (ë‹¨ì–´ë¥¼ ê°ì‹¸ëŠ” ê²½ìš°, ë‹¨ë… *ëŠ” ì œê±°í•˜ì§€ ì•ŠìŒ)
            result = result.replace(/\*([^\s*][^*]*?[^\s*])\*/g, '$1');
            
            // ì–¸ë”ìŠ¤ì½”ì–´ ë³¼ë“œ/ì´íƒ¤ë¦­ ì œê±° (í…ìŠ¤íŠ¸ë¥¼ ê°ì‹¸ëŠ” ê²½ìš°ë§Œ)
            result = result.replace(/__([^_]+?)__/g, '$1');
            result = result.replace(/\b_([^_\s]+?)_\b/g, '$1');
            
            // ì½”ë“œ ë¸”ë¡ ì œê±° (``` ë¡œ ì‹œì‘í•˜ê³  ```ë¡œ ëë‚˜ëŠ” ë¸”ë¡ë§Œ)
            result = result.replace(/```[\s\S]*?```/g, '');
            // ì¸ë¼ì¸ ì½”ë“œ ì œê±° (`ë¡œ ê°ì‹¼ ê²½ìš°ë§Œ)
            result = result.replace(/`([^`]+?)`/g, '$1');
            
            // ë§í¬ ì œê±° ([text](url))
            result = result.replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1');
            // ì´ë¯¸ì§€ ì œê±° (![text](url))
            result = result.replace(/!\[([^\]]+)\]\([^\)]+\)/g, '$1');
            
            // ë‹¨ë…ìœ¼ë¡œ ìˆëŠ” ë§ˆí¬ë‹¤ìš´ ë¬¸ì ì œê±° (###, *** ë“±ì´ í˜¼ì ìˆëŠ” ê²½ìš°)
            result = result.replace(/^#{1,6}$/gm, '');
            result = result.replace(/^\*{1,3}$/gm, '');
            
            // ì¤„ë°”ê¿ˆ ì •ë¦¬
            result = result.replace(/\n{3,}/g, '\n\n');
            
            return result.trim();
        }

        // GPT ë¶„ì„ í•¨ìˆ˜
        async function analyzeWithGPT(customPrompt = null) {
            const text = $gptInput.value.trim();
            if (!text) {
                console.warn('GPT ë¶„ì„: ë¶„ì„í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                $gptStatus.textContent = 'âœ— ë¶„ì„í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $gptStatus.style.color = '#dc3545';
                return;
            }

            // í”„ë¡¬í”„íŠ¸ê°€ ì „ë‹¬ë˜ì§€ ì•Šìœ¼ë©´ ì²« ë²ˆì§¸ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©
            if (customPrompt === null) {
                customPrompt = $gptPrompt1.value.trim();
            }

            // í”„ë¡¬í”„íŠ¸ ë¡œê·¸ ì¶œë ¥ (50ì ì œí•œ)
            const promptForLog = customPrompt && customPrompt.length > 50 
                ? customPrompt.substring(0, 47) + '...' 
                : customPrompt || '(ì—†ìŒ)';
            console.log('GPT ë¶„ì„ ì‹œì‘', `í”„ë¡¬í”„íŠ¸: ${promptForLog}`, `í…ìŠ¤íŠ¸ê¸¸ì´: ${text.length}`);

            try {
                // ë‘ ë²„íŠ¼ ëª¨ë‘ ë¹„í™œì„±í™”
                $analyzeBtn1.disabled = true;
                $analyzeBtn2.disabled = true;
                $gptStatus.textContent = 'GPT AI ë¶„ì„ ì¤‘...';
                $gptStatus.style.color = '#007bff';
                $gptResponse.textContent = 'ë¶„ì„ ì¤‘...';

                console.log('í”„ë¡¬í”„íŠ¸ ì„¤ì •', `í”„ë¡¬í”„íŠ¸: ${promptForLog}`);
                
                // ê°œìš” ìš”ì²­ í™•ì¸ (ë” ë„“ì€ ë²”ìœ„ë¡œ ê²€ìƒ‰)
                const lowerPrompt = customPrompt ? customPrompt.toLowerCase() : '';
                const isOutlineRequest = customPrompt && (
                    lowerPrompt.includes('ê°œìš”') || 
                    lowerPrompt.includes('ìƒì„¸') || 
                    lowerPrompt.includes('êµ¬ì¡°í™”') ||
                    lowerPrompt.includes('outline') ||
                    lowerPrompt.includes('ìš”ì•½') ||
                    lowerPrompt.includes('ì •ë¦¬')
                );
                
                console.log('ê°œìš” ìš”ì²­ í™•ì¸', { isOutlineRequest, customPrompt });
                
                const outlineInstructions = isOutlineRequest ? `

**âš ï¸ ì¤‘ìš”: ê°œìš” ì‘ì„± ëª¨ë“œ í™œì„±í™” âš ï¸**
ì‚¬ìš©ìê°€ "${customPrompt}"ë¼ê³  ìš”ì²­í–ˆìŠµë‹ˆë‹¤. ì´ë¥¼ ë°˜ë“œì‹œ ì¤€ìˆ˜í•˜ì„¸ìš”.

ê° ì†ì„±ì˜ "ë°ì´í„°" ë¶€ë¶„ì„ êµ¬ì¡°í™”ë˜ê³  ìƒì„¸í•œ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•´ì£¼ì„¸ìš”:

- **ë“±ì¥ì¸ë¬¼ì˜ ê²½ìš°**: ê° ì¸ë¬¼ì˜ ì´ë¦„, ì—­í• , íŠ¹ì§•ì„ ëª…í™•íˆ êµ¬ë¶„í•˜ì—¬ ì‘ì„±
  ì˜ˆ: "ì¹´ì´ (ì£¼ì¸ê³µ): ì—˜í”„ ê°€ë“œì— í•©ë¥˜í•œ ì¸ë¬¼, ì •ì²´ì„±ì„ ì°¾ëŠ” ì¤‘ | ì„¸ë¦¬ì—˜: ë¦¬ë” ì—­í• , ê²½í—˜ ë§ì€ ì „ì‚¬ | ë¦¬ì•„ë‚˜: ì§€ì› ì—­í• , ë§ˆë²•ì‚¬..."

- **ë°°ê²½ ì„¤ì •ì˜ ê²½ìš°**: ì‹œê°„, ì¥ì†Œ, ì„¸ê³„ê´€ì„ êµ¬ë¶„í•˜ì—¬ ì‘ì„±
  ì˜ˆ: "ì‹œê°„: íŒíƒ€ì§€ ì‹œëŒ€ | ì¥ì†Œ: ì–´ë‘ìš´ ìˆ² | ì„¸ê³„ê´€: ì—˜í”„ ê°€ë“œì˜ ì „ì„¤ì´ ì¡´ì¬í•˜ëŠ” íŒíƒ€ì§€ ì„¸ê³„..."

- **ì£¼ìš” ì‚¬ê±´ì˜ ê²½ìš°**: ì‚¬ê±´ë“¤ì„ ì‹œê°„ìˆœ ë˜ëŠ” ì¤‘ìš”ë„ìˆœìœ¼ë¡œ ì •ë¦¬
  ì˜ˆ: "1. ì¹´ì´ê°€ ì—˜í”„ ê°€ë“œ ë¶€ëŒ€ì— í•©ë¥˜ | 2. ì „íˆ¬ì™€ ê°±í‚¹ ë°œìƒ | 3. ìì¹´ë¥´ì™€ì˜ ëŒ€ì¹˜ | 4. í¬í¬ë¦¬ì˜ ë“±ì¥ ë° í˜‘ë ¥..."

- **ê°ì •/ë¶„ìœ„ê¸°ì˜ ê²½ìš°**: ê°ì • ë³€í™”ì™€ ë¶„ìœ„ê¸°ë¥¼ êµ¬ì²´ì ìœ¼ë¡œ ì„¤ëª…
  ì˜ˆ: "ê¸´ì¥ê°: ì „íˆ¬ ìƒí™©ì—ì„œì˜ ë¶ˆì•ˆê° | í˜‘ë ¥: ìœ„ê¸° ìƒí™©ì—ì„œì˜ ì—°ëŒ€ê° | í˜¼ë€: ì˜ˆìƒì¹˜ ëª»í•œ ìƒí™©ì— ëŒ€í•œ ë‹¹í™©..."

- **í…Œë§ˆ/ì£¼ì œì˜ ê²½ìš°**: ì£¼ìš” ì£¼ì œì™€ í•˜ìœ„ ì£¼ì œë¥¼ êµ¬ë¶„
  ì˜ˆ: "- í˜‘ë ¥ê³¼ ë°°ì‹ : ë™ë£Œë“¤ ê°„ì˜ ì‹ ë¢° ê´€ê³„ | - ì •ì²´ì„±ì˜ íƒêµ¬: ì¹´ì´ì˜ ìê¸° ë°œê²¬ | - ì „ì„¤ê³¼ í˜„ì‹¤ì˜ ì¶©ëŒ: ì´ìƒê³¼ í˜„ì‹¤ì˜ ê°­..."

- **ìŠ¤íƒ€ì¼/í†¤ì˜ ê²½ìš°**: ë¬¸ì²´ íŠ¹ì§•ê³¼ í†¤ì„ êµ¬ì²´ì ìœ¼ë¡œ ì„¤ëª…
  ì˜ˆ: "ë¬¸ì²´: ì„œì‚¬ì  ë¬¸ì²´, ê¸´ì¥ê° ìˆëŠ” ì„œìˆ  | í†¤: íŒíƒ€ì§€ì  ìš”ì†Œ ê°•ì¡°, ì§„ì§€í•˜ê³  ëª°ì…ë„ ë†’ì€ ë¶„ìœ„ê¸°..."

**âš ï¸ ë°˜ë“œì‹œ ì¤€ìˆ˜**: ë°ì´í„° ë¶€ë¶„ì€ ë‹¨ìˆœ ë‚˜ì—´ì´ ì•„ë‹Œ êµ¬ì¡°í™”ëœ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•˜ë˜, ë„ˆë¬´ ê¸¸ì§€ ì•Šê²Œ í•µì‹¬ë§Œ ê°„ê²°í•˜ê²Œ ì •ë¦¬í•´ì£¼ì„¸ìš”.
` : '';

                // í”„ë¡¬í”„íŠ¸ë¥¼ ì‹œìŠ¤í…œ ë©”ì‹œì§€ì™€ ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ ëª¨ë‘ì— ëª…í™•íˆ ë°˜ì˜
                const systemMessage = `ë‹¹ì‹ ì€ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ êµ¬ì„± ìš”ì†Œ(ì†ì„±)ë“¤ì„ ì¶”ì¶œí•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ì…ë ¥ëœ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ì— í•„ìš”í•œ êµ¬ì„± ìš”ì†Œë“¤ì„ ì°¾ì•„ì£¼ì„¸ìš”. ì˜ˆë¥¼ ë“¤ì–´:
- ë“±ì¥ì¸ë¬¼ (ì£¼ì¸ê³µ, ì¡°ì—°, ì•…ì—­ ë“±)
- ë°°ê²½ ì„¤ì • (ì‹œê°„, ì¥ì†Œ, ì„¸ê³„ê´€)
- ì£¼ìš” ì‚¬ê±´ (í”Œë¡¯, ê°ˆë“±, ì „ê°œ)
- ê°ì •/ë¶„ìœ„ê¸° (ë¶„ìœ„ê¸°, ê°ì • ë³€í™”)
- í…Œë§ˆ/ì£¼ì œ (ë©”ì‹œì§€, êµí›ˆ)
- ìŠ¤íƒ€ì¼/í†¤ (ë¬¸ì²´, í†¤)

${customPrompt ? `\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
âš ï¸ ì‚¬ìš©ì ìš”ì²­ì‚¬í•­ (ë°˜ë“œì‹œ ì¤€ìˆ˜) âš ï¸
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
${customPrompt}

ìœ„ ìš”ì²­ì‚¬í•­ì„ ë°˜ë“œì‹œ ë°˜ì˜í•˜ì—¬ ì‘ë‹µí•´ì£¼ì„¸ìš”. ì´ ì§€ì‹œì‚¬í•­ì€ ë‹¤ë¥¸ ëª¨ë“  ì§€ì¹¨ë³´ë‹¤ ìš°ì„ í•©ë‹ˆë‹¤.
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n` : ''}${outlineInstructions}

**ì‘ë‹µ í˜•ì‹**: ì•„ë˜ í˜•ì‹ì„ ì •í™•íˆ ë”°ë¥´ì„¸ìš”. ê° ì†ì„±ë§ˆë‹¤ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•˜ì„¸ìš”:

ì†ì„± 1: [ì†ì„±ëª…]

ë°ì´í„°: ${isOutlineRequest ? '[âš ï¸ ìœ„ ê°œìš” ì‘ì„± ëª¨ë“œ ì§€ì¹¨ì„ ë°˜ë“œì‹œ ë”°ë¥´ì„¸ìš” - êµ¬ì¡°í™”ë˜ê³  ìƒì„¸í•œ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±]' : '[êµ¬ì²´ì ì¸ ë°ì´í„° ë‚´ìš©]'}

ì´ìœ : [ì´ ì†ì„±ì„ ì¶”ì¶œí•œ ì´ìœ ]

ì†ì„± BIT: -, -

ë°ì´í„° BIT: -, -

---

ì†ì„± 2: [ì†ì„±ëª…]

ë°ì´í„°: ${isOutlineRequest ? '[âš ï¸ ìœ„ ê°œìš” ì‘ì„± ëª¨ë“œ ì§€ì¹¨ì„ ë°˜ë“œì‹œ ë”°ë¥´ì„¸ìš” - êµ¬ì¡°í™”ë˜ê³  ìƒì„¸í•œ ê°œìš” í˜•ì‹ìœ¼ë¡œ ì‘ì„±]' : '[êµ¬ì²´ì ì¸ ë°ì´í„° ë‚´ìš©]'}

ì´ìœ : [ì´ ì†ì„±ì„ ì¶”ì¶œí•œ ì´ìœ ]

ì†ì„± BIT: -, -

ë°ì´í„° BIT: -, -

---

(ê³„ì† ë°˜ë³µ...)

**ì¤‘ìš”**: 
- ìµœì†Œ 3ê°œ ì´ìƒì˜ ì†ì„±ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”.
- ì‚¬ìš©ìê°€ "ì†ì„±ì„ ë” ì¶”ê°€í•´ì£¼ì„¸ìš”" ë˜ëŠ” ìœ ì‚¬í•œ ìš”ì²­ì„ í•˜ë©´, ê¸°ì¡´ ì†ì„± ì™¸ì— ì¶”ê°€ ì†ì„±ë“¤ì„ ë” ì°¾ì•„ì„œ ì œê³µí•´ì£¼ì„¸ìš”.
- ì†ì„± BITì™€ ë°ì´í„° BITëŠ” í•­ìƒ "-, -"ë¡œ í‘œì‹œí•˜ì„¸ìš” (ì‹¤ì œ ê³„ì‚°ì€ ì‹œìŠ¤í…œì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤).
- JSON í˜•ì‹ì´ ì•„ë‹Œ ìœ„ì˜ í…ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•˜ì„¸ìš”.`;

                // í”„ë¡¬í”„íŠ¸ ì…ë ¥ì´ ìˆìœ¼ë©´ í•´ë‹¹ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©, í…ìŠ¤íŠ¸ëŠ” ê·¸ëŒ€ë¡œ í¬í•¨
                // í”„ë¡¬í”„íŠ¸ì— {text} í”Œë ˆì´ìŠ¤í™€ë”ê°€ ìˆìœ¼ë©´ í…ìŠ¤íŠ¸ë¡œ ì¹˜í™˜, ì—†ìœ¼ë©´ í”„ë¡¬í”„íŠ¸ ë’¤ì— í…ìŠ¤íŠ¸ ì¶”ê°€
                let finalPrompt;
                if (customPrompt) {
                    // ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ë¥¼ ëª…í™•íˆ í‘œì‹œ
                    if (customPrompt.includes('{text}')) {
                        // í”„ë¡¬í”„íŠ¸ì— {text} í”Œë ˆì´ìŠ¤í™€ë”ê°€ ìˆìœ¼ë©´ ì¹˜í™˜
                        finalPrompt = customPrompt.replace(/{text}/g, text);
                    } else {
                        // í”Œë ˆì´ìŠ¤í™€ë”ê°€ ì—†ìœ¼ë©´ í”„ë¡¬í”„íŠ¸ë¥¼ ë¨¼ì € ëª…ì‹œí•˜ê³  í…ìŠ¤íŠ¸ ì¶”ê°€
                        finalPrompt = `${customPrompt}\n\n[ìœ„ ìš”ì²­ì‚¬í•­ì— ë”°ë¼ ì•„ë˜ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•´ì£¼ì„¸ìš”]\n\n${text}`;
                    }
                } else {
                    // ê¸°ë³¸ í”„ë¡¬í”„íŠ¸
                    finalPrompt = `ë‹¤ìŒ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ êµ¬ì„± ìš”ì†Œ(ì†ì„±)ë“¤ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”:\n\n"${text}"`;
                }

                // í”„ë¡¬í”„íŠ¸ 1ìš© ë¡œê·¸ ì €ì¥ (ë°ì´í„° ì œì™¸)
                updatePromptLog1(systemMessage, finalPrompt);

                const url = getServerUrl('/api/gpt/chat');
                console.log('GPT API ìš”ì²­ ì‹œì‘', { url, promptLength: finalPrompt.length });
                
                const requestBody = {
                    prompt: finalPrompt,
                    systemMessage: systemMessage,
                    model: 'gpt-4o-mini',
                    temperature: 0.3,
                    maxTokens: 1500
                };
                
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('GPT API ì‘ë‹µ ìˆ˜ì‹ ', { status: res.status, statusText: res.statusText });

                if (!res.ok) {
                    console.error('GPT API ì˜¤ë¥˜', { status: res.status });
                    throw new Error(`HTTP ${res.status}`);
                }

                const data = await res.json();
                console.log('GPT API ì‘ë‹µ íŒŒì‹± ì™„ë£Œ', { ok: data.ok, responseLength: data.response?.length || 0 });
                
                if (!data.ok) {
                    console.error('GPT ë¶„ì„ ì‹¤íŒ¨', { error: data.error });
                    throw new Error(data.error || 'GPT ë¶„ì„ ì‹¤íŒ¨');
                }

                console.log('GPT ì‘ë‹µ í…ìŠ¤íŠ¸ íŒŒì‹± ì‹œì‘');

                // í…ìŠ¤íŠ¸ í˜•ì‹ ì‘ë‹µ íŒŒì‹±
                let parsed = [];
                try {
                    const responseText = data.response.trim();
                    
                    // ë¨¼ì € JSON í˜•ì‹ì¸ì§€ í™•ì¸ (í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´)
                    let jsonText = responseText;
                    if (jsonText.startsWith('```json')) {
                        jsonText = jsonText.replace(/```json\s*/, '').replace(/\s*```$/, '');
                    } else if (jsonText.startsWith('```')) {
                        jsonText = jsonText.replace(/```\s*/, '').replace(/\s*```$/, '');
                    }
                    
                    try {
                        const jsonParsed = JSON.parse(jsonText);
                        if (Array.isArray(jsonParsed)) {
                            // JSON í˜•ì‹ìœ¼ë¡œ íŒŒì‹± ì„±ê³µ
                            parsed = jsonParsed.map(item => ({
                                attribute: item.attribute?.trim() || '',
                                data: item.data?.trim() || '',
                                reasoning: item.reasoning?.trim() || ''
                            }));
                        }
                    } catch {
                        // JSONì´ ì•„ë‹ˆë©´ í…ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œ íŒŒì‹±
                        // "ì†ì„± N: ..." íŒ¨í„´ìœ¼ë¡œ ì†ì„±ë“¤ì„ ë¶„ë¦¬
                        // "---" ë˜ëŠ” ë¹ˆ ì¤„ë¡œ êµ¬ë¶„ëœ ì„¹ì…˜ì„ ì°¾ìŒ
                        const sections = responseText.split(/(?:^|\n)---+|\n\n(?=ì†ì„±\s*\d+\s*:)/m);
                        
                        for (const section of sections) {
                            const trimmedSection = section.trim();
                            if (!trimmedSection) continue;
                            
                            // ì†ì„±ëª… ì¶”ì¶œ (ì†ì„± 1: ë˜ëŠ” ì†ì„± N: í˜•ì‹)
                            const attrMatch = trimmedSection.match(/ì†ì„±\s*\d+\s*:\s*(.+?)(?:\n|$)/);
                            if (!attrMatch) continue;
                            const attribute = attrMatch[1].trim();
                            
                            // ë°ì´í„° ì¶”ì¶œ (ë°ì´í„°: ë‹¤ìŒë¶€í„° ì´ìœ : ë˜ëŠ” ì†ì„± BIT: ì „ê¹Œì§€)
                            const dataMatch = trimmedSection.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì´ìœ :|\nì´ìœ :|\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|$)/s);
                            const dataText = dataMatch ? dataMatch[1].trim() : '';
                            
                            // ì´ìœ  ì¶”ì¶œ (ì´ìœ : ë‹¤ìŒë¶€í„° ì†ì„± BIT: ë˜ëŠ” ë°ì´í„° BIT: ì „ê¹Œì§€)
                            const reasonMatch = trimmedSection.match(/ì´ìœ \s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|\n\në°ì´í„°\s*BIT:|\në°ì´í„°\s*BIT:|$)/s);
                            const reasoning = reasonMatch ? reasonMatch[1].trim() : '';
                            
                            if (attribute && dataText) {
                                parsed.push({
                                    attribute: attribute,
                                    data: dataText,
                                    reasoning: reasoning
                                });
                            }
                        }
                        
                        // ì„¹ì…˜ ë¶„ë¦¬ê°€ ì•ˆ ëœ ê²½ìš°, ì§ì ‘ íŒ¨í„´ ë§¤ì¹­ ì‹œë„
                        if (parsed.length === 0) {
                            const attributeMatches = [...responseText.matchAll(/ì†ì„±\s*\d+\s*:\s*(.+?)(?:\n|$)/g)];
                            for (const attrMatch of attributeMatches) {
                                const attribute = attrMatch[1].trim();
                                if (!attribute) continue;
                                
                                // í•´ë‹¹ ì†ì„± ë‹¤ìŒ ë¶€ë¶„ ì°¾ê¸°
                                const attrIndex = attrMatch.index + attrMatch[0].length;
                                const nextSection = responseText.substring(attrIndex);
                                
                                const dataMatch = nextSection.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì´ìœ :|\nì´ìœ :|\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|ì†ì„±\s*\d+\s*:|$)/s);
                                const dataText = dataMatch ? dataMatch[1].trim() : '';
                                
                                const reasonMatch = nextSection.match(/ì´ìœ \s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|\n\në°ì´í„°\s*BIT:|\në°ì´í„°\s*BIT:|ì†ì„±\s*\d+\s*:|$)/s);
                                const reasoning = reasonMatch ? reasonMatch[1].trim() : '';
                                
                                if (attribute && dataText) {
                                    parsed.push({
                                        attribute: attribute,
                                        data: dataText,
                                        reasoning: reasoning
                                    });
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('íŒŒì‹± ì˜¤ë¥˜:', e);
                    throw new Error('GPT ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨: ' + e.message);
                }

                console.log('íŒŒì‹± ì™„ë£Œ', { parsedCount: parsed.length });

                if (!Array.isArray(parsed) || parsed.length === 0) {
                    console.error('ì†ì„± ì¶”ì¶œ ì‹¤íŒ¨: ì¶”ì¶œëœ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                    throw new Error('GPT ì‘ë‹µì—ì„œ ì†ì„±ì„ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‘ë‹µ í˜•ì‹ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }

                console.log('ì¶”ì¶œëœ ì†ì„± ì²˜ë¦¬ ì‹œì‘', { count: parsed.length });

                // ì¶”ì¶œëœ ì†ì„± ì²˜ë¦¬
                extractedAttributesList = parsed.map(item => {
                    const attribute = item.attribute?.trim() || '';
                    let dataText = item.data?.trim() || '';
                    const reasoning = item.reasoning?.trim() || '';
                    
                    // ë§ˆí¬ë‹¤ìš´ ë¬¸ì ì œê±°
                    dataText = removeMarkdownChars(dataText);
                    
                    if (!attribute || !dataText) {
                        return null;
                    }

                    const attrBits = calculateBitValues(attribute);
                    const dataBits = calculateBitValues(dataText);
                    
                    console.log('ì†ì„± BIT ê³„ì‚°', { 
                        attribute, 
                        attrBitMax: attrBits.max, 
                        attrBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    });
                    
                    return {
                        attribute: attribute,
                        data: dataText,
                        reasoning: reasoning,
                        attributeBitMax: attrBits.max,
                        attributeBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    };
                }).filter(Boolean);

                console.log('ì†ì„± ì²˜ë¦¬ ì™„ë£Œ', { validCount: extractedAttributesList.length });

                if (extractedAttributesList.length === 0) {
                    console.error('ìœ íš¨í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                    throw new Error('ì¶”ì¶œëœ ìœ íš¨í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                }

                // ê²°ê³¼ í‘œì‹œ
                console.log('ë¶„ì„ ê²°ê³¼ í‘œì‹œ', { attributeCount: extractedAttributesList.length });
                $gptResponse.textContent = data.response;
                displayExtractedAttributes();
                $gptResultCard.style.display = 'block';
                $gptStatus.textContent = `âœ“ ë¶„ì„ ì™„ë£Œ: ${extractedAttributesList.length}ê°œ ì†ì„± ì¶”ì¶œë¨. ìë™ ì €ì¥ ì¤‘...`;
                $gptStatus.style.color = '#007bff';

                // ìë™ ì €ì¥ ì‹¤í–‰
                console.log('ìë™ ì €ì¥ ì‹œì‘');
                await saveAllAttributes();
                console.log('GPT ë¶„ì„ ì™„ë£Œ');

            } catch (e) {
                console.error('GPT ë¶„ì„ ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ë¶„ì„ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
                $gptResponse.textContent = `ì˜¤ë¥˜: ${e.message}`;
            } finally {
                $analyzeBtn1.disabled = false;
                $analyzeBtn2.disabled = false;
            }
        }

        // ì¶”ì¶œëœ ì†ì„± í‘œì‹œ
        function displayExtractedAttributes() {
            let html = '<div class="row">';
            extractedAttributesList.forEach((item, idx) => {
                const attrMax = item.attributeBitMax !== null && item.attributeBitMax !== undefined ? item.attributeBitMax.toFixed(10) : '-';
                const attrMin = item.attributeBitMin !== null && item.attributeBitMin !== undefined ? item.attributeBitMin.toFixed(10) : '-';
                const dataMax = item.dataBitMax !== null && item.dataBitMax !== undefined ? item.dataBitMax.toFixed(10) : '-';
                const dataMin = item.dataBitMin !== null && item.dataBitMin !== undefined ? item.dataBitMin.toFixed(10) : '-';
                const saveStatus = item.saveStatus || 'pending'; // pending, saving, success, duplicate, error
                const saveMessage = item.saveMessage || '';
                
                let statusHtml = '';
                if (saveStatus === 'pending') {
                    statusHtml = '<div class="small text-muted mt-2"><em>ì €ì¥ ëŒ€ê¸° ì¤‘...</em></div>';
                } else if (saveStatus === 'saving') {
                    statusHtml = '<div class="small text-info mt-2">ğŸ’¾ ì €ì¥ ì¤‘...</div>';
                } else if (saveStatus === 'success') {
                    statusHtml = `<div class="small text-success mt-2">âœ“ ${saveMessage || 'ì €ì¥ ì™„ë£Œ'}</div>`;
                } else if (saveStatus === 'duplicate') {
                    // ì¤‘ë³µì´ê±°ë‚˜ ê¸°ì¡´ ë°ì´í„°ê°€ ìˆì„ ë•Œ ìˆ˜ì • ë²„íŠ¼ í‘œì‹œ
                    statusHtml = `
                        <div class="small text-warning mt-2 mb-2">âš  ${saveMessage || 'ê¸°ì¡´ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤.'}</div>
                        <button class="btn btn-sm btn-warning" onclick="updateAttributeData(${idx}); return false;">
                            âœï¸ ìˆ˜ì •
                        </button>
                    `;
                } else if (saveStatus === 'error') {
                    statusHtml = `<div class="small text-danger mt-2">âœ— ${saveMessage || 'ì €ì¥ ì‹¤íŒ¨'}</div>`;
                }
                
                html += `
                    <div class="col-md-6 mb-3">
                        <div class="border rounded p-3 attribute-card" 
                             onclick="handleAttributeCardClick(${idx})">
                            <h6 class="text-primary">ì†ì„± ${idx + 1}: ${escapeHtml(item.attribute)}</h6>
                            <div class="mb-2">
                                <strong>ë°ì´í„°:</strong> ${escapeHtml(item.data)}
                            </div>
                            ${item.reasoning ? `<div class="small text-muted mb-2"><strong>ì´ìœ :</strong> ${escapeHtml(item.reasoning)}</div>` : ''}
                            <div class="small text-muted">
                                <strong>ì†ì„± BIT:</strong> MAX ${attrMax}, MIN ${attrMin}<br>
                                <strong>ë°ì´í„° BIT:</strong> MAX ${dataMax}, MIN ${dataMin}
                            </div>
                            ${(item.attributeBitMax === null || item.attributeBitMin === null || item.dataBitMax === null || item.dataBitMin === null) ? 
                                '<div class="text-warning small mt-1">âš  BIT ê°’ ê³„ì‚° ì‹¤íŒ¨</div>' : ''}
                            ${statusHtml}
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            $extractedAttributes.innerHTML = html;
        }
        
        // ì†ì„± ì¹´ë“œ í´ë¦­ í•¸ë“¤ëŸ¬
        window.handleAttributeCardClick = function(idx) {
            const item = extractedAttributesList[idx];
            if (!item) return;
            
            // ì¢Œì¸¡ ì†ì„± ëª©ë¡ì—ì„œ í•´ë‹¹ ì†ì„± ì°¾ê¸°
            if (item.attributeBitMax && item.attributeBitMin) {
                scrollToAttribute(item.attributeBitMax, item.attributeBitMin, item.attribute);
            }
        };
        
        // ìˆ˜ì • ë²„íŠ¼ í´ë¦­ í•¸ë“¤ëŸ¬ (ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡)
        window.updateAttributeData = updateAttributeData;

        // ì¢Œì¸¡ ì†ì„± ëª©ë¡ì—ì„œ ì†ì„± ì°¾ì•„ì„œ ìŠ¤í¬ë¡¤í•˜ê³  ê°•ì¡° í‘œì‹œ
        function scrollToAttribute(bitMax, bitMin, attributeText) {
            console.log('ì†ì„± ìŠ¤í¬ë¡¤ ì‹œì‘', { attributeText, bitMax, bitMin });
            
            // ì´ì „ í•˜ì´ë¼ì´íŠ¸ ì œê±°
            const previousHighlighted = document.querySelector('.attribute-item.highlighted');
            if (previousHighlighted) {
                previousHighlighted.classList.remove('highlighted');
            }

            // ëª¨ë“  ì†ì„± ì•„ì´í…œ ì°¾ê¸°
            const attributeItems = document.querySelectorAll('.attribute-item');
            let targetElement = null;

            // BIT ê°’ìœ¼ë¡œ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ì†ì„± ì°¾ê¸°
            attributeItems.forEach(item => {
                const bitMaxText = item.getAttribute('data-bit-max');
                const bitMinText = item.getAttribute('data-bit-min');
                
                if (bitMaxText && bitMinText) {
                    const itemBitMax = parseFloat(bitMaxText);
                    const itemBitMin = parseFloat(bitMinText);
                    
                    // BIT ê°’ì´ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸ (ì†Œìˆ˜ì  ì˜¤ì°¨ í—ˆìš©)
                    if (Math.abs(itemBitMax - bitMax) < 0.0001 && Math.abs(itemBitMin - bitMin) < 0.0001) {
                        targetElement = item;
                    }
                }
            });

            // BIT ê°’ìœ¼ë¡œ ëª» ì°¾ì•˜ìœ¼ë©´ í…ìŠ¤íŠ¸ë¡œ ì°¾ê¸°
            if (!targetElement) {
                attributeItems.forEach(item => {
                    // data-attribute-text ì†ì„±ìœ¼ë¡œ ì „ì²´ ì†ì„± í…ìŠ¤íŠ¸ í™•ì¸ (í”„ë¡¬í”„íŠ¸ 2 í˜•ì‹ ì§€ì›)
                    const dataAttributeText = item.getAttribute('data-attribute-text');
                    if (dataAttributeText && dataAttributeText.trim() === attributeText.trim()) {
                        targetElement = item;
                        return;
                    }
                    
                    // attribute-nameìœ¼ë¡œë„ í™•ì¸ (ë¶€ë¶„ ë§¤ì¹­)
                    const nameElement = item.querySelector('.attribute-name');
                    if (nameElement) {
                        const nameText = nameElement.textContent.trim();
                        // ì •í™•í•œ ì¼ì¹˜ ë˜ëŠ” ë¶€ë¶„ í¬í•¨ í™•ì¸
                        if (nameText === attributeText.trim() || attributeText.trim().includes(nameText) || nameText.includes(attributeText.trim())) {
                            targetElement = item;
                            return;
                        }
                    }
                });
            }

            if (targetElement) {
                console.log('ì†ì„± ì°¾ìŒ ë° ìŠ¤í¬ë¡¤', { attributeText });
                // í•˜ì´ë¼ì´íŠ¸ ì¶”ê°€
                targetElement.classList.add('highlighted');
                
                // ìŠ¤í¬ë¡¤í•˜ì—¬ í•´ë‹¹ ìš”ì†Œë¥¼ ë³´ì´ê²Œ í•¨
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'center'
                });

                // 3ì´ˆ í›„ í•˜ì´ë¼ì´íŠ¸ ì œê±°
                setTimeout(() => {
                    targetElement.classList.remove('highlighted');
                    console.log('ì†ì„± í•˜ì´ë¼ì´íŠ¸ ì œê±°', { attributeText });
                }, 3000);
            } else {
                console.warn('ì†ì„±ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', { attributeText, bitMax, bitMin });
                // ì†ì„± ëª©ë¡ì´ ë¹„ì–´ìˆê±°ë‚˜ ë¡œë”© ì¤‘ì¼ ë•Œë§Œ ìƒˆë¡œê³ ì¹¨
                if (attributeItems.length === 0) {
                    console.log('ì†ì„± ëª©ë¡ì´ ë¹„ì–´ìˆìŒ. ìƒˆë¡œê³ ì¹¨ í›„ ì¬ì‹œë„');
                    loadAttributes().then(() => {
                        // ì¶©ë¶„í•œ ì‹œê°„ì„ ë‘ê³  ì¬ì‹œë„ (ë Œë”ë§ ì™„ë£Œ ëŒ€ê¸°)
                        setTimeout(() => {
                            scrollToAttribute(bitMax, bitMin, attributeText);
                        }, 800);
                    });
                } else {
                    console.warn('ì†ì„± ëª©ë¡ì— í•­ëª©ì´ ìˆì§€ë§Œ ì¼ì¹˜í•˜ëŠ” ì†ì„±ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }
            }
        }


        // ì†ì„±ì— ê¸°ì¡´ ë°ì´í„°ê°€ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” í•¨ìˆ˜
        async function checkExistingData(attributeBitMax, attributeBitMin, novelTitle, currentChapter) {
            try {
                // ì†ì„±ì˜ ë°ì´í„° ì¡°íšŒ
                const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${attributeBitMax}&bitMin=${attributeBitMin}&limit=10`);
                const dataRes = await fetch(dataUrl);
                
                if (dataRes.ok) {
                    const dataData = await dataRes.json();
                    if (dataData.ok && dataData.items && dataData.items.length > 0) {
                        // ì†Œì„¤/ì±•í„° ì •ë³´ê°€ ìˆìœ¼ë©´ í•„í„°ë§
                        if (novelTitle && currentChapter) {
                            const filtered = dataData.items.filter(dataItem => {
                                return dataItem.novel && dataItem.novel.title === novelTitle &&
                                       dataItem.chapter && dataItem.chapter.number === currentChapter.number;
                            });
                            return filtered.length > 0;
                        }
                        // ì†Œì„¤/ì±•í„° ì •ë³´ê°€ ì—†ìœ¼ë©´ ë°ì´í„°ê°€ ìˆìœ¼ë©´ true
                        return true;
                    }
                }
            } catch (e) {
                console.warn('ê¸°ì¡´ ë°ì´í„° í™•ì¸ ì˜¤ë¥˜:', e);
            }
            return false;
        }

        // ë‹¨ì¼ ì†ì„± ì—…ë°ì´íŠ¸ ì €ì¥ (ìˆ˜ì • ë²„íŠ¼ í´ë¦­ ì‹œ)
        async function updateAttributeData(idx) {
            const item = extractedAttributesList[idx];
            if (!item) return;
            
            try {
                item.saveStatus = 'saving';
                item.saveMessage = 'ìˆ˜ì • ì¤‘...';
                displayExtractedAttributes();
                
                // BIT ê°’ ê²€ì¦
                if (item.attributeBitMax === null || item.attributeBitMin === null || 
                    item.dataBitMax === null || item.dataBitMin === null) {
                    item.saveStatus = 'error';
                    item.saveMessage = 'BIT ê°’ ê³„ì‚° ì‹¤íŒ¨';
                    displayExtractedAttributes();
                    return;
                }

                const novelTitle = $novelTitle.value.trim();
                const currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
                
                if (!novelTitle || !currentChapter) {
                    item.saveStatus = 'error';
                    item.saveMessage = 'ì†Œì„¤ ì œëª©ê³¼ ì±•í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.';
                    displayExtractedAttributes();
                    return;
                }

                // ì†Œì„¤ ì œëª© BIT ê³„ì‚°
                const novelTitleBits = calculateBitValues(novelTitle);
                const chapterText = `${currentChapter.number || ''} ${currentChapter.title || ''}`.trim();
                const chapterBits = calculateBitValues(chapterText);
                const chapterDisplay = `${currentChapter.number || ''}${currentChapter.title ? `: ${currentChapter.title}` : ''}`;
                const combinedAttributeText = `${novelTitle} â†’ ${chapterDisplay} â†’ ${item.attribute}`;
                const combinedAttributeBits = calculateBitValues(combinedAttributeText);
                
                // ê¸°ì¡´ ë°ì´í„° ì‚­ì œ í›„ ìƒˆë¡œ ì €ì¥ (ì†ì„±ë‹¹ 1ê°œë§Œ í—ˆìš©)
                // TODO: ê¸°ì¡´ ë°ì´í„° ì‚­ì œ APIê°€ í•„ìš”í•  ìˆ˜ ìˆìŒ, ì¼ë‹¨ ì €ì¥ ì‹œë„
                const url = getServerUrl('/api/attributes/data');
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        attributeBitMax: combinedAttributeBits.max,
                        attributeBitMin: combinedAttributeBits.min,
                        attributeText: combinedAttributeText,
                        text: item.data,
                        dataBitMax: item.dataBitMax,
                        dataBitMin: item.dataBitMin,
                        novelTitle: novelTitle,
                        novelTitleBitMax: novelTitleBits.max,
                        novelTitleBitMin: novelTitleBits.min,
                        chapter: currentChapter,
                        chapterBitMax: chapterBits.max,
                        chapterBitMin: chapterBits.min
                    })
                });

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }

                const data = await res.json();
                if (data.ok) {
                    item.saveStatus = 'success';
                    item.saveMessage = 'ìˆ˜ì • ì™„ë£Œ';
                    console.log(`ì†ì„± ìˆ˜ì • ì™„ë£Œ: ${item.attribute}`);
                } else {
                    throw new Error(data.error || 'ìˆ˜ì • ì‹¤íŒ¨');
                }
                
                displayExtractedAttributes();
                loadAttributes();
            } catch (e) {
                console.error(`ì†ì„± "${item.attribute}" ìˆ˜ì • ì˜¤ë¥˜:`, e);
                item.saveStatus = 'error';
                item.saveMessage = e.message || 'ìˆ˜ì • ì‹¤íŒ¨';
                displayExtractedAttributes();
            }
        }

        // ëª¨ë“  ì†ì„± ì €ì¥ (ìë™ ì €ì¥ - ì¤‘ë³µ/ë°ì´í„° ìˆìœ¼ë©´ ì €ì¥í•˜ì§€ ì•ŠìŒ)
        async function saveAllAttributes() {
            if (extractedAttributesList.length === 0) {
                console.warn('ì €ì¥í•  ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            console.log('ì†ì„± ì €ì¥ ì‹œì‘', { totalCount: extractedAttributesList.length });

            try {
                let successCount = 0;
                let duplicateCount = 0;
                let errorCount = 0;
                let skipCount = 0;

                // ê° ì†ì„±ë³„ë¡œ í™•ì¸ ë° ì €ì¥
                for (let idx = 0; idx < extractedAttributesList.length; idx++) {
                    const item = extractedAttributesList[idx];
                    
                    // ì´ˆê¸° ìƒíƒœë¡œ í‘œì‹œ
                    item.saveStatus = 'pending';
                    item.saveMessage = 'í™•ì¸ ì¤‘...';
                    displayExtractedAttributes();
                    
                    try {
                        // BIT ê°’ ê²€ì¦
                        if (item.attributeBitMax === null || item.attributeBitMin === null || 
                            item.dataBitMax === null || item.dataBitMin === null) {
                            item.saveStatus = 'error';
                            item.saveMessage = 'BIT ê°’ ê³„ì‚° ì‹¤íŒ¨';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }

                        // ì†Œì„¤ ì œëª©ê³¼ ì±•í„° ì •ë³´ í™•ì¸
                        const novelTitle = $novelTitle.value.trim();
                        const currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
                        
                        if (!novelTitle) {
                            console.warn('ì†Œì„¤ ì œëª©ì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                            item.saveStatus = 'error';
                            item.saveMessage = 'ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }
                        
                        if (!currentChapter) {
                            console.warn('ì±•í„°ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                            item.saveStatus = 'error';
                            item.saveMessage = 'ì±•í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }

                        // ì†Œì„¤ ì œëª© BIT ê³„ì‚°
                        const novelTitleBits = calculateBitValues(novelTitle);
                        if (novelTitleBits.max === null || novelTitleBits.min === null) {
                            console.warn('ì†Œì„¤ ì œëª© BIT ê³„ì‚° ì‹¤íŒ¨');
                            item.saveStatus = 'error';
                            item.saveMessage = 'ì†Œì„¤ ì œëª© BIT ê³„ì‚° ì‹¤íŒ¨';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }

                        // ì±•í„° BIT ê³„ì‚° (ì±•í„° ë²ˆí˜¸ + ì œëª©ì„ ì¡°í•©)
                        const chapterText = `${currentChapter.number || ''} ${currentChapter.title || ''}`.trim();
                        const chapterBits = calculateBitValues(chapterText);
                        if (chapterBits.max === null || chapterBits.min === null) {
                            console.warn('ì±•í„° BIT ê³„ì‚° ì‹¤íŒ¨');
                            item.saveStatus = 'error';
                            item.saveMessage = 'ì±•í„° BIT ê³„ì‚° ì‹¤íŒ¨';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }

                        // ì†ì„±ëª…ì„ "ì†Œì„¤ ì œëª© â†’ ì±•í„° â†’ ì†ì„±ëª…" í˜•ì‹ìœ¼ë¡œ ì¡°í•©
                        const chapterDisplay = `${currentChapter.number || ''}${currentChapter.title ? `: ${currentChapter.title}` : ''}`;
                        const combinedAttributeText = `${novelTitle} â†’ ${chapterDisplay} â†’ ${item.attribute}`;
                        
                        // ì¡°í•©ëœ ì†ì„±ëª…ìœ¼ë¡œ BIT ê°’ ì¬ê³„ì‚°
                        const combinedAttributeBits = calculateBitValues(combinedAttributeText);
                        if (combinedAttributeBits.max === null || combinedAttributeBits.min === null) {
                            console.warn('ì¡°í•©ëœ ì†ì„±ëª… BIT ê³„ì‚° ì‹¤íŒ¨');
                            item.saveStatus = 'error';
                            item.saveMessage = 'ì†ì„±ëª… BIT ê³„ì‚° ì‹¤íŒ¨';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }
                        
                        // ì €ì¥ ì „ì— ê¸°ì¡´ ë°ì´í„° í™•ì¸
                        const hasExistingData = await checkExistingData(
                            combinedAttributeBits.max,
                            combinedAttributeBits.min,
                            novelTitle,
                            currentChapter
                        );
                        
                        if (hasExistingData) {
                            // ê¸°ì¡´ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì €ì¥í•˜ì§€ ì•Šê³  ì¤‘ë³µ ìƒíƒœë¡œ í‘œì‹œ
                            duplicateCount++;
                            item.saveStatus = 'duplicate';
                            item.saveMessage = 'ê¸°ì¡´ ë°ì´í„°ê°€ ìˆìŠµë‹ˆë‹¤. ìˆ˜ì • ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”.';
                            console.warn(`ì†ì„±ì— ê¸°ì¡´ ë°ì´í„° ì¡´ì¬: ${item.attribute}`);
                            displayExtractedAttributes();
                            continue;
                        }
                        
                        console.log(`ì†ì„± ì €ì¥ ì‹œë„: ${combinedAttributeText}`, { 
                            originalAttribute: item.attribute,
                            novelTitle, 
                            novelTitleBits,
                            chapter: currentChapter,
                            chapterBits,
                            combinedAttributeBits
                        });
                        const url = getServerUrl('/api/attributes/data');
                        const res = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                attributeBitMax: combinedAttributeBits.max,
                                attributeBitMin: combinedAttributeBits.min,
                                attributeText: combinedAttributeText,
                                text: item.data,
                                dataBitMax: item.dataBitMax,
                                dataBitMin: item.dataBitMin,
                                novelTitle: novelTitle,
                                novelTitleBitMax: novelTitleBits.max,
                                novelTitleBitMin: novelTitleBits.min,
                                chapter: currentChapter,
                                chapterBitMax: chapterBits.max,
                                chapterBitMin: chapterBits.min
                            })
                        });

                        console.log(`ì†ì„± ì €ì¥ API ì‘ë‹µ: ${item.attribute}`, { status: res.status });

                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}`);
                        }

                        const data = await res.json();
                        if (data.ok) {
                            if (data.duplicate) {
                                // APIì—ì„œ ì¤‘ë³µ í™•ì¸ëœ ê²½ìš°ë„ ì €ì¥í•˜ì§€ ì•ŠìŒ
                                duplicateCount++;
                                item.saveStatus = 'duplicate';
                                item.saveMessage = 'ì¤‘ë³µëœ ë°ì´í„°ì…ë‹ˆë‹¤. ìˆ˜ì • ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”.';
                                console.warn(`ì†ì„± ì¤‘ë³µ: ${item.attribute}`);
                            } else {
                                successCount++;
                                item.saveStatus = 'success';
                                item.saveMessage = 'ì €ì¥ ì™„ë£Œ';
                                console.log(`ì†ì„± ì €ì¥ ì™„ë£Œ: ${item.attribute}`);
                            }
                        } else {
                            throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
                        }
                    } catch (e) {
                        console.error(`ì†ì„± "${item.attribute}" ì €ì¥ ì˜¤ë¥˜:`, e);
                        errorCount++;
                        item.saveStatus = 'error';
                        item.saveMessage = e.message || 'ì €ì¥ ì‹¤íŒ¨';
                    }
                    
                    // ê° í•­ëª© ì €ì¥ í›„ ì¦‰ì‹œ í™”ë©´ ì—…ë°ì´íŠ¸
                    displayExtractedAttributes();
                }

                // ì „ì²´ ì €ì¥ ì™„ë£Œ ìƒíƒœ ì—…ë°ì´íŠ¸
                console.log('ì†ì„± ì €ì¥ ì™„ë£Œ', { success: successCount, duplicate: duplicateCount, error: errorCount });
                $gptStatus.textContent = `âœ“ ì €ì¥ ì™„ë£Œ: ì„±ê³µ ${successCount}ê°œ, ì¤‘ë³µ ${duplicateCount}ê°œ, ì‹¤íŒ¨ ${errorCount}ê°œ`;
                $gptStatus.style.color = '#28a745';
                
                // ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                console.log('ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ì˜ˆì•½');
                setTimeout(() => {
                    loadAttributes();
                }, 500);
            } catch (e) {
                console.error('ì €ì¥ ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
            }
        }

        // GPT ë¶„ì„ ë²„íŠ¼ ì´ë²¤íŠ¸
        $analyzeBtn1.addEventListener('click', () => {
            const prompt = $gptPrompt1.value.trim();
            analyzeWithGPT(prompt);
        });
        
        $analyzeBtn2.addEventListener('click', () => {
            analyzeWithGPT2();
        });

        // í”„ë¡¬í”„íŠ¸ 1ìš© ë¡œê·¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updatePromptLog1(systemMessage, userPrompt) {
            if (!$gptPromptLog) return;
            
            // ë°ì´í„° í•„ë“œ ì œì™¸ ì²˜ë¦¬
            let cleanedPrompt = userPrompt;
            
            // [ë¶„ì„í•  í…ìŠ¤íŠ¸] ë˜ëŠ” í…ìŠ¤íŠ¸ ë°ì´í„° ë¶€ë¶„ì„ ì œì™¸
            cleanedPrompt = cleanedPrompt.replace(/\[ë¶„ì„í•  í…ìŠ¤íŠ¸\][\s\S]*?(?=\n\n|\n===|$)/g, '[ë¶„ì„í•  í…ìŠ¤íŠ¸]\n(ë°ì´í„° ì œì™¸)');
            cleanedPrompt = cleanedPrompt.replace(/\[í…ìŠ¤íŠ¸\][\s\S]*?(?=\n\n|\n===|$)/g, '[í…ìŠ¤íŠ¸]\n(ë°ì´í„° ì œì™¸)');
            
            // í”„ë¡¬í”„íŠ¸ 1ìš© ë¡œê·¸ í˜•ì‹
            const promptLogText = `=== í”„ë¡¬í”„íŠ¸ 1 ===\n\n=== ì‹œìŠ¤í…œ ë©”ì‹œì§€ ===\n${systemMessage}\n\n=== ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ ===\n${cleanedPrompt}`;
            
            $gptPromptLog.value = promptLogText;
            console.log('í”„ë¡¬í”„íŠ¸ 1 ë¡œê·¸ ì—…ë°ì´íŠ¸ë¨');
        }

        // í”„ë¡¬í”„íŠ¸ 2ìš© ë¡œê·¸ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updatePromptLog2(systemMessage, userPrompt) {
            if (!$gptPromptLog) return;
            
            // ë°ì´í„° í•„ë“œ ì œì™¸ ì²˜ë¦¬
            let cleanedPrompt = userPrompt;
            
            // [ì°¸ê³  í…ìŠ¤íŠ¸] ë¶€ë¶„ì„ ì œì™¸í•˜ê³  "(ë°ì´í„° ì œì™¸)"ë¡œ êµì²´
            cleanedPrompt = cleanedPrompt.replace(/\[ì°¸ê³  í…ìŠ¤íŠ¸\][\s\S]*?(?=\n\nìœ„ ì •ë³´|\nìœ„ ì •ë³´|$)/g, '[ì°¸ê³  í…ìŠ¤íŠ¸]\n(ë°ì´í„° ì œì™¸)');
            
            // ì‹œìŠ¤í…œ ë©”ì‹œì§€ê°€ ìˆìœ¼ë©´ í¬í•¨, ì—†ìœ¼ë©´ ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸ë§Œ í‘œì‹œ
            const promptLogText = systemMessage && systemMessage.trim() 
                ? `${systemMessage}

${cleanedPrompt}`
                : cleanedPrompt;
            
            $gptPromptLog.value = promptLogText;
            console.log('í”„ë¡¬í”„íŠ¸ 2 ë¡œê·¸ ì—…ë°ì´íŠ¸ë¨');
        }

        // ì†ì„± ì…ë ¥ë€ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateSelectedAttributeInput(attribute) {
            if (!$selectedAttributeInput) {
                console.warn('ì†ì„± ì…ë ¥ë€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            $selectedAttributeInput.value = attribute;
            console.log('ì†ì„± ì…ë ¥ë€ì— ìë™ ì…ë ¥:', attribute);
        }

        // ì†ì„± ì…ë ¥ë€ ê°’ ê°€ì ¸ì˜¤ê¸° í•¨ìˆ˜
        function getSelectedAttributeInput() {
            if (!$selectedAttributeInput) {
                console.warn('ì†ì„± ì…ë ¥ë€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return '';
            }
            
            return $selectedAttributeInput.value.trim();
        }

        // ì†ì„± ì…ë ¥ë€ ì´ˆê¸°í™” í•¨ìˆ˜
        function clearSelectedAttributeInput() {
            if (!$selectedAttributeInput) {
                console.warn('ì†ì„± ì…ë ¥ë€ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            
            $selectedAttributeInput.value = '';
            console.log('ì†ì„± ì…ë ¥ë€ ì´ˆê¸°í™”ë¨');
        }

        // GPT ë¶„ì„ í•¨ìˆ˜ 2: ì†ì„± ê²°ì • í›„ í”„ë¡¬í”„íŠ¸ 2 ì ìš©
        async function analyzeWithGPT2() {
            const text = $gptInput.value.trim();
            if (!text) {
                console.warn('GPT ë¶„ì„: ë¶„ì„í•  í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
                $gptStatus.textContent = 'âœ— ë¶„ì„í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $gptStatus.style.color = '#dc3545';
                return;
            }

            const prompt2 = $gptPrompt2.value.trim();
            if (!prompt2) {
                console.warn('GPT ë¶„ì„ 2: í”„ë¡¬í”„íŠ¸ ì…ë ¥ 2ê°€ ì—†ìŠµë‹ˆë‹¤.');
                $gptStatus.textContent = 'âœ— í”„ë¡¬í”„íŠ¸ ì…ë ¥ 2ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $gptStatus.style.color = '#dc3545';
                return;
            }

            console.log('GPT ë¶„ì„ 2 ì‹œì‘', { prompt2, textLength: text.length });

            try {
                // ë‘ ë²„íŠ¼ ëª¨ë‘ ë¹„í™œì„±í™”
                $analyzeBtn1.disabled = true;
                $analyzeBtn2.disabled = true;
                $gptStatus.textContent = 'GPT AI ë¶„ì„ ì¤‘... (ì†ì„± ê²°ì • ì¤‘)';
                $gptStatus.style.color = '#007bff';
                $gptResponse.textContent = 'ë¶„ì„ ì¤‘...';

                // ì†Œì„¤ ì œëª©ê³¼ ì±•í„° ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                const novelTitle = $novelTitle.value.trim();
                const currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
                
                if (!novelTitle) {
                    console.warn('ì†Œì„¤ ì œëª©ì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                    $gptStatus.textContent = 'âœ— ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.';
                    $gptStatus.style.color = '#dc3545';
                    $analyzeBtn1.disabled = false;
                    $analyzeBtn2.disabled = false;
                    return;
                }
                
                if (!currentChapter) {
                    console.warn('ì±•í„°ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                    $gptStatus.textContent = 'âœ— ì±•í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.';
                    $gptStatus.style.color = '#dc3545';
                    $analyzeBtn1.disabled = false;
                    $analyzeBtn2.disabled = false;
                    return;
                }
                
                // ì €ì¥ëœ ì†ì„± ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                console.log('ì €ì¥ëœ ì†ì„± ëª©ë¡ ì¡°íšŒ ì‹œì‘', { novelTitle, currentChapter });
                const allAttrUrl = getServerUrl('/api/attributes/all');
                const allAttrRes = await fetch(allAttrUrl);
                let savedAttributes = [];
                
                if (allAttrRes.ok) {
                    const allAttrData = await allAttrRes.json();
                    if (allAttrData.ok && allAttrData.attributes) {
                        // ì •í™•í•œ ì±•í„° ë§¤ì¹­ì„ ìœ„í•œ ë¬¸ìì—´ ìƒì„± (ì €ì¥ ì‹œ í˜•ì‹ê³¼ ë™ì¼í•˜ê²Œ)
                        const chapterNumber = (currentChapter.number || '').trim();
                        const chapterTitle = (currentChapter.title || '').trim();
                        const chapterDisplay = `${chapterNumber}${chapterTitle ? `: ${chapterTitle}` : ''}`;
                        const expectedPrefix = `${novelTitle} â†’ ${chapterDisplay} â†’ `;
                        
                        console.log('ì±•í„° í•„í„°ë§ ì¡°ê±´:', { 
                            expectedPrefix, 
                            chapterNumber, 
                            chapterTitle,
                            chapterDisplay,
                            totalAttributes: allAttrData.attributes.length 
                        });
                        
                        // ë””ë²„ê¹…: ì²« ëª‡ ê°œ ì†ì„±ì˜ í˜•ì‹ í™•ì¸
                        const sampleAttrs = allAttrData.attributes.slice(0, 5);
                        console.log('ìƒ˜í”Œ ì†ì„± í˜•ì‹:', sampleAttrs.map(attr => attr.text));
                        
                        savedAttributes = allAttrData.attributes
                            .filter(attr => {
                                const attrText = (attr.text || '').trim();
                                
                                // ì •í™•íˆ 100% ì¼ì¹˜í•˜ëŠ” ì†ì„±ë§Œ í•„í„°ë§
                                // ì €ì¥ í˜•ì‹: "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 2: ì œ1ì¥ â†’ ë“±ì¥ì¸ë¬¼"
                                // expectedPrefix: "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 2: ì œ1ì¥ â†’ "
                                
                                // 1ë‹¨ê³„: ì •í™•í•œ prefix ë§¤ì¹­
                                const startsWithPrefix = attrText.startsWith(expectedPrefix);
                                
                                if (!startsWithPrefix) {
                                    return false;
                                }
                                
                                // 2ë‹¨ê³„: ì¶”ê°€ ê²€ì¦ - ì±•í„° ë¶€ë¶„ì´ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
                                const attrParts = attrText.split(' â†’ ');
                                if (attrParts.length < 3) {
                                    // í˜•ì‹ì´ ë§ì§€ ì•Šìœ¼ë©´ ì œì™¸
                                    return false;
                                }
                                
                                const attrNovelTitle = attrParts[0].trim();
                                const attrChapterPart = attrParts[1].trim(); // "ì±•í„° 2: ì œ1ì¥"
                                
                                // ì†Œì„¤ ì œëª©ê³¼ ì±•í„°ê°€ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
                                const novelMatches = attrNovelTitle === novelTitle.trim();
                                const chapterMatches = attrChapterPart === chapterDisplay;
                                
                                if (novelMatches && chapterMatches) {
                                    console.log('100% ì¼ì¹˜í•˜ëŠ” ì†ì„± ë°œê²¬:', { 
                                        attrText, 
                                        expectedPrefix,
                                        attrNovelTitle,
                                        attrChapterPart,
                                        expectedNovel: novelTitle.trim(),
                                        expectedChapter: chapterDisplay
                                    });
                                    return true;
                                }
                                
                                // ì¼ì¹˜í•˜ì§€ ì•Šìœ¼ë©´ ë¡œê·¸ ì¶œë ¥
                                console.log('ì†ì„± ë¶ˆì¼ì¹˜:', { 
                                    attrText, 
                                    attrNovelTitle, 
                                    attrChapterPart,
                                    expectedNovel: novelTitle.trim(),
                                    expectedChapter: chapterDisplay,
                                    novelMatches,
                                    chapterMatches
                                });
                                
                                return false;
                            })
                            .map(attr => {
                                // ì†ì„±ëª…ë§Œ ì¶”ì¶œ (ì˜ˆ: "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 1: ê°œìš” â†’ ë“±ì¥ì¸ë¬¼" â†’ "ë“±ì¥ì¸ë¬¼")
                                const parts = attr.text.split(' â†’ ');
                                return parts.length >= 3 ? parts[parts.length - 1] : attr.text;
                            });
                        console.log('ì €ì¥ëœ ì†ì„± ëª©ë¡ í•„í„°ë§ ì™„ë£Œ', { 
                            count: savedAttributes.length,
                            filteredAttributes: savedAttributes 
                        });
                    }
                }

                // ì²« ë²ˆì§¸ GPT í˜¸ì¶œ: ì†ì„± ê²°ì • (ì €ì¥ëœ ì†ì„± ëª©ë¡ ê¸°ë°˜)
                console.log('1ë‹¨ê³„: ì†ì„± ê²°ì • ì‹œì‘ (ì €ì¥ëœ ì†ì„± ëª©ë¡ ê¸°ë°˜)');
                const chapterDisplay = `${currentChapter.number}${currentChapter.title ? `: ${currentChapter.title}` : ''}`;
                const attributeSystemMessage = `ë‹¹ì‹ ì€ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì–´ë–¤ ì†ì„±(ì†Œì„¤ êµ¬ì„± ìš”ì†Œ)ì„ ë¶„ì„í• ì§€ ê²°ì •í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ì‚¬ìš©ìì˜ ìš”ì²­: "${prompt2}"

í˜„ì¬ ì†Œì„¤: "${novelTitle}"
í˜„ì¬ ì±•í„°: "${chapterDisplay}"

ì €ì¥ëœ ì†ì„± ëª©ë¡:
${savedAttributes.length > 0 ? savedAttributes.map((attr, idx) => `- ${attr}`).join('\n') : '- ë“±ì¥ì¸ë¬¼\n- ë°°ê²½ ì„¤ì •\n- ì£¼ìš” ì‚¬ê±´\n- ê°ì •/ë¶„ìœ„ê¸°\n- í…Œë§ˆ/ì£¼ì œ\n- ìŠ¤íƒ€ì¼/í†¤'}

**ì¤‘ìš”**: 
- ì €ì¥ëœ ì†ì„± ëª©ë¡ ì¤‘ì—ì„œ ì‚¬ìš©ìì˜ ìš”ì²­ "${prompt2}"ì— ê°€ì¥ ì í•©í•œ ì†ì„± ì´ë¦„ í•˜ë‚˜ë¥¼ ì •í™•íˆ ì„ íƒí•˜ì„¸ìš”.
- ì €ì¥ëœ ì†ì„± ëª©ë¡ì— ì—†ëŠ” ê²½ìš° ê¸°ë³¸ ì†ì„± ì¤‘ì—ì„œ ì„ íƒí•˜ì„¸ìš”.
- ë‹¤ë¥¸ ì„¤ëª… ì—†ì´ ì†ì„± ì´ë¦„ë§Œ ì •í™•íˆ ë°˜í™˜í•˜ì„¸ìš”.
- ì˜ˆ: ì‚¬ìš©ìê°€ "ë“±ì¥ì¸ë¬¼ì„" ë˜ëŠ” "ë“±ì¥ì¸ë¬¼ì— ëŒ€í•´" ìš”ì²­í•˜ë©´ â†’ "ë“±ì¥ì¸ë¬¼"
- ì˜ˆ: ì‚¬ìš©ìê°€ "ë°°ê²½" ë˜ëŠ” "ì„¤ì •"ì„ ìš”ì²­í•˜ë©´ â†’ "ë°°ê²½ ì„¤ì •"
- ì˜ˆ: ì‚¬ìš©ìê°€ "ê°œìš”ë¥¼ ì¨ì¤˜"ë¼ê³  í–ˆì§€ë§Œ ì†ì„±ì„ ëª…ì‹œí•˜ì§€ ì•Šì•˜ë‹¤ë©´, í…ìŠ¤íŠ¸ë¥¼ ë³´ê³  ê°€ì¥ ì í•©í•œ ì†ì„±ì„ ì„ íƒí•˜ì„¸ìš”.`;

                const attributePrompt = `ë‹¤ìŒ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬, ì‚¬ìš©ì ìš”ì²­ "${prompt2}"ì— í•´ë‹¹í•˜ëŠ” ì†ì„± í•˜ë‚˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.

ì €ì¥ëœ ì†ì„± ëª©ë¡:
${savedAttributes.length > 0 ? savedAttributes.map((attr, idx) => `- ${attr}`).join('\n') : '- ë“±ì¥ì¸ë¬¼\n- ë°°ê²½ ì„¤ì •\n- ì£¼ìš” ì‚¬ê±´\n- ê°ì •/ë¶„ìœ„ê¸°\n- í…Œë§ˆ/ì£¼ì œ\n- ìŠ¤íƒ€ì¼/í†¤'}

[í…ìŠ¤íŠ¸]
${text}

ìœ„ ìš”ì²­ê³¼ ì €ì¥ëœ ì†ì„± ëª©ë¡ì„ ê³ ë ¤í•˜ì—¬ ê°€ì¥ ì í•©í•œ ì†ì„± ì´ë¦„ í•˜ë‚˜ë§Œ ì •í™•íˆ ë°˜í™˜í•˜ì„¸ìš”.`;

                // í”„ë¡¬í”„íŠ¸ ë¡œê·¸ ì´ˆê¸°í™” (í”„ë¡¬í”„íŠ¸ 2 ì‹œì‘ ì „)
                if ($gptPromptLog) {
                    $gptPromptLog.value = '';
                }

                const attributeUrl = getServerUrl('/api/gpt/chat');
                const attributeRes = await fetch(attributeUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: attributePrompt,
                        systemMessage: attributeSystemMessage,
                        model: 'gpt-4o-mini',
                        temperature: 0.3,
                        maxTokens: 100
                    })
                });

                if (!attributeRes.ok) {
                    throw new Error(`HTTP ${attributeRes.status}`);
                }

                const attributeData = await attributeRes.json();
                if (!attributeData.ok) {
                    throw new Error(attributeData.error || 'ì†ì„± ê²°ì • ì‹¤íŒ¨');
                }

                // ì†ì„± ì´ë¦„ ì¶”ì¶œ
                let selectedAttribute = attributeData.response.trim();
                // ì†ì„± ì´ë¦„ë§Œ ì¶”ì¶œ (ë¶ˆí•„ìš”í•œ ì„¤ëª… ì œê±°)
                const lowerResponse = selectedAttribute.toLowerCase();
                
                if (lowerResponse.includes('ë“±ì¥ì¸ë¬¼') || lowerResponse.includes('ì¸ë¬¼')) {
                    selectedAttribute = 'ë“±ì¥ì¸ë¬¼';
                } else if (lowerResponse.includes('ë°°ê²½') && (lowerResponse.includes('ì„¤ì •') || lowerResponse.includes('ì¥ì†Œ') || lowerResponse.includes('ì„¸ê³„'))) {
                    selectedAttribute = 'ë°°ê²½ ì„¤ì •';
                } else if ((lowerResponse.includes('ì£¼ìš”') && lowerResponse.includes('ì‚¬ê±´')) || lowerResponse.includes('ì‚¬ê±´') || lowerResponse.includes('í”Œë¡¯')) {
                    selectedAttribute = 'ì£¼ìš” ì‚¬ê±´';
                } else if ((lowerResponse.includes('ê°ì •') || lowerResponse.includes('ë¶„ìœ„ê¸°')) && !lowerResponse.includes('í…Œë§ˆ')) {
                    selectedAttribute = 'ê°ì •/ë¶„ìœ„ê¸°';
                } else if (lowerResponse.includes('í…Œë§ˆ') || lowerResponse.includes('ì£¼ì œ') || lowerResponse.includes('ë©”ì‹œì§€')) {
                    selectedAttribute = 'í…Œë§ˆ/ì£¼ì œ';
                } else if (lowerResponse.includes('ìŠ¤íƒ€ì¼') || lowerResponse.includes('í†¤') || lowerResponse.includes('ë¬¸ì²´')) {
                    selectedAttribute = 'ìŠ¤íƒ€ì¼/í†¤';
                } else {
                    // ê¸°ë³¸ê°’: í”„ë¡¬í”„íŠ¸ 2ì˜ ê°’ì„ ì†ì„±ìœ¼ë¡œ ì‚¬ìš©
                    console.warn('ì†ì„±ì„ ìë™ìœ¼ë¡œ ê²°ì •í•  ìˆ˜ ì—†ì–´ í”„ë¡¬í”„íŠ¸ 2 ê°’ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.', { response: selectedAttribute, prompt2 });
                    selectedAttribute = prompt2;
                }

                console.log('ì„ íƒëœ ì†ì„±', { selectedAttribute, originalResponse: attributeData.response });

                // ì„ íƒëœ ì†ì„±ì„ ì…ë ¥ë€ì— ìë™ ì…ë ¥ (ì†Œì„¤ ì œëª© â†’ ì±•í„° í˜•ì‹)
                const attributeDisplayText = `${novelTitle} â†’ ${chapterDisplay}`;
                updateSelectedAttributeInput(attributeDisplayText);

                // ë‘ ë²ˆì§¸ GPT í˜¸ì¶œ: ì†Œì„¤ ì‘ê°€ê°€ ë˜ì–´ì„œ í”„ë¡¬í”„íŠ¸ ìš”êµ¬ëŒ€ë¡œ ì‘ì„±
                console.log('2ë‹¨ê³„: ì†Œì„¤ ì‘ê°€ ì—­í• ë¡œ ì‘ì„± ì‹œì‘', { attribute: selectedAttribute });
                
                // ì†ì„± ì…ë ¥ë€ì—ì„œ ê°’ ê°€ì ¸ì˜¤ê¸° (í”„ë¡¬í”„íŠ¸ì™€ ì €ì¥ ì‹œ ëª¨ë‘ ì‚¬ìš©)
                const attributeFromInput = getSelectedAttributeInput();
                const displayAttribute = attributeFromInput && attributeFromInput.trim() ? attributeFromInput.trim() : selectedAttribute;
                $gptStatus.textContent = `GPT AI ì‘ê°€ ì‘ë™ ì¤‘... (${displayAttribute} ì‘ì„± ì¤‘)`;
                
                // ì €ì¥ëœ ì†ì„± ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì°¸ê³ ìš©)
                const combinedAttributeText = `${novelTitle} â†’ ${chapterDisplay} â†’ ${selectedAttribute}`;
                const savedAttributeInfo = savedAttributes.length > 0 
                    ? `\n\nì €ì¥ëœ ì†ì„± ì°¸ê³ :\n${savedAttributes.map(attr => `- ${attr}`).join('\n')}`
                    : '';
                
                const analysisPrompt = `ì†Œì„¤ ì‘ê°€ë¡œì„œ "${attributeFromInput}" ì†ì„±ì— ëŒ€í•œ ë‚´ìš©ì„ ì‘ì„±í•´ì£¼ì„¸ìš”.

í˜„ì¬ ì†Œì„¤: "${novelTitle}"
í˜„ì¬ ì±•í„°: "${chapterDisplay}"
ì‚¬ìš©ì ìš”ì²­: "${prompt2}"

[ì°¸ê³  í…ìŠ¤íŠ¸]
${text}
${savedAttributeInfo}`;

                // í”„ë¡¬í”„íŠ¸ 2ìš© í”„ë¡¬í”„íŠ¸ ë¡œê·¸ ì €ì¥ (ë°ì´í„° ì œì™¸, ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì—†ìŒ)
                updatePromptLog2('', analysisPrompt);

                const analysisUrl = getServerUrl('/api/gpt/chat');
                const analysisRes = await fetch(analysisUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: analysisPrompt,
                        systemMessage: '',
                        model: 'gpt-4o-mini',
                        temperature: 0.3,
                        maxTokens: 1500
                    })
                });

                if (!analysisRes.ok) {
                    throw new Error(`HTTP ${analysisRes.status}`);
                }

                const analysisData = await analysisRes.json();
                if (!analysisData.ok) {
                    throw new Error(analysisData.error || 'ì†ì„± ë¶„ì„ ì‹¤íŒ¨');
                }

                console.log('ì†ì„± ë¶„ì„ ì™„ë£Œ');

                // ì‘ë‹µ íŒŒì‹±
                let parsed = [];
                try {
                    const responseText = analysisData.response.trim();
                    
                    // ì†ì„± ì¶”ì¶œ
                    const attrMatch = responseText.match(/ì†ì„±\s*:\s*(.+?)(?:\n|$)/);
                    const attribute = attrMatch ? attrMatch[1].trim() : selectedAttribute;
                    
                    // ë°ì´í„° ì¶”ì¶œ
                    const dataMatch = responseText.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|$)/s);
                    const dataText = dataMatch ? dataMatch[1].trim() : responseText;
                    
                    if (attribute && dataText) {
                        parsed.push({
                            attribute: attribute,
                            data: dataText,
                            reasoning: ''
                        });
                    }
                } catch (e) {
                    console.error('íŒŒì‹± ì˜¤ë¥˜:', e);
                    // íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì „ì²´ ì‘ë‹µì„ ë°ì´í„°ë¡œ ì‚¬ìš©
                    parsed.push({
                        attribute: selectedAttribute,
                        data: analysisData.response,
                        reasoning: ''
                    });
                }

                if (parsed.length === 0) {
                    throw new Error('ë¶„ì„ ê²°ê³¼ë¥¼ íŒŒì‹±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }

                // ì¶”ì¶œëœ ì†ì„± ì²˜ë¦¬ (attributeFromInputì€ ìœ„ì—ì„œ ì´ë¯¸ ì„ ì–¸ë¨)
                extractedAttributesList = parsed.map(item => {
                    // í”„ë¡¬í”„íŠ¸ 2ì¼ ë•ŒëŠ” ì†ì„± ì…ë ¥ë€ì˜ ê°’ì„ ì‚¬ìš© (ì†Œì„¤ ì œëª© â†’ ì±•í„° í˜•ì‹)
                    // ì†ì„± ì…ë ¥ë€ì— ê°’ì´ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì‚¬ìš©, ì—†ìœ¼ë©´ íŒŒì‹±ëœ ì†ì„±ëª… ì‚¬ìš©
                    const attribute = (attributeFromInput && attributeFromInput.trim()) ? attributeFromInput.trim() : (item.attribute?.trim() || '');
                    let dataText = item.data?.trim() || '';
                    
                    // ë§ˆí¬ë‹¤ìš´ ë¬¸ì ì œê±°
                    dataText = removeMarkdownChars(dataText);
                    
                    if (!attribute || !dataText) {
                        return null;
                    }

                    const attrBits = calculateBitValues(attribute);
                    const dataBits = calculateBitValues(dataText);
                    
                    console.log('ì†ì„± BIT ê³„ì‚°', { 
                        attribute, 
                        attrBitMax: attrBits.max, 
                        attrBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    });
                    
                    return {
                        attribute: attribute,
                        data: dataText,
                        reasoning: item.reasoning?.trim() || '',
                        attributeBitMax: attrBits.max,
                        attributeBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    };
                }).filter(Boolean);

                if (extractedAttributesList.length === 0) {
                    throw new Error('ì¶”ì¶œëœ ìœ íš¨í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                }

                // ê²°ê³¼ í‘œì‹œ
                console.log('ë¶„ì„ ê²°ê³¼ í‘œì‹œ', { attributeCount: extractedAttributesList.length });
                $gptResponse.textContent = analysisData.response;
                displayExtractedAttributes();
                $gptResultCard.style.display = 'block';
                $gptStatus.textContent = `âœ“ ë¶„ì„ ì™„ë£Œ: ${extractedAttributesList.length}ê°œ ì†ì„± ì¶”ì¶œë¨. ìë™ ì €ì¥ ì¤‘...`;
                $gptStatus.style.color = '#007bff';

                // ìë™ ì €ì¥ ì‹¤í–‰
                console.log('ìë™ ì €ì¥ ì‹œì‘');
                await saveAllAttributes();
                console.log('GPT ë¶„ì„ 2 ì™„ë£Œ');

            } catch (e) {
                console.error('GPT ë¶„ì„ 2 ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ë¶„ì„ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
                $gptResponse.textContent = `ì˜¤ë¥˜: ${e.message}`;
            } finally {
                $analyzeBtn1.disabled = false;
                $analyzeBtn2.disabled = false;
            }
        }


        // ë°ì´í„° ì…ë ¥ ì‹œ BIT ê³„ì‚°
        $newDataInput.addEventListener('input', (e) => {
            const text = e.target.value.trim();
            if (text) {
                const { max, min } = calculateBitValues(text);
                $newDataMax.textContent = max !== null ? max.toFixed(10) : '-';
                $newDataMin.textContent = min !== null ? min.toFixed(10) : '-';
            } else {
                $newDataMax.textContent = '-';
                $newDataMin.textContent = '-';
            }
        });

        // ì†ì„± ëª©ë¡ ë¡œë“œ
        async function loadAttributes() {
            console.log('ì†ì„± ëª©ë¡ ë¡œë“œ ì‹œì‘');
            try {
                $attributesList.innerHTML = '<div class="text-center text-muted">ë¡œë”© ì¤‘...</div>';
                
                // ëª¨ë“  ì†ì„± ëª©ë¡ ì¡°íšŒ
                const url = getServerUrl('/api/attributes/all');
                console.log('ì†ì„± ëª©ë¡ API ìš”ì²­', { url });
                const res = await fetch(url);

                console.log('ì†ì„± ëª©ë¡ API ì‘ë‹µ', { status: res.status });

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }

                const data = await res.json();
                console.log('ì†ì„± ëª©ë¡ ë°ì´í„° ìˆ˜ì‹ ', { ok: data.ok, attributeCount: data.attributes?.length || 0 });
                
                if (!data.ok || !data.attributes || data.attributes.length === 0) {
                    $attributesList.innerHTML = '<div class="text-center text-muted">ì €ì¥ëœ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                    return;
                }

                // í•„í„° ì…ë ¥ë€ì—ì„œ ì†Œì„¤ ì œëª©ê³¼ ì±•í„° ì •ë³´ íŒŒì‹±
                let currentNovelTitle = $novelTitle.value.trim();
                let currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
                
                if ($attributeFilterInput && $attributeFilterInput.value.trim()) {
                    const filterText = $attributeFilterInput.value.trim();
                    console.log('í•„í„° ì…ë ¥ë€ ê°’:', filterText);
                    
                    // "â†’" êµ¬ë¶„ìë¡œ ì†Œì„¤ ì œëª©ê³¼ ì±•í„° íŒŒì‹±
                    // í˜•ì‹: "ì†Œì„¤ ì œëª© â†’ ì±•í„° ë²ˆí˜¸: ì±•í„° ì œëª©" ë˜ëŠ” "ì†Œì„¤ ì œëª© â†’ ì±•í„° ë²ˆí˜¸"
                    const arrowMatch = filterText.match(/^(.+?)\s*â†’\s*(.+)$/);
                    if (arrowMatch) {
                        currentNovelTitle = arrowMatch[1].trim();
                        const chapterPart = arrowMatch[2].trim();
                        
                        // ì±•í„° ë¶€ë¶„ íŒŒì‹±: "ì±•í„° 1: ê°œìš”" ë˜ëŠ” "ì±•í„° 1"
                        const chapterMatch = chapterPart.match(/^(.+?)(?::\s*(.+))?$/);
                        if (chapterMatch) {
                            currentChapter = {
                                number: chapterMatch[1].trim(),
                                title: chapterMatch[2] ? chapterMatch[2].trim() : '',
                                description: ''
                            };
                        } else {
                            currentChapter = {
                                number: chapterPart,
                                title: '',
                                description: ''
                            };
                        }
                        console.log('í•„í„° íŒŒì‹± ê²°ê³¼:', { currentNovelTitle, currentChapter });
                    } else {
                        // "â†’" êµ¬ë¶„ìê°€ ì—†ìœ¼ë©´ ì „ì²´ë¥¼ ì†Œì„¤ ì œëª©ìœ¼ë¡œ ì²˜ë¦¬
                        currentNovelTitle = filterText;
                        currentChapter = null;
                        console.log('í•„í„° íŒŒì‹± ê²°ê³¼ (ì†Œì„¤ ì œëª©ë§Œ):', { currentNovelTitle });
                    }
                }
                
                // ê° ì†ì„±ì˜ ë°ì´í„° ì¡°íšŒ
                const attributePromises = data.attributes.map(async (attr) => {
                    try {
                        const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${attr.bitMax}&bitMin=${attr.bitMin}&limit=100`);
                        const dataRes = await fetch(dataUrl);
                        if (dataRes.ok) {
                            const dataData = await dataRes.json();
                            if (dataData.ok && dataData.items) {
                                // ì†ì„± ìì²´ë¥¼ ë°ì´í„°ë¡œ ì €ì¥í•œ ê²½ìš°ëŠ” ì œì™¸
                                let dataList = dataData.items
                                    .filter(item => item.data && item.data.text && item.data.text !== attr.text);
                                
                                console.log(`ì†ì„± "${attr.text}" ë°ì´í„° í•„í„°ë§ ì „:`, { count: dataList.length });
                                
                                // ì†Œì„¤ ì œëª©ê³¼ ì±•í„°ë¡œ ì—„ê²©í•˜ê²Œ í•„í„°ë§ (ì¼ì¹˜í•˜ëŠ” ë°ì´í„°ë§Œ í‘œì‹œ)
                                if (currentNovelTitle && currentChapter) {
                                    // ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ë°ì´í„°ë§Œ í‘œì‹œ
                                    dataList = dataList.filter(item => {
                                        const itemNovel = item.novel?.title;
                                        const itemChapter = item.chapter?.number;
                                        return itemNovel === currentNovelTitle && 
                                               itemChapter === currentChapter.number;
                                    });
                                    console.log(`í•„í„°ë§ í›„ (ì†Œì„¤+ì±•í„°):`, { 
                                        currentNovelTitle, 
                                        currentChapter: currentChapter.number,
                                        filteredCount: dataList.length 
                                    });
                                } else if (currentNovelTitle) {
                                    // ì†Œì„¤ ì œëª©ë§Œ ì¼ì¹˜í•˜ëŠ” ë°ì´í„° í‘œì‹œ
                                    dataList = dataList.filter(item => {
                                        const itemNovel = item.novel?.title;
                                        return itemNovel === currentNovelTitle;
                                    });
                                    console.log(`í•„í„°ë§ í›„ (ì†Œì„¤ë§Œ):`, { 
                                        currentNovelTitle,
                                        filteredCount: dataList.length 
                                    });
                                } else {
                                    // ì†Œì„¤ ì œëª©ì´ ì—†ìœ¼ë©´ ë°ì´í„° í‘œì‹œ ì•ˆ í•¨
                                    dataList = [];
                                    console.log('ì†Œì„¤ ì œëª© ì—†ìŒ, ë°ì´í„° í‘œì‹œ ì•ˆ í•¨');
                                }
                                
                                // data ê°ì²´ë§Œ ì¶”ì¶œ
                                const filteredDataList = dataList.map(item => item.data);
                                
                                return {
                                    ...attr,
                                    dataList: filteredDataList,
                                    dataCount: filteredDataList.length
                                };
                            }
                        }
                    } catch (e) {
                        console.warn(`ì†ì„± "${attr.text}" ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:`, e);
                    }
                    return {
                        ...attr,
                        dataList: [],
                        dataCount: 0
                    };
                });

                const attributesWithData = await Promise.all(attributePromises);
                console.log('ì†ì„± ë°ì´í„° ì¡°íšŒ ì™„ë£Œ', { count: attributesWithData.length });

                // í•„í„° ì…ë ¥ë€ì˜ ê°’ìœ¼ë¡œ ì†ì„± ê²€ìƒ‰ (gpt_auto_new ë°©ì‹ ê·¸ëŒ€ë¡œ ì‚¬ìš©)
                let filteredAttributes = attributesWithData;
                
                if ($attributeFilterInput && $attributeFilterInput.value.trim()) {
                    const filterText = $attributeFilterInput.value.trim();
                    const filterBits = calculateBitValues(filterText);
                    
                    if (filterBits.max !== null && filterBits.min !== null && filterBits.max && filterBits.min) {
                        console.log('ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ ì‹œì‘ (gpt_auto_new ë°©ì‹):', { filterText, filterBits });
                        
                        try {
                            // gpt_auto_newì˜ autoSearch í•¨ìˆ˜ì™€ ë™ì¼í•œ ë¡œì§
                            // ê²€ìƒ‰ í…ìŠ¤íŠ¸ BITë¡œ ëª¨ë“  ì†ì„±ê³¼ ìœ ì‚¬ë„ ë¹„êµ
                            // ëª¨ë“  ì†ì„± ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                            const allAttrUrl = getServerUrl('/api/attributes/all');
                            const allAttrRes = await fetch(allAttrUrl);
                            
                            if (allAttrRes.ok) {
                                const allAttrData = await allAttrRes.json();
                                if (allAttrData.ok && allAttrData.attributes && allAttrData.attributes.length > 0) {
                                    // ìœ ì‚¬ë„ ê³„ì‚° í—¬í¼ í•¨ìˆ˜ (gpt_auto_newì™€ ë™ì¼)
                                    function calculateSimilarity(queryBitMax, queryBitMin, resultBitMax, resultBitMin) {
                                        if (resultBitMax === null || resultBitMax === undefined || 
                                            resultBitMin === null || resultBitMin === undefined) {
                                            return 0;
                                        }
                                        const bitMaxDiff = Math.abs((queryBitMax || 0) - (resultBitMax || 0));
                                        const bitMinDiff = Math.abs((queryBitMin || 0) - (resultBitMin || 0));
                                        const distance = Math.sqrt(bitMaxDiff * bitMaxDiff + bitMinDiff * bitMinDiff);
                                        return Math.max(0, 1 / (1 + distance));
                                    }
                                    
                                    // ê²€ìƒ‰ í…ìŠ¤íŠ¸ BITì™€ ê° ì†ì„± BIT ê°„ì˜ ìœ ì‚¬ë„ ê³„ì‚°
                                    const similarAttributes = allAttrData.attributes
                                        .map(attr => {
                                            const similarity = calculateSimilarity(filterBits.max, filterBits.min, attr.bitMax, attr.bitMin);
                                            return { ...attr, similarity };
                                        })
                                        .filter(attr => attr.similarity > 0.1) // ìœ ì‚¬ë„ ì„ê³„ê°’ 0.1
                                        .sort((a, b) => b.similarity - a.similarity)
                                        .slice(0, 10); // ìƒìœ„ 10ê°œ ì†ì„±ë§Œ (gpt_auto_newì™€ ë™ì¼)
                                    
                                    console.log('ìœ ì‚¬ ì†ì„± ë°œê²¬:', { count: similarAttributes.length });
                                    
                                    // ìœ ì‚¬í•œ ì†ì„±ë“¤ì˜ ë°ì´í„° ì¬ì¡°íšŒ (ìœ ì‚¬ë„ ê¸°ë°˜ ê²€ìƒ‰ ì‹œ ëª¨ë“  ë°ì´í„° í¬í•¨)
                                    const similarAttributeBitMap = new Map();
                                    similarAttributes.forEach(attr => {
                                        similarAttributeBitMap.set(`${attr.bitMax}_${attr.bitMin}`, attr);
                                    });
                                    
                                    // ìœ ì‚¬í•œ ì†ì„±ë“¤ì˜ ë°ì´í„° ì¬ì¡°íšŒ (í•„í„°ë§ ì—†ì´ ëª¨ë“  ë°ì´í„° í¬í•¨)
                                    const similarAttributePromises = similarAttributes.map(async (similarAttr) => {
                                        try {
                                            const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${similarAttr.bitMax}&bitMin=${similarAttr.bitMin}&limit=100`);
                                            const dataRes = await fetch(dataUrl);
                                            if (dataRes.ok) {
                                                const dataData = await dataRes.json();
                                                if (dataData.ok && dataData.items) {
                                                    // ì†ì„± ìì²´ë¥¼ ë°ì´í„°ë¡œ ì €ì¥í•œ ê²½ìš°ëŠ” ì œì™¸
                                                    let dataList = dataData.items
                                                        .filter(item => item.data && item.data.text && item.data.text !== similarAttr.text);
                                                    
                                                    // í•„í„° ì…ë ¥ ì‹œ ë°ì´í„° í•„í„°ë§ ì œê±° (ëª¨ë“  ë°ì´í„° í‘œì‹œ)
                                                    // data ê°ì²´ë§Œ ì¶”ì¶œ
                                                    const filteredDataList = dataList.map(item => item.data);
                                                    
                                                    return {
                                                        ...similarAttr,
                                                        dataList: filteredDataList,
                                                        dataCount: filteredDataList.length,
                                                        similarity: similarAttr.similarity
                                                    };
                                                }
                                            }
                                        } catch (e) {
                                            console.warn(`ì†ì„± "${similarAttr.text}" ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:`, e);
                                        }
                                        return {
                                            ...similarAttr,
                                            dataList: [],
                                            dataCount: 0,
                                            similarity: similarAttr.similarity
                                        };
                                    });
                                    
                                    // ìœ ì‚¬í•œ ì†ì„±ë“¤ì˜ ë°ì´í„° ì¬ì¡°íšŒ ì™„ë£Œ
                                    const similarAttributesWithData = await Promise.all(similarAttributePromises);
                                    filteredAttributes = similarAttributesWithData.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));
                                    
                                    console.log('ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ ì™„ë£Œ (gpt_auto_new ë°©ì‹):', { 
                                        filterText, 
                                        before: attributesWithData.length, 
                                        after: filteredAttributes.length 
                                    });
                                }
                            }
                        } catch (e) {
                            console.warn('ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ ì˜¤ë¥˜:', e);
                            // ì˜¤ë¥˜ ë°œìƒ ì‹œ ì›ë³¸ ëª©ë¡ ìœ ì§€
                            filteredAttributes = attributesWithData;
                        }
                    } else {
                        console.warn('í•„í„° í…ìŠ¤íŠ¸ BIT ê³„ì‚° ì‹¤íŒ¨');
                        filteredAttributes = [];
                    }
                }

                // ì†ì„± ëª©ë¡ ë Œë”ë§
                console.log('ì†ì„± ëª©ë¡ ë Œë”ë§ ì‹œì‘');
                
                let html = '';
                if (currentNovelTitle && currentChapter) {
                    html += `<div class="mb-2 p-2 bg-light rounded"><small class="text-muted">ğŸ“– ${escapeHtml(currentNovelTitle)} â†’ ${escapeHtml(currentChapter.number || 'ì±•í„°')}: ${escapeHtml(currentChapter.title || 'ì œëª© ì—†ìŒ')}</small></div>`;
                } else if (currentNovelTitle) {
                    html += `<div class="mb-2 p-2 bg-light rounded"><small class="text-muted">ğŸ“– ${escapeHtml(currentNovelTitle)} (ì±•í„° ë¯¸ì„ íƒ)</small></div>`;
                } else {
                    html += `<div class="mb-2 p-2 bg-warning rounded"><small class="text-danger">âš ï¸ ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ê³  ì±•í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</small></div>`;
                }

                if (filteredAttributes.length === 0 && ($attributeFilterInput && $attributeFilterInput.value.trim())) {
                    html += `<div class="mb-2 p-2 bg-light rounded"><small class="text-muted">"${escapeHtml($attributeFilterInput.value.trim())}"ì™€ ìœ ì‚¬í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤. (ìœ ì‚¬ë„ ì„ê³„ê°’: 0.1 ì´ìƒ)</small></div>`;
                }
                
                filteredAttributes.forEach((attr) => {
                    // ì†ì„±ëª…ì—ì„œ ì‹¤ì œ ì†ì„±ëª…ë§Œ ì¶”ì¶œ (í‘œì‹œìš©)
                    // "ë‹¤í¬ íŒíƒ€ì§€ â†’ ì±•í„° 1: ê°œìš” â†’ ë“±ì¥ì¸ë¬¼" â†’ "ë“±ì¥ì¸ë¬¼"
                    let displayAttributeText = attr.text || '';
                    const arrowParts = displayAttributeText.split(' â†’ ');
                    if (arrowParts.length >= 3) {
                        // ë§ˆì§€ë§‰ ë¶€ë¶„ì´ ì‹¤ì œ ì†ì„±ëª…
                        displayAttributeText = arrowParts[arrowParts.length - 1];
                    }
                    
                    // ìœ ì‚¬ë„ í‘œì‹œ (í•„í„° ì…ë ¥ì´ ìˆëŠ” ê²½ìš°)
                    const similarityBadge = ($attributeFilterInput && $attributeFilterInput.value.trim() && attr.similarity !== undefined) 
                        ? `<span class="badge ${attr.similarity >= 0.9 ? 'bg-success' : attr.similarity >= 0.7 ? 'bg-warning' : 'bg-info'} ms-2">ìœ ì‚¬ë„ ${(attr.similarity * 100).toFixed(1)}%</span>`
                        : '';
                    
                    html += `
                        <div class="attribute-item" 
                             data-bit-max="${attr.bitMax}" 
                             data-bit-min="${attr.bitMin}"
                             data-attribute-text="${escapeHtml(attr.text)}">
                            <div class="attribute-header">
                                <div>
                                    <span class="attribute-name">${escapeHtml(displayAttributeText)}</span>
                                    ${similarityBadge}
                                    ${arrowParts.length >= 3 ? `<br><small class="text-muted">${escapeHtml(arrowParts.slice(0, -1).join(' â†’ '))}</small>` : ''}
                                </div>
                                <small class="text-muted">
                                    BIT: ${attr.bitMax.toFixed(6)}, ${attr.bitMin.toFixed(6)} | 
                                    ë°ì´í„° ${attr.dataCount}ê°œ
                                </small>
                            </div>
                            <div class="data-list">
                                ${attr.dataList.length > 0 ? attr.dataList.map((data, dataIdx) => {
                                    const fullText = data.text || '';
                                    const displayText = fullText.length > 150 ? fullText.substring(0, 150) + '...' : fullText;
                                    const uniqueId = `data-${attr.bitMax}-${attr.bitMin}-${dataIdx}`;
                                    // í…ìŠ¤íŠ¸ë¥¼ JSON.stringifyë¡œ ì•ˆì „í•˜ê²Œ ì¸ì½”ë”©
                                    const safeText = JSON.stringify(fullText);
                                    return `
                                    <div class="data-item">
                                        <strong style="word-break: break-word; display: block; margin-bottom: 8px;">${escapeHtml(displayText)}</strong>
                                        <div class="d-flex justify-content-between align-items-center">
                                            <small class="text-muted">
                                                BIT: ${data.bitMax.toFixed(6)}, ${data.bitMin.toFixed(6)}
                                            </small>
                                            <button class="btn btn-sm btn-outline-secondary" 
                                                    onclick="copyDataTextFromHidden('${uniqueId}'); return false;"
                                                    title="ì „ì²´ í…ìŠ¤íŠ¸ ë³µì‚¬">
                                                ğŸ“‹ ë³µì‚¬
                                            </button>
                                        </div>
                                        <input type="hidden" id="${uniqueId}" value="${escapeHtml(fullText).replace(/"/g, '&quot;')}">
                                    </div>
                                `;
                                }).join('') : '<div class="text-muted small">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>'}
                            </div>
                        </div>
                    `;
                });

                $attributesList.innerHTML = html;
                console.log('ì†ì„± ëª©ë¡ ë Œë”ë§ ì™„ë£Œ', { renderedCount: filteredAttributes.length, total: attributesWithData.length });
            } catch (e) {
                console.error('ì†ì„± ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜:', e);
                $attributesList.innerHTML = `<div class="text-danger">âœ— ë¡œë“œ ì‹¤íŒ¨: ${e.message}</div>`;
            }
        }

        // ì†ì„± ê²€ìƒ‰ í•„í„° ì…ë ¥ ì´ë²¤íŠ¸
        if ($attributeFilterInput) {
            let filterTimer = null;
            $attributeFilterInput.addEventListener('input', () => {
                // ë””ë°”ìš´ì‹±ìœ¼ë¡œ ìë™ ë¡œë“œ
                if (filterTimer) clearTimeout(filterTimer);
                filterTimer = setTimeout(() => {
                    loadAttributes();
                }, 500);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ë°ì´í„° í…ìŠ¤íŠ¸ ë³µì‚¬ í•¨ìˆ˜ (hidden inputì—ì„œ í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°)
        function copyDataTextFromHidden(id) {
            try {
                const hiddenInput = document.getElementById(id);
                if (!hiddenInput) {
                    alert('ë³µì‚¬í•  ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                
                // ë²„íŠ¼ ì°¾ê¸° (hidden inputì˜ ë¶€ëª¨ì—ì„œ ì°¾ê¸°)
                const dataItem = hiddenInput.closest('.data-item');
                const btn = dataItem ? dataItem.querySelector('button') : null;
                
                // &quot; ë“±ì„ ì›ë˜ ë¬¸ìë¡œ ë³µì›
                const textToCopy = hiddenInput.value
                    .replace(/&quot;/g, '"')
                    .replace(/&#x27;/g, "'")
                    .replace(/&amp;/g, '&')
                    .replace(/&lt;/g, '<')
                    .replace(/&gt;/g, '>');
                
                navigator.clipboard.writeText(textToCopy).then(() => {
                    console.log('ë°ì´í„° ë³µì‚¬ ì™„ë£Œ');
                    
                    // ë³µì‚¬ ë²„íŠ¼ í”¼ë“œë°±
                    if (btn) {
                        const originalText = btn.innerHTML;
                        btn.innerHTML = 'âœ“ ë³µì‚¬ë¨';
                        btn.classList.remove('btn-outline-secondary');
                        btn.classList.add('btn-success');
                        
                        setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.classList.remove('btn-success');
                            btn.classList.add('btn-outline-secondary');
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('ë³µì‚¬ ì‹¤íŒ¨:', err);
                    // í´ë°±: í…ìŠ¤íŠ¸ ì˜ì—­ ì‚¬ìš©
                    try {
                        const textarea = document.createElement('textarea');
                        textarea.value = textToCopy;
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        
                        if (btn) {
                            const originalText = btn.innerHTML;
                            btn.innerHTML = 'âœ“ ë³µì‚¬ë¨';
                            btn.classList.remove('btn-outline-secondary');
                            btn.classList.add('btn-success');
                            
                            setTimeout(() => {
                                btn.innerHTML = originalText;
                                btn.classList.remove('btn-success');
                                btn.classList.add('btn-outline-secondary');
                            }, 2000);
                        }
                    } catch (fallbackErr) {
                        console.error('ë³µì‚¬ í´ë°± ì‹¤íŒ¨:', fallbackErr);
                        alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                    }
                });
            } catch (e) {
                console.error('ë³µì‚¬ ì˜¤ë¥˜:', e);
                alert('ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        }
        
        // ì „ì—­ í•¨ìˆ˜ë¡œ ë“±ë¡
        window.copyDataTextFromHidden = copyDataTextFromHidden;

        // ë°ì´í„° ì¶”ê°€ ëª¨ë‹¬ ì—´ê¸°
        window.openAddDataModal = function(attributeText, attributeBitMax, attributeBitMin) {
            currentAttribute = {
                text: attributeText,
                bitMax: attributeBitMax,
                bitMin: attributeBitMin
            };
            
            $modalAttributeName.textContent = attributeText;
            $modalAttributeMax.textContent = attributeBitMax.toFixed(10);
            $modalAttributeMin.textContent = attributeBitMin.toFixed(10);
            $newDataInput.value = '';
            $newDataMax.textContent = '-';
            $newDataMin.textContent = '-';
            $saveDataStatus.textContent = '';
            
            addDataModal.show();
        };

        // ë°ì´í„° ì €ì¥
        $saveDataBtn.addEventListener('click', async () => {
            console.log('ë°ì´í„° ì €ì¥ ë²„íŠ¼ í´ë¦­');
            
            if (!currentAttribute) {
                console.warn('ë°ì´í„° ì €ì¥: ì†ì„± ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.');
                $saveDataStatus.textContent = 'âœ— ì†ì„± ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            const dataText = $newDataInput.value.trim();
            if (!dataText) {
                console.warn('ë°ì´í„° ì €ì¥: ë°ì´í„°ê°€ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                $saveDataStatus.textContent = 'âœ— ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            console.log('ë°ì´í„° ì €ì¥ ì‹œì‘', { attribute: currentAttribute.text, dataLength: dataText.length });
            
            const { max, min } = calculateBitValues(dataText);
            console.log('ë°ì´í„° BIT ê³„ì‚°', { max, min });
            
            if (max === null || min === null) {
                console.error('ë°ì´í„° ì €ì¥: BIT ê°’ ê³„ì‚° ì‹¤íŒ¨');
                $saveDataStatus.textContent = 'âœ— BIT ê°’ ê³„ì‚° ì‹¤íŒ¨.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            // ì†Œì„¤ ì œëª©ê³¼ ì±•í„° ì •ë³´ í™•ì¸
            const novelTitle = $novelTitle.value.trim();
            const currentChapter = currentChapterIdx !== null && chapters[currentChapterIdx] ? chapters[currentChapterIdx] : null;
            
            if (!novelTitle) {
                console.warn('ë°ì´í„° ì €ì¥: ì†Œì„¤ ì œëª©ì´ ì…ë ¥ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                $saveDataStatus.textContent = 'âœ— ì†Œì„¤ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }
            
            if (!currentChapter) {
                console.warn('ë°ì´í„° ì €ì¥: ì±•í„°ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                $saveDataStatus.textContent = 'âœ— ì±•í„°ë¥¼ ì„ íƒí•˜ì„¸ìš”.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            // ì†Œì„¤ ì œëª© BIT ê³„ì‚°
            const novelTitleBits = calculateBitValues(novelTitle);
            if (novelTitleBits.max === null || novelTitleBits.min === null) {
                console.error('ë°ì´í„° ì €ì¥: ì†Œì„¤ ì œëª© BIT ê°’ ê³„ì‚° ì‹¤íŒ¨');
                $saveDataStatus.textContent = 'âœ— ì†Œì„¤ ì œëª© BIT ê³„ì‚° ì‹¤íŒ¨.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            // ì±•í„° BIT ê³„ì‚°
            const chapterText = `${currentChapter.number || ''} ${currentChapter.title || ''}`.trim();
            const chapterBits = calculateBitValues(chapterText);
            if (chapterBits.max === null || chapterBits.min === null) {
                console.error('ë°ì´í„° ì €ì¥: ì±•í„° BIT ê°’ ê³„ì‚° ì‹¤íŒ¨');
                $saveDataStatus.textContent = 'âœ— ì±•í„° BIT ê³„ì‚° ì‹¤íŒ¨.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            try {
                $saveDataBtn.disabled = true;
                $saveDataStatus.textContent = 'ì €ì¥ ì¤‘...';
                $saveDataStatus.style.color = '#007bff';

                console.log('ë°ì´í„° ì €ì¥ API ìš”ì²­', { 
                    novelTitle, 
                    novelTitleBits,
                    chapter: currentChapter,
                    chapterBits
                });
                const url = getServerUrl('/api/attributes/data');
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        attributeText: currentAttribute.text,
                        attributeBitMax: currentAttribute.bitMax,
                        attributeBitMin: currentAttribute.bitMin,
                        text: dataText,
                        dataBitMax: max,
                        dataBitMin: min,
                        novelTitle: novelTitle,
                        novelTitleBitMax: novelTitleBits.max,
                        novelTitleBitMin: novelTitleBits.min,
                        chapter: currentChapter,
                        chapterBitMax: chapterBits.max,
                        chapterBitMin: chapterBits.min
                    })
                });

                console.log('ë°ì´í„° ì €ì¥ API ì‘ë‹µ', { status: res.status });

                if (!res.ok) {
                    const errorText = await res.text();
                    console.error('ë°ì´í„° ì €ì¥ API ì˜¤ë¥˜', { status: res.status, error: errorText });
                    throw new Error(`HTTP ${res.status}: ${errorText}`);
                }

                const data = await res.json();
                console.log('ë°ì´í„° ì €ì¥ ê²°ê³¼', { ok: data.ok, duplicate: data.duplicate });
                
                if (!data.ok) {
                    throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
                }

                if (data.duplicate) {
                    console.warn('ë°ì´í„° ì¤‘ë³µ ì €ì¥ ì‹œë„');
                    $saveDataStatus.textContent = 'âš  ì´ë¯¸ ë™ì¼í•œ ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.';
                    $saveDataStatus.style.color = '#ffc107';
                } else {
                    console.log('ë°ì´í„° ì €ì¥ ì™„ë£Œ');
                    $saveDataStatus.textContent = 'âœ“ ë°ì´í„° ì €ì¥ ì™„ë£Œ';
                    $saveDataStatus.style.color = '#28a745';
                    $newDataInput.value = '';
                    $newDataMax.textContent = '-';
                    $newDataMin.textContent = '-';
                    
                    setTimeout(() => {
                        addDataModal.hide();
                        loadAttributes();
                    }, 1000);
                }
            } catch (e) {
                console.error('ë°ì´í„° ì €ì¥ ì˜¤ë¥˜:', e);
                $saveDataStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
                $saveDataStatus.style.color = '#dc3545';
            } finally {
                $saveDataBtn.disabled = false;
            }
        });

        // ì†ì„±ìœ¼ë¡œ ê²€ìƒ‰
        window.searchByAttribute = function(attributeText, attributeBitMax, attributeBitMin) {
            window.location.href = `bit_search.html?attribute=${encodeURIComponent(attributeText)}&bitMax=${attributeBitMax}&bitMin=${attributeBitMin}`;
        };

        // ìƒˆë¡œê³ ì¹¨
        $refreshBtn.addEventListener('click', () => {
            console.log('ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ë²„íŠ¼ í´ë¦­');
            loadAttributes();
        });

        // í˜ì´ì§€ ë¡œë“œ ì‹œ localStorageì—ì„œ ë°ì´í„° ë³µì›
        console.log('í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ, ë°ì´í„° ë³µì› ì‹œì‘');
        loadNovelTitle();
        
        // ì†Œì„¤ ì œëª© BIT ê°’ ê³„ì‚° ë° í‘œì‹œ (ë³µì› í›„)
        // BIT ìŠ¤í¬ë¦½íŠ¸ê°€ ë¡œë“œë  ë•Œê¹Œì§€ ëŒ€ê¸°
        function initAfterBitScript() {
            if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
                setTimeout(initAfterBitScript, 100);
                return;
            }
            
            const savedTitle = $novelTitle.value.trim();
            if (savedTitle) {
                updateNovelTitleBits(savedTitle);
            }
        }
        
        initAfterBitScript();
        loadChapters();
        
        // ì±•í„° ë¡œë“œ í›„ í•„í„° ì…ë ¥ë€ ë™ê¸°í™”
        setTimeout(() => {
            syncFilterInputs();
        }, 300);
        
        // ì†ì„± ëª©ë¡ ë¡œë“œ
        loadAttributes();
    </script>
</body>
</html>

