<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì†Œì„¤ êµ¬ì„± ìš”ì†Œ ê´€ë¦¬</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f5f5f5;
            padding: 20px;
        }
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .card {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .attribute-item {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: white;
        }
        .attribute-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .attribute-name {
            font-size: 1.1em;
            font-weight: bold;
            color: #007bff;
        }
        .bit-display {
            font-size: 0.85em;
            color: #6c757d;
            margin-top: 5px;
        }
        .data-item {
            background: #f8f9fa;
            padding: 10px;
            margin: 8px 0;
            border-left: 3px solid #28a745;
            border-radius: 4px;
        }
        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }
        .status {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
        }
        .status-success {
            background-color: #d4edda;
            color: #155724;
        }
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
        }
        .status-info {
            background-color: #d1ecf1;
            color: #0c5460;
        }
        .attribute-card {
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }
        .attribute-card:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-2px);
            border-color: #007bff !important;
        }
        .attribute-card:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="main-container">
        <h1 class="mb-4">ğŸ“š ì†Œì„¤ êµ¬ì„± ìš”ì†Œ ê´€ë¦¬ (GPT ìë™ ì •ë¦¬)</h1>

        <div class="row">
            <!-- ì¢Œì¸¡: ì†ì„± ëª©ë¡ ì„¹ì…˜ -->
            <div class="col-md-4">
                <div class="card">
                    <div class="card-header bg-success text-white d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">ğŸ“‹ ì €ì¥ëœ ì†ì„± ëª©ë¡</h5>
                        <button id="refreshBtn" class="btn btn-sm btn-light">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
                    </div>
                    <div class="card-body" style="max-height: 800px; overflow-y: auto;">
                        <div id="attributesList"></div>
                    </div>
                </div>
            </div>

            <!-- ìš°ì¸¡: GPT ë¶„ì„ ì„¹ì…˜ -->
            <div class="col-md-8">
                <!-- GPT ìë™ ë¶„ì„ ì„¹ì…˜ -->
                <div class="card mb-3">
                    <div class="card-header bg-gradient text-white" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                        <h5 class="mb-0">ğŸ¤– GPT AI ìë™ ì†ì„± ì¶”ì¶œ</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">í”„ë¡¬í”„íŠ¸ ì…ë ¥ (ì„ íƒì‚¬í•­)</label>
                            <textarea 
                                id="gptPrompt" 
                                class="form-control mb-2" 
                                placeholder="GPTì—ê²Œ ì¶”ê°€ ì§€ì‹œì‚¬í•­ì„ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ: 'ì†ì„±ì„ ë” ì¶”ê°€í•´ì£¼ì„¸ìš”', 'ì†Œì„¤ì˜ ë“±ì¥ì¸ë¬¼ê³¼ ë°°ê²½ë§Œ ì¶”ì¶œí•´ì£¼ì„¸ìš”', 'ì¥ë¥´ì™€ ì£¼ì œë¡œ ë¶„ë¥˜í•´ì£¼ì„¸ìš”' ë“±..."
                                rows="2"
                            ></textarea>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ë¶„ì„í•  í…ìŠ¤íŠ¸ ì…ë ¥</label>
                            <textarea 
                                id="gptInput" 
                                class="form-control" 
                                placeholder="ì†Œì„¤ ê´€ë ¨ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”. GPTê°€ ìë™ìœ¼ë¡œ ì†ì„±(ì†Œì„¤ êµ¬ì„± ìš”ì†Œ)ë“¤ì„ ì¶”ì¶œí•˜ê³  ì •ë¦¬í•©ë‹ˆë‹¤.&#10;ì˜ˆ: ì†Œì„¤ì˜ ë‚´ìš©, ë“±ì¥ì¸ë¬¼ ì„¤ëª…, ë°°ê²½ ì„¤ì •, ì£¼ìš” ì‚¬ê±´ ë“±..."
                                rows="6"
                            ></textarea>
                        </div>
                        <button id="analyzeBtn" class="btn btn-primary btn-lg w-100">
                            ğŸ” GPT AIë¡œ ë¶„ì„í•˜ì—¬ ì†ì„± ìë™ ì¶”ì¶œ ë° ì €ì¥
                        </button>
                        <div id="gptStatus" class="mt-2 small"></div>
                    </div>
                </div>

                <!-- GPT ë¶„ì„ ê²°ê³¼ -->
                <div class="card" id="gptResultCard" style="display: none;">
                    <div class="card-header bg-info text-white">
                        <h5 class="mb-0">ğŸ“‹ GPT ë¶„ì„ ê²°ê³¼</h5>
                    </div>
                    <div class="card-body">
                        <div id="gptResponse" class="mb-3 p-3 bg-light rounded" style="white-space: pre-wrap; max-height: 300px; overflow-y: auto;"></div>
                        <div id="extractedAttributes" class="mb-3"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì†ì„±ë³„ ë°ì´í„° ì¶”ê°€ ëª¨ë‹¬ -->
        <div class="modal fade" id="addDataModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">ë°ì´í„° ì¶”ê°€</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label class="form-label fw-bold">ì†ì„±:</label>
                            <div id="modalAttributeName" class="fw-bold text-primary"></div>
                            <small class="text-muted">
                                BIT MAX: <span id="modalAttributeMax">-</span> | 
                                BIT MIN: <span id="modalAttributeMin">-</span>
                            </small>
                        </div>
                        <div class="mb-3">
                            <label class="form-label fw-bold">ë°ì´í„° ì¶”ê°€ (ì´ ì†ì„±ì— ì†í•˜ëŠ” êµ¬ì²´ì ì¸ ë‚´ìš©)</label>
                            <textarea 
                                id="newDataInput" 
                                class="form-control" 
                                rows="3"
                                placeholder="ì˜ˆ: 'ì£¼ì¸ê³µì˜ ë‚´ì  ê°ˆë“±', 'ë§ˆë²• ì„¸ê³„ì˜ ë²•ì¹™' ë“±..."
                            ></textarea>
                            <div class="row mt-2">
                                <div class="col-md-6">
                                    <div class="bit-display">
                                        <strong>ë°ì´í„° BIT MAX:</strong> <span id="newDataMax">-</span>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="bit-display">
                                        <strong>ë°ì´í„° BIT MIN:</strong> <span id="newDataMin">-</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <button id="saveDataBtn" class="btn btn-success">ë°ì´í„° ì €ì¥</button>
                        <span id="saveDataStatus" class="ms-2 small"></span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://xn--9l4b4xi9r.com/_8%EB%B9%84%ED%8A%B8/js/bitCalculation.js" defer></script>
    <script>
        // DOM ìš”ì†Œ
        const $gptPrompt = document.getElementById('gptPrompt');
        const $gptInput = document.getElementById('gptInput');
        const $analyzeBtn = document.getElementById('analyzeBtn');
        const $gptStatus = document.getElementById('gptStatus');
        const $gptResultCard = document.getElementById('gptResultCard');
        const $gptResponse = document.getElementById('gptResponse');
        const $extractedAttributes = document.getElementById('extractedAttributes');

        const $attributesList = document.getElementById('attributesList');
        const $refreshBtn = document.getElementById('refreshBtn');
        
        // ëª¨ë‹¬ ê´€ë ¨
        const addDataModal = new bootstrap.Modal(document.getElementById('addDataModal'));
        const $modalAttributeName = document.getElementById('modalAttributeName');
        const $modalAttributeMax = document.getElementById('modalAttributeMax');
        const $modalAttributeMin = document.getElementById('modalAttributeMin');
        const $newDataInput = document.getElementById('newDataInput');
        const $newDataMax = document.getElementById('newDataMax');
        const $newDataMin = document.getElementById('newDataMin');
        const $saveDataBtn = document.getElementById('saveDataBtn');
        const $saveDataStatus = document.getElementById('saveDataStatus');

        let currentAttribute = null;
        let extractedAttributesList = [];

        function getServerUrl(path) {
            if (window.location.protocol === 'file:') {
                return `http://localhost:8123${path}`;
            }
            return path;
        }

        function calculateBitValues(text) {
            if (!text || typeof text !== 'string' || text.trim() === '') {
                return { max: null, min: null };
            }
            try {
                if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
                    console.warn('BIT ê³„ì‚° í•¨ìˆ˜ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                    return { max: null, min: null };
                }
                const unicodeArray = wordNbUnicodeFormat(text);
                const max = BIT_MAX_NB(unicodeArray);
                const min = BIT_MIN_NB(unicodeArray);
                return { max: isFinite(max) ? max : null, min: isFinite(min) ? min : null };
            } catch (e) {
                console.error('BIT ê³„ì‚° ì˜¤ë¥˜:', e);
                return { max: null, min: null };
            }
        }

        // GPT ë¶„ì„ í•¨ìˆ˜
        async function analyzeWithGPT() {
            const text = $gptInput.value.trim();
            if (!text) {
                alert('ë¶„ì„í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
                return;
            }

            try {
                $analyzeBtn.disabled = true;
                $gptStatus.textContent = 'GPT AI ë¶„ì„ ì¤‘...';
                $gptStatus.style.color = '#007bff';
                $gptResponse.textContent = 'ë¶„ì„ ì¤‘...';

                const customPrompt = $gptPrompt.value.trim();
                
                const systemMessage = `ë‹¹ì‹ ì€ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ êµ¬ì„± ìš”ì†Œ(ì†ì„±)ë“¤ì„ ì¶”ì¶œí•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ì…ë ¥ëœ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ì— í•„ìš”í•œ êµ¬ì„± ìš”ì†Œë“¤ì„ ì°¾ì•„ì£¼ì„¸ìš”. ì˜ˆë¥¼ ë“¤ì–´:
- ë“±ì¥ì¸ë¬¼ (ì£¼ì¸ê³µ, ì¡°ì—°, ì•…ì—­ ë“±)
- ë°°ê²½ ì„¤ì • (ì‹œê°„, ì¥ì†Œ, ì„¸ê³„ê´€)
- ì£¼ìš” ì‚¬ê±´ (í”Œë¡¯, ê°ˆë“±, ì „ê°œ)
- ê°ì •/ë¶„ìœ„ê¸° (ë¶„ìœ„ê¸°, ê°ì • ë³€í™”)
- í…Œë§ˆ/ì£¼ì œ (ë©”ì‹œì§€, êµí›ˆ)
- ìŠ¤íƒ€ì¼/í†¤ (ë¬¸ì²´, í†¤)

${customPrompt ? `\n[ì¶”ê°€ ì§€ì‹œì‚¬í•­]\n${customPrompt}\n` : ''}

**ì‘ë‹µ í˜•ì‹**: ì•„ë˜ í˜•ì‹ì„ ì •í™•íˆ ë”°ë¥´ì„¸ìš”. ê° ì†ì„±ë§ˆë‹¤ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•˜ì„¸ìš”:

ì†ì„± 1: [ì†ì„±ëª…]

ë°ì´í„°: [êµ¬ì²´ì ì¸ ë°ì´í„° ë‚´ìš©]

ì´ìœ : [ì´ ì†ì„±ì„ ì¶”ì¶œí•œ ì´ìœ ]

ì†ì„± BIT: -, -

ë°ì´í„° BIT: -, -

---

ì†ì„± 2: [ì†ì„±ëª…]

ë°ì´í„°: [êµ¬ì²´ì ì¸ ë°ì´í„° ë‚´ìš©]

ì´ìœ : [ì´ ì†ì„±ì„ ì¶”ì¶œí•œ ì´ìœ ]

ì†ì„± BIT: -, -

ë°ì´í„° BIT: -, -

---

(ê³„ì† ë°˜ë³µ...)

**ì¤‘ìš”**: 
- ìµœì†Œ 3ê°œ ì´ìƒì˜ ì†ì„±ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”.
- ì‚¬ìš©ìê°€ "ì†ì„±ì„ ë” ì¶”ê°€í•´ì£¼ì„¸ìš”" ë˜ëŠ” ìœ ì‚¬í•œ ìš”ì²­ì„ í•˜ë©´, ê¸°ì¡´ ì†ì„± ì™¸ì— ì¶”ê°€ ì†ì„±ë“¤ì„ ë” ì°¾ì•„ì„œ ì œê³µí•´ì£¼ì„¸ìš”.
- ì†ì„± BITì™€ ë°ì´í„° BITëŠ” í•­ìƒ "-, -"ë¡œ í‘œì‹œí•˜ì„¸ìš” (ì‹¤ì œ ê³„ì‚°ì€ ì‹œìŠ¤í…œì—ì„œ ì²˜ë¦¬í•©ë‹ˆë‹¤).
- JSON í˜•ì‹ì´ ì•„ë‹Œ ìœ„ì˜ í…ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•˜ì„¸ìš”.`;

                const url = getServerUrl('/api/gpt/chat');
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: `ë‹¤ìŒ ì†Œì„¤ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†Œì„¤ êµ¬ì„± ìš”ì†Œ(ì†ì„±)ë“¤ì„ ì¶”ì¶œí•´ì£¼ì„¸ìš”:\n\n"${text}"${customPrompt ? `\n\n${customPrompt}` : ''}`,
                        systemMessage: systemMessage,
                        model: 'gpt-4o-mini',
                        temperature: 0.3,
                        maxTokens: 1500
                    })
                });

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }

                const data = await res.json();
                if (!data.ok) {
                    throw new Error(data.error || 'GPT ë¶„ì„ ì‹¤íŒ¨');
                }

                // í…ìŠ¤íŠ¸ í˜•ì‹ ì‘ë‹µ íŒŒì‹±
                let parsed = [];
                try {
                    const responseText = data.response.trim();
                    
                    // ë¨¼ì € JSON í˜•ì‹ì¸ì§€ í™•ì¸ (í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´)
                    let jsonText = responseText;
                    if (jsonText.startsWith('```json')) {
                        jsonText = jsonText.replace(/```json\s*/, '').replace(/\s*```$/, '');
                    } else if (jsonText.startsWith('```')) {
                        jsonText = jsonText.replace(/```\s*/, '').replace(/\s*```$/, '');
                    }
                    
                    try {
                        const jsonParsed = JSON.parse(jsonText);
                        if (Array.isArray(jsonParsed)) {
                            // JSON í˜•ì‹ìœ¼ë¡œ íŒŒì‹± ì„±ê³µ
                            parsed = jsonParsed.map(item => ({
                                attribute: item.attribute?.trim() || '',
                                data: item.data?.trim() || '',
                                reasoning: item.reasoning?.trim() || ''
                            }));
                        }
                    } catch {
                        // JSONì´ ì•„ë‹ˆë©´ í…ìŠ¤íŠ¸ í˜•ì‹ìœ¼ë¡œ íŒŒì‹±
                        // "ì†ì„± N: ..." íŒ¨í„´ìœ¼ë¡œ ì†ì„±ë“¤ì„ ë¶„ë¦¬
                        // "---" ë˜ëŠ” ë¹ˆ ì¤„ë¡œ êµ¬ë¶„ëœ ì„¹ì…˜ì„ ì°¾ìŒ
                        const sections = responseText.split(/(?:^|\n)---+|\n\n(?=ì†ì„±\s*\d+\s*:)/m);
                        
                        for (const section of sections) {
                            const trimmedSection = section.trim();
                            if (!trimmedSection) continue;
                            
                            // ì†ì„±ëª… ì¶”ì¶œ (ì†ì„± 1: ë˜ëŠ” ì†ì„± N: í˜•ì‹)
                            const attrMatch = trimmedSection.match(/ì†ì„±\s*\d+\s*:\s*(.+?)(?:\n|$)/);
                            if (!attrMatch) continue;
                            const attribute = attrMatch[1].trim();
                            
                            // ë°ì´í„° ì¶”ì¶œ (ë°ì´í„°: ë‹¤ìŒë¶€í„° ì´ìœ : ë˜ëŠ” ì†ì„± BIT: ì „ê¹Œì§€)
                            const dataMatch = trimmedSection.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì´ìœ :|\nì´ìœ :|\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|$)/s);
                            const dataText = dataMatch ? dataMatch[1].trim() : '';
                            
                            // ì´ìœ  ì¶”ì¶œ (ì´ìœ : ë‹¤ìŒë¶€í„° ì†ì„± BIT: ë˜ëŠ” ë°ì´í„° BIT: ì „ê¹Œì§€)
                            const reasonMatch = trimmedSection.match(/ì´ìœ \s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|\n\në°ì´í„°\s*BIT:|\në°ì´í„°\s*BIT:|$)/s);
                            const reasoning = reasonMatch ? reasonMatch[1].trim() : '';
                            
                            if (attribute && dataText) {
                                parsed.push({
                                    attribute: attribute,
                                    data: dataText,
                                    reasoning: reasoning
                                });
                            }
                        }
                        
                        // ì„¹ì…˜ ë¶„ë¦¬ê°€ ì•ˆ ëœ ê²½ìš°, ì§ì ‘ íŒ¨í„´ ë§¤ì¹­ ì‹œë„
                        if (parsed.length === 0) {
                            const attributeMatches = [...responseText.matchAll(/ì†ì„±\s*\d+\s*:\s*(.+?)(?:\n|$)/g)];
                            for (const attrMatch of attributeMatches) {
                                const attribute = attrMatch[1].trim();
                                if (!attribute) continue;
                                
                                // í•´ë‹¹ ì†ì„± ë‹¤ìŒ ë¶€ë¶„ ì°¾ê¸°
                                const attrIndex = attrMatch.index + attrMatch[0].length;
                                const nextSection = responseText.substring(attrIndex);
                                
                                const dataMatch = nextSection.match(/ë°ì´í„°\s*:\s*(.+?)(?:\n\nì´ìœ :|\nì´ìœ :|\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|ì†ì„±\s*\d+\s*:|$)/s);
                                const dataText = dataMatch ? dataMatch[1].trim() : '';
                                
                                const reasonMatch = nextSection.match(/ì´ìœ \s*:\s*(.+?)(?:\n\nì†ì„±\s*BIT:|\nì†ì„±\s*BIT:|\n\në°ì´í„°\s*BIT:|\në°ì´í„°\s*BIT:|ì†ì„±\s*\d+\s*:|$)/s);
                                const reasoning = reasonMatch ? reasonMatch[1].trim() : '';
                                
                                if (attribute && dataText) {
                                    parsed.push({
                                        attribute: attribute,
                                        data: dataText,
                                        reasoning: reasoning
                                    });
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('íŒŒì‹± ì˜¤ë¥˜:', e);
                    throw new Error('GPT ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨: ' + e.message);
                }

                if (!Array.isArray(parsed) || parsed.length === 0) {
                    throw new Error('GPT ì‘ë‹µì—ì„œ ì†ì„±ì„ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì‘ë‹µ í˜•ì‹ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }

                // ì¶”ì¶œëœ ì†ì„± ì²˜ë¦¬
                extractedAttributesList = parsed.map(item => {
                    const attribute = item.attribute?.trim() || '';
                    const dataText = item.data?.trim() || '';
                    const reasoning = item.reasoning?.trim() || '';
                    
                    if (!attribute || !dataText) {
                        return null;
                    }

                    const attrBits = calculateBitValues(attribute);
                    const dataBits = calculateBitValues(dataText);
                    
                    return {
                        attribute: attribute,
                        data: dataText,
                        reasoning: reasoning,
                        attributeBitMax: attrBits.max,
                        attributeBitMin: attrBits.min,
                        dataBitMax: dataBits.max,
                        dataBitMin: dataBits.min
                    };
                }).filter(Boolean);

                if (extractedAttributesList.length === 0) {
                    throw new Error('ì¶”ì¶œëœ ìœ íš¨í•œ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.');
                }

                // ê²°ê³¼ í‘œì‹œ
                $gptResponse.textContent = data.response;
                displayExtractedAttributes();
                $gptResultCard.style.display = 'block';
                $gptStatus.textContent = `âœ“ ë¶„ì„ ì™„ë£Œ: ${extractedAttributesList.length}ê°œ ì†ì„± ì¶”ì¶œë¨. ìë™ ì €ì¥ ì¤‘...`;
                $gptStatus.style.color = '#007bff';

                // ìë™ ì €ì¥ ì‹¤í–‰
                await saveAllAttributes();

            } catch (e) {
                console.error('GPT ë¶„ì„ ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ë¶„ì„ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
                $gptResponse.textContent = `ì˜¤ë¥˜: ${e.message}`;
            } finally {
                $analyzeBtn.disabled = false;
            }
        }

        // ì¶”ì¶œëœ ì†ì„± í‘œì‹œ
        function displayExtractedAttributes() {
            let html = '<div class="row">';
            extractedAttributesList.forEach((item, idx) => {
                const attrMax = item.attributeBitMax !== null && item.attributeBitMax !== undefined ? item.attributeBitMax.toFixed(10) : '-';
                const attrMin = item.attributeBitMin !== null && item.attributeBitMin !== undefined ? item.attributeBitMin.toFixed(10) : '-';
                const dataMax = item.dataBitMax !== null && item.dataBitMax !== undefined ? item.dataBitMax.toFixed(10) : '-';
                const dataMin = item.dataBitMin !== null && item.dataBitMin !== undefined ? item.dataBitMin.toFixed(10) : '-';
                const saveStatus = item.saveStatus || 'pending'; // pending, saving, success, duplicate, error
                const saveMessage = item.saveMessage || '';
                
                let statusHtml = '';
                if (saveStatus === 'pending') {
                    statusHtml = '<div class="small text-muted mt-2"><em>ì €ì¥ ëŒ€ê¸° ì¤‘...</em></div>';
                } else if (saveStatus === 'saving') {
                    statusHtml = '<div class="small text-info mt-2">ğŸ’¾ ì €ì¥ ì¤‘...</div>';
                } else if (saveStatus === 'success') {
                    statusHtml = `<div class="small text-success mt-2">âœ“ ${saveMessage || 'ì €ì¥ ì™„ë£Œ'}</div>`;
                } else if (saveStatus === 'duplicate') {
                    statusHtml = `<div class="small text-warning mt-2">âš  ${saveMessage || 'ì´ë¯¸ ì €ì¥ë¨'}</div>`;
                } else if (saveStatus === 'error') {
                    statusHtml = `<div class="small text-danger mt-2">âœ— ${saveMessage || 'ì €ì¥ ì‹¤íŒ¨'}</div>`;
                }
                
                html += `
                    <div class="col-md-6 mb-3">
                        <div class="border rounded p-3 attribute-card" 
                             onclick="handleAttributeCardClick(${idx})">
                            <h6 class="text-primary">ì†ì„± ${idx + 1}: ${escapeHtml(item.attribute)}</h6>
                            <div class="mb-2">
                                <strong>ë°ì´í„°:</strong> ${escapeHtml(item.data)}
                            </div>
                            ${item.reasoning ? `<div class="small text-muted mb-2"><strong>ì´ìœ :</strong> ${escapeHtml(item.reasoning)}</div>` : ''}
                            <div class="small text-muted">
                                <strong>ì†ì„± BIT:</strong> MAX ${attrMax}, MIN ${attrMin}<br>
                                <strong>ë°ì´í„° BIT:</strong> MAX ${dataMax}, MIN ${dataMin}
                            </div>
                            ${(item.attributeBitMax === null || item.attributeBitMin === null || item.dataBitMax === null || item.dataBitMin === null) ? 
                                '<div class="text-warning small mt-1">âš  BIT ê°’ ê³„ì‚° ì‹¤íŒ¨</div>' : ''}
                            ${statusHtml}
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            $extractedAttributes.innerHTML = html;
        }
        
        // ì†ì„± ì¹´ë“œ í´ë¦­ í•¸ë“¤ëŸ¬
        window.handleAttributeCardClick = function(idx) {
            const item = extractedAttributesList[idx];
            if (!item) return;
            
            // ì†ì„± ì •ë³´ë¥¼ ì½˜ì†”ì— ì¶œë ¥í•˜ê±°ë‚˜ ìƒì„¸ ì •ë³´ í‘œì‹œ
            console.log('í´ë¦­ëœ ì†ì„±:', item);
            
            // ì†ì„± ê²€ìƒ‰ í˜ì´ì§€ë¡œ ì´ë™í•˜ê±°ë‚˜ ìƒì„¸ ì •ë³´ í‘œì‹œ
            if (item.attributeBitMax && item.attributeBitMin) {
                window.location.href = `bit_search.html?attribute=${encodeURIComponent(item.attribute)}&bitMax=${item.attributeBitMax}&bitMin=${item.attributeBitMin}`;
            }
        };


        // ëª¨ë“  ì†ì„± ì €ì¥ (ìë™ ì €ì¥)
        async function saveAllAttributes() {
            if (extractedAttributesList.length === 0) {
                return;
            }

            try {
                let successCount = 0;
                let duplicateCount = 0;
                let errorCount = 0;

                // ê° ì†ì„±ë³„ë¡œ ì €ì¥
                for (let idx = 0; idx < extractedAttributesList.length; idx++) {
                    const item = extractedAttributesList[idx];
                    
                    // ì €ì¥ ì¤‘ ìƒíƒœë¡œ í‘œì‹œ
                    item.saveStatus = 'saving';
                    item.saveMessage = 'ì €ì¥ ì¤‘...';
                    displayExtractedAttributes();
                    
                    try {
                        // BIT ê°’ ê²€ì¦
                        if (item.attributeBitMax === null || item.attributeBitMin === null || 
                            item.dataBitMax === null || item.dataBitMin === null) {
                            item.saveStatus = 'error';
                            item.saveMessage = 'BIT ê°’ ê³„ì‚° ì‹¤íŒ¨';
                            errorCount++;
                            displayExtractedAttributes();
                            continue;
                        }

                        const url = getServerUrl('/api/attributes/data');
                        const res = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                attributeBitMax: item.attributeBitMax,
                                attributeBitMin: item.attributeBitMin,
                                attributeText: item.attribute,
                                text: item.data,
                                dataBitMax: item.dataBitMax,
                                dataBitMin: item.dataBitMin
                            })
                        });

                        if (!res.ok) {
                            throw new Error(`HTTP ${res.status}`);
                        }

                        const data = await res.json();
                        if (data.ok) {
                            if (data.duplicate) {
                                duplicateCount++;
                                item.saveStatus = 'duplicate';
                                item.saveMessage = data.message || 'ì´ë¯¸ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.';
                            } else {
                                successCount++;
                                item.saveStatus = 'success';
                                item.saveMessage = 'ì €ì¥ ì™„ë£Œ';
                            }
                        } else {
                            throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
                        }
                    } catch (e) {
                        console.error(`ì†ì„± "${item.attribute}" ì €ì¥ ì˜¤ë¥˜:`, e);
                        errorCount++;
                        item.saveStatus = 'error';
                        item.saveMessage = e.message || 'ì €ì¥ ì‹¤íŒ¨';
                    }
                    
                    // ê° í•­ëª© ì €ì¥ í›„ ì¦‰ì‹œ í™”ë©´ ì—…ë°ì´íŠ¸
                    displayExtractedAttributes();
                }

                // ì „ì²´ ì €ì¥ ì™„ë£Œ ìƒíƒœ ì—…ë°ì´íŠ¸
                $gptStatus.textContent = `âœ“ ì €ì¥ ì™„ë£Œ: ì„±ê³µ ${successCount}ê°œ, ì¤‘ë³µ ${duplicateCount}ê°œ, ì‹¤íŒ¨ ${errorCount}ê°œ`;
                $gptStatus.style.color = '#28a745';
                
                // ì†ì„± ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                setTimeout(() => {
                    loadAttributes();
                }, 500);
            } catch (e) {
                console.error('ì €ì¥ ì˜¤ë¥˜:', e);
                $gptStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
                $gptStatus.style.color = '#dc3545';
            }
        }

        // GPT ë¶„ì„ ë²„íŠ¼ ì´ë²¤íŠ¸
        $analyzeBtn.addEventListener('click', analyzeWithGPT);


        // ë°ì´í„° ì…ë ¥ ì‹œ BIT ê³„ì‚°
        $newDataInput.addEventListener('input', (e) => {
            const text = e.target.value.trim();
            if (text) {
                const { max, min } = calculateBitValues(text);
                $newDataMax.textContent = max !== null ? max.toFixed(10) : '-';
                $newDataMin.textContent = min !== null ? min.toFixed(10) : '-';
            } else {
                $newDataMax.textContent = '-';
                $newDataMin.textContent = '-';
            }
        });

        // ì†ì„± ëª©ë¡ ë¡œë“œ
        async function loadAttributes() {
            try {
                $attributesList.innerHTML = '<div class="text-center text-muted">ë¡œë”© ì¤‘...</div>';
                
                // ëª¨ë“  ì†ì„± ëª©ë¡ ì¡°íšŒ
                const url = getServerUrl('/api/attributes/all');
                const res = await fetch(url);

                if (!res.ok) {
                    throw new Error(`HTTP ${res.status}`);
                }

                const data = await res.json();
                
                if (!data.ok || !data.attributes || data.attributes.length === 0) {
                    $attributesList.innerHTML = '<div class="text-center text-muted">ì €ì¥ëœ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
                    return;
                }

                // ê° ì†ì„±ì˜ ë°ì´í„° ì¡°íšŒ
                const attributePromises = data.attributes.map(async (attr) => {
                    try {
                        const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${attr.bitMax}&bitMin=${attr.bitMin}&limit=100`);
                        const dataRes = await fetch(dataUrl);
                        if (dataRes.ok) {
                            const dataData = await dataRes.json();
                            if (dataData.ok && dataData.items) {
                                // ì†ì„± ìì²´ë¥¼ ë°ì´í„°ë¡œ ì €ì¥í•œ ê²½ìš°ëŠ” ì œì™¸
                                const dataList = dataData.items
                                    .filter(item => item.data && item.data.text && item.data.text !== attr.text)
                                    .map(item => item.data);
                                return {
                                    ...attr,
                                    dataList: dataList,
                                    dataCount: dataList.length
                                };
                            }
                        }
                    } catch (e) {
                        console.warn(`ì†ì„± "${attr.text}" ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:`, e);
                    }
                    return {
                        ...attr,
                        dataList: [],
                        dataCount: 0
                    };
                });

                const attributesWithData = await Promise.all(attributePromises);

                // ì†ì„± ëª©ë¡ ë Œë”ë§
                let html = '';
                attributesWithData.forEach((attr) => {
                    html += `
                        <div class="attribute-item">
                            <div class="attribute-header">
                                <div>
                                    <span class="attribute-name">${escapeHtml(attr.text)}</span>
                                </div>
                                <small class="text-muted">
                                    BIT: ${attr.bitMax.toFixed(6)}, ${attr.bitMin.toFixed(6)} | 
                                    ë°ì´í„° ${attr.dataCount}ê°œ
                                </small>
                            </div>
                            <div class="data-list">
                                ${attr.dataList.length > 0 ? attr.dataList.map(data => `
                                    <div class="data-item">
                                        <strong>${escapeHtml(data.text)}</strong>
                                        <small class="text-muted ms-2">
                                            BIT: ${data.bitMax.toFixed(6)}, ${data.bitMin.toFixed(6)}
                                        </small>
                                    </div>
                                `).join('') : '<div class="text-muted small">ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>'}
                            </div>
                        </div>
                    `;
                });

                $attributesList.innerHTML = html;
            } catch (e) {
                console.error('ì†ì„± ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜:', e);
                $attributesList.innerHTML = `<div class="text-danger">âœ— ë¡œë“œ ì‹¤íŒ¨: ${e.message}</div>`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ë°ì´í„° ì¶”ê°€ ëª¨ë‹¬ ì—´ê¸°
        window.openAddDataModal = function(attributeText, attributeBitMax, attributeBitMin) {
            currentAttribute = {
                text: attributeText,
                bitMax: attributeBitMax,
                bitMin: attributeBitMin
            };
            
            $modalAttributeName.textContent = attributeText;
            $modalAttributeMax.textContent = attributeBitMax.toFixed(10);
            $modalAttributeMin.textContent = attributeBitMin.toFixed(10);
            $newDataInput.value = '';
            $newDataMax.textContent = '-';
            $newDataMin.textContent = '-';
            $saveDataStatus.textContent = '';
            
            addDataModal.show();
        };

        // ë°ì´í„° ì €ì¥
        $saveDataBtn.addEventListener('click', async () => {
            if (!currentAttribute) {
                $saveDataStatus.textContent = 'âœ— ì†ì„± ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            const dataText = $newDataInput.value.trim();
            if (!dataText) {
                $saveDataStatus.textContent = 'âœ— ë°ì´í„°ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            const { max, min } = calculateBitValues(dataText);
            if (max === null || min === null) {
                $saveDataStatus.textContent = 'âœ— BIT ê°’ ê³„ì‚° ì‹¤íŒ¨.';
                $saveDataStatus.style.color = '#dc3545';
                return;
            }

            try {
                $saveDataBtn.disabled = true;
                $saveDataStatus.textContent = 'ì €ì¥ ì¤‘...';
                $saveDataStatus.style.color = '#007bff';

                const url = getServerUrl('/api/attributes/data');
                const res = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        attributeText: currentAttribute.text,
                        attributeBitMax: currentAttribute.bitMax,
                        attributeBitMin: currentAttribute.bitMin,
                        text: dataText,
                        dataBitMax: max,
                        dataBitMin: min
                    })
                });

                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`HTTP ${res.status}: ${errorText}`);
                }

                const data = await res.json();
                
                if (!data.ok) {
                    throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
                }

                if (data.duplicate) {
                    $saveDataStatus.textContent = 'âš  ì´ë¯¸ ë™ì¼í•œ ë°ì´í„°ê°€ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.';
                    $saveDataStatus.style.color = '#ffc107';
                } else {
                    $saveDataStatus.textContent = 'âœ“ ë°ì´í„° ì €ì¥ ì™„ë£Œ';
                    $saveDataStatus.style.color = '#28a745';
                    $newDataInput.value = '';
                    $newDataMax.textContent = '-';
                    $newDataMin.textContent = '-';
                    
                    setTimeout(() => {
                        addDataModal.hide();
                        loadAttributes();
                    }, 1000);
                }
            } catch (e) {
                console.error('ë°ì´í„° ì €ì¥ ì˜¤ë¥˜:', e);
                $saveDataStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
                $saveDataStatus.style.color = '#dc3545';
            } finally {
                $saveDataBtn.disabled = false;
            }
        });

        // ì†ì„±ìœ¼ë¡œ ê²€ìƒ‰
        window.searchByAttribute = function(attributeText, attributeBitMax, attributeBitMin) {
            window.location.href = `bit_search.html?attribute=${encodeURIComponent(attributeText)}&bitMax=${attributeBitMax}&bitMin=${attributeBitMin}`;
        };

        // ìƒˆë¡œê³ ì¹¨
        $refreshBtn.addEventListener('click', () => {
            loadAttributes();
        });

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì†ì„± ëª©ë¡ ë¡œë“œ
        loadAttributes();
    </script>
</body>
</html>

