<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>BIT ê°’ ì†ì„± ê²€ìƒ‰</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://xn--9l4b4xi9r.com/_8%EB%B9%84%ED%8A%B8/js/bitCalculation.js" defer></script>
</head>
<body>
    <div class="container py-4">
        <h2 class="mb-4">ğŸ” BIT ê°’ ì†ì„± ê²€ìƒ‰</h2>
        
        <!-- ì†ì„±ë³„ ë°ì´í„° ì €ì¥ -->
        <div class="card mb-4">
            <div class="card-header"><strong>ì†ì„±ë³„ ë°ì´í„° ì €ì¥</strong></div>
            <div class="card-body">
                <div class="mb-3">
                    <label class="form-label"><strong>1ë‹¨ê³„: ì†ì„± (ë¬¸ì ì…ë ¥)</strong></label>
                    <textarea id="attributeInput" class="form-control" placeholder="ì†ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”. ìë™ìœ¼ë¡œ BIT ê°’ìœ¼ë¡œ ë³€í™˜ë˜ì–´ ì†ì„±ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤." rows="3"></textarea>
                    <div class="row g-3 mt-2 mb-2">
                        <div class="col-md-6">
                            <label class="form-label">ê³„ì‚°ëœ ì†ì„± BIT MAX</label>
                            <input type="number" id="attributeBitMax" class="form-control" readonly />
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">ê³„ì‚°ëœ ì†ì„± BIT MIN</label>
                            <input type="number" id="attributeBitMin" class="form-control" readonly />
                        </div>
                    </div>
                    <div class="d-flex gap-2 mb-2">
                        <button id="loadAttributeBtn" class="btn btn-sm btn-outline-secondary">ì†ì„±ìœ¼ë¡œ ì €ì¥ëœ ë°ì´í„° ë¡œë“œ</button>
                        <button id="copyToAttributeBtn" class="btn btn-sm btn-outline-info">ê²€ìƒ‰ ê²°ê³¼ì—ì„œ ì†ì„± ë³µì‚¬</button>
                    </div>
                </div>
                
                <div class="mb-3 border-top pt-3">
                    <label class="form-label"><strong>2ë‹¨ê³„: ë°ì´í„° (ë¬¸ì ì…ë ¥)</strong></label>
                    <textarea id="textInput" class="form-control" placeholder="ì´ ì†ì„±ì— ì €ì¥í•  ë°ì´í„°(í…ìŠ¤íŠ¸)ë¥¼ ì…ë ¥í•˜ì„¸ìš”." rows="4"></textarea>
                    <div class="row g-3 mt-2">
                        <div class="col-md-6">
                            <label class="form-label">ê³„ì‚°ëœ BIT MAX</label>
                            <input type="number" id="calculatedBitMax" class="form-control" readonly />
                        </div>
                        <div class="col-md-6">
                            <label class="form-label">ê³„ì‚°ëœ BIT MIN</label>
                            <input type="number" id="calculatedBitMin" class="form-control" readonly />
                        </div>
                    </div>
                </div>
                
                <div class="mb-3">
                    <button id="saveBtn" class="btn btn-success">ì†ì„±ì— ë°ì´í„° ì €ì¥</button>
                    <span id="saveStatus" class="ms-2 small text-muted"></span>
                </div>
                
                <div id="attributeDataList" class="mt-3 border-top pt-3" style="display: none;">
                    <strong>ì´ ì†ì„±ì— ì €ì¥ëœ ë°ì´í„° ëª©ë¡:</strong>
                    <div id="attributeDataItems" class="mt-2"></div>
                </div>
            </div>
        </div>
        
        <!-- ê²€ìƒ‰ ì¡°ê±´ -->
        <div class="card mb-4">
            <div class="card-header"><strong>ê²€ìƒ‰ ì¡°ê±´ (ë¬¸ìì—´ ê¸°ë°˜)</strong></div>
            <div class="card-body">
                <div class="mb-3">
                    <label for="searchTextInput" class="form-label">ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ ì…ë ¥</label>
                    <textarea id="searchTextInput" class="form-control" placeholder="ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”. ìë™ìœ¼ë¡œ BIT ê°’ìœ¼ë¡œ ë³€í™˜ë˜ì–´ ê²€ìƒ‰ë©ë‹ˆë‹¤." rows="3"></textarea>
                </div>
                <div class="row g-3 mb-3">
                    <div class="col-md-4">
                        <label for="bitMaxInput" class="form-label">ê³„ì‚°ëœ BIT MAX</label>
                        <input type="number" id="bitMaxInput" class="form-control" readonly />
                    </div>
                    <div class="col-md-4">
                        <label for="bitMinInput" class="form-label">ê³„ì‚°ëœ BIT MIN</label>
                        <input type="number" id="bitMinInput" class="form-control" readonly />
                    </div>
                    <div class="col-md-4">
                        <label class="form-label">&nbsp;</label>
                        <div class="d-grid">
                            <button id="searchBtn" class="btn btn-primary">ê²€ìƒ‰</button>
                        </div>
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-12">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="useSimilarity" checked />
                            <label class="form-check-label" for="useSimilarity">
                                ìœ ì‚¬ë„ ê²€ìƒ‰ ì‚¬ìš© (ì •í™• ì¼ì¹˜ê°€ ì•„ë‹Œ ìœ ì‚¬í•œ ê°’ë„ ê²€ìƒ‰)
                            </label>
                        </div>
                        <div class="form-check mt-2">
                            <input class="form-check-input" type="checkbox" id="searchByMaxOnly" />
                            <label class="form-check-label" for="searchByMaxOnly">
                                MAX ê°’ë§Œìœ¼ë¡œ ê²€ìƒ‰ (MIN ë¬´ì‹œ)
                            </label>
                        </div>
                        <div class="form-check mt-2">
                            <input class="form-check-input" type="checkbox" id="searchByMinOnly" />
                            <label class="form-check-label" for="searchByMinOnly">
                                MIN ê°’ë§Œìœ¼ë¡œ ê²€ìƒ‰ (MAX ë¬´ì‹œ)
                            </label>
                        </div>
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-md-6">
                        <label for="limitInput" class="form-label">ê²€ìƒ‰ ê²°ê³¼ ê°œìˆ˜ ì œí•œ</label>
                        <input type="number" id="limitInput" class="form-control" value="10" min="1" max="100" />
                    </div>
                </div>
            </div>
        </div>

        <!-- ìƒìœ„ ì†ì„± ê´€ë¦¬ -->
        <div class="card mb-4">
            <div class="card-header"><strong>ğŸŒ ìƒìœ„ ì†ì„± ê´€ë¦¬ (ë²Œì§‘ êµ¬ì¡°)</strong></div>
            <div class="card-body">
                <div class="mb-3">
                    <button id="detectClustersBtn" class="btn btn-primary me-2">í´ëŸ¬ìŠ¤í„° ìë™ ê°ì§€</button>
                    <button id="loadParentsBtn" class="btn btn-outline-secondary">ìƒìœ„ ì†ì„± ëª©ë¡ ë³´ê¸°</button>
                </div>
                <div id="clusterStatus" class="small text-muted mb-2"></div>
                <div id="clustersList" class="mt-3"></div>
                <div id="parentsList" class="mt-3" style="display: none;">
                    <h6>ìƒì„±ëœ ìƒìœ„ ì†ì„±:</h6>
                    <div id="parentsItems"></div>
                </div>
            </div>
        </div>

        <!-- ê²€ìƒ‰ ê²°ê³¼ -->
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <strong>ê²€ìƒ‰ ê²°ê³¼</strong>
                <span id="resultCount" class="badge bg-secondary">ê²°ê³¼ ì—†ìŒ</span>
            </div>
            <div class="card-body">
                <div id="searchStatus" class="small text-muted mb-2"></div>
                <div class="table-responsive" style="max-height: 600px; overflow-y: auto;">
                    <table class="table table-sm table-bordered table-striped">
                        <thead class="table-light sticky-top" style="background-color: #f8f9fa;">
                            <tr>
                                <th style="width: 5%;">#</th>
                                <th style="width: 12%;">ì‹œê°„</th>
                                <th style="width: 10%;">BIT_MAX</th>
                                <th style="width: 10%;">BIT_MIN</th>
                                <th style="width: 25%;">ì…ë ¥</th>
                                <th style="width: 28%;">ì‘ë‹µ/ë°ì´í„°</th>
                                <th style="width: 10%;">ìœ ì‚¬ë„</th>
                            </tr>
                        </thead>
                        <tbody id="resultBody"></tbody>
                    </table>
                </div>
                <div id="resultInfo" class="small text-muted mt-2"></div>
            </div>
        </div>
    </div>

    <script>
    (function(){
      // ì…ë ¥ ë° ì €ì¥ ê´€ë ¨
      const $textInput = document.getElementById('textInput');
      const $calculatedBitMax = document.getElementById('calculatedBitMax');
      const $calculatedBitMin = document.getElementById('calculatedBitMin');
      const $saveBtn = document.getElementById('saveBtn');
      const $saveStatus = document.getElementById('saveStatus');
      const $attributeInput = document.getElementById('attributeInput');
      const $attributeBitMax = document.getElementById('attributeBitMax');
      const $attributeBitMin = document.getElementById('attributeBitMin');
      const $loadAttributeBtn = document.getElementById('loadAttributeBtn');
      const $copyToAttributeBtn = document.getElementById('copyToAttributeBtn');
      const $attributeDataList = document.getElementById('attributeDataList');
      const $attributeDataItems = document.getElementById('attributeDataItems');
      
      // ê²€ìƒ‰ ê´€ë ¨
      const $searchTextInput = document.getElementById('searchTextInput');
      const $bitMax = document.getElementById('bitMaxInput');
      const $bitMin = document.getElementById('bitMinInput');
      const $searchBtn = document.getElementById('searchBtn');
      const $useSimilarity = document.getElementById('useSimilarity');
      const $searchByMaxOnly = document.getElementById('searchByMaxOnly');
      const $searchByMinOnly = document.getElementById('searchByMinOnly');
      const $limit = document.getElementById('limitInput');
      const $resultBody = document.getElementById('resultBody');
      const $resultCount = document.getElementById('resultCount');
      const       $resultInfo = document.getElementById('resultInfo');
      const $searchStatus = document.getElementById('searchStatus');
      
      // ìƒìœ„ ì†ì„± ê´€ë¦¬ ê´€ë ¨
      const $detectClustersBtn = document.getElementById('detectClustersBtn');
      const $loadParentsBtn = document.getElementById('loadParentsBtn');
      const $clusterStatus = document.getElementById('clusterStatus');
      const $clustersList = document.getElementById('clustersList');
      const $parentsList = document.getElementById('parentsList');
      const $parentsItems = document.getElementById('parentsItems');

      function getServerUrl(path) {
        if (window.location.protocol === 'file:') {
          return `http://localhost:8123${path}`;
        }
        return path;
      }

      // ì„œë²„ ì—°ê²° í…ŒìŠ¤íŠ¸
      async function testServerConnection() {
        try {
          const res = await fetch(getServerUrl('/health'));
          if (res.ok) {
            return true;
          }
        } catch (e) {
          return false;
        }
        return false;
      }

      // BIT ê°’ ê³„ì‚°
      function calculateBitValues(text) {
        try {
          const arr = (window.wordNbUnicodeFormat || wordNbUnicodeFormat)(text || '');
          if (arr.length === 0) {
            $calculatedBitMax.value = '';
            $calculatedBitMin.value = '';
            return { max: null, min: null };
          }
          const bitMax = (window.BIT_MAX_NB || (()=>0))(arr);
          const bitMin = (window.BIT_MIN_NB || (()=>0))(arr);
          $calculatedBitMax.value = bitMax;
          $calculatedBitMin.value = bitMin;
          return { max: bitMax, min: bitMin };
        } catch (e) {
          console.error('BIT ê³„ì‚° ì˜¤ë¥˜:', e);
          $calculatedBitMax.value = '';
          $calculatedBitMin.value = '';
          return { max: null, min: null };
        }
      }

      // ì†ì„± ì…ë ¥ë€ ë³€ê²½ ì‹œ BIT ê°’ ê³„ì‚°
      $attributeInput.addEventListener('input', () => {
        const text = $attributeInput.value.trim();
        if (text) {
          const bitValues = calculateBitValues(text);
          $attributeBitMax.value = bitValues.max || '';
          $attributeBitMin.value = bitValues.min || '';
        } else {
          $attributeBitMax.value = '';
          $attributeBitMin.value = '';
        }
      });

      // ë°ì´í„° ì…ë ¥ë€ ë³€ê²½ ì‹œ BIT ê°’ ê³„ì‚°
      $textInput.addEventListener('input', () => {
        const text = $textInput.value.trim();
        if (text) {
          calculateBitValues(text);
        } else {
          $calculatedBitMax.value = '';
          $calculatedBitMin.value = '';
        }
      });

      // ì†ì„±ë³„ ë°ì´í„° ë¡œë“œ
      async function loadAttributeData() {
        const attributeText = $attributeInput.value.trim();
        if (!attributeText) {
          $saveStatus.textContent = 'ì†ì„± í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
          $saveStatus.style.color = '#dc3545';
          return;
        }
        
        const bitValues = calculateBitValues(attributeText);
        const attrMax = bitValues.max;
        const attrMin = bitValues.min;
        
        if (attrMax === null || attrMin === null) {
          $saveStatus.textContent = 'ì†ì„± BIT ê°’ ê³„ì‚° ì‹¤íŒ¨.';
          $saveStatus.style.color = '#dc3545';
          return;
        }
        
        try {
          const res = await fetch(getServerUrl(`/api/attributes/data?bitMax=${attrMax}&bitMin=${attrMin}`));
          const data = await res.json();
          
          if (data.ok) {
            if (data.items && data.items.length > 0) {
              $attributeDataList.style.display = 'block';
              $attributeDataItems.innerHTML = '';
              
              data.items.forEach((item, idx) => {
                const div = document.createElement('div');
                div.className = 'border rounded p-2 mb-2';
                const attributeInfo = item.attribute && item.attribute.text 
                  ? `<small class="text-primary">ì†ì„±: "${item.attribute.text.substring(0, 30)}${item.attribute.text.length > 30 ? '...' : ''}"</small><br>`
                  : '';
                div.innerHTML = `
                  <div class="d-flex justify-content-between">
                    <small class="text-muted">#${idx + 1} - ${new Date(item.t).toLocaleString('ko-KR')}</small>
                  </div>
                  ${attributeInfo}
                  <div class="mt-1"><strong>ë°ì´í„°:</strong> ${item.data.text || ''}</div>
                `;
                $attributeDataItems.appendChild(div);
              });
            } else {
              $attributeDataList.style.display = 'block';
              $attributeDataItems.innerHTML = '<div class="text-muted">ì´ ì†ì„±ì— ì €ì¥ëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            }
          }
        } catch (e) {
          console.error('ì†ì„± ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', e);
        }
      }

      // ì†ì„±ì— ë°ì´í„° ì €ì¥
      async function saveData() {
        const attributeText = $attributeInput.value.trim();
        if (!attributeText) {
          $saveStatus.textContent = 'ì†ì„± í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ì…ë ¥í•˜ì„¸ìš”.';
          $saveStatus.style.color = '#dc3545';
          return;
        }
        
        const text = $textInput.value.trim();
        if (!text) {
          $saveStatus.textContent = 'ì €ì¥í•  ë°ì´í„° í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
          $saveStatus.style.color = '#dc3545';
          return;
        }
        
        // ì†ì„± BIT ê°’ ê³„ì‚°
        const attributeBitValues = calculateBitValues(attributeText);
        const attrMax = attributeBitValues.max;
        const attrMin = attributeBitValues.min;
        
        if (attrMax === null || attrMin === null) {
          $saveStatus.textContent = 'ì†ì„± BIT ê°’ ê³„ì‚° ì‹¤íŒ¨.';
          $saveStatus.style.color = '#dc3545';
          return;
        }

        const bitValues = calculateBitValues(text);
        if (bitValues.max === null || bitValues.min === null) {
          $saveStatus.textContent = 'BIT ê°’ ê³„ì‚° ì‹¤íŒ¨.';
          $saveStatus.style.color = '#dc3545';
          return;
        }

        try {
          $saveBtn.disabled = true;
          $saveStatus.textContent = 'ì €ì¥ ì¤‘...';
          $saveStatus.style.color = '#007bff';

          // ì†ì„±ë³„ ë°ì´í„° ì €ì¥ API ì‚¬ìš©
          const url = getServerUrl('/api/attributes/data');
          const requestBody = {
            attributeBitMax: attrMax,
            attributeBitMin: attrMin,
            attributeText: attributeText, // ì†ì„± í…ìŠ¤íŠ¸ë„ í•¨ê»˜ ì €ì¥
            text: text,
            dataBitMax: bitValues.max,
            dataBitMin: bitValues.min
          };
          
          console.log('[Save] ì†ì„± ë°ì´í„° ì €ì¥ ìš”ì²­:', { url, body: requestBody });
          
          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
          });
          
          console.log('[Save] ì‘ë‹µ ìƒíƒœ:', res.status, res.statusText);
          
          if (!res.ok) {
            const text = await res.text();
            let errorMsg = `HTTP ${res.status}: ${res.statusText}`;
            try {
              const json = JSON.parse(text);
              if (json.error) errorMsg = json.error;
            } catch {}
            throw new Error(errorMsg);
          }
          
          const contentType = res.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            const text = await res.text();
            throw new Error(`ì„œë²„ê°€ JSON ëŒ€ì‹  ë‹¤ë¥¸ í˜•ì‹ì„ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤. Content-Type: ${contentType || 'ì—†ìŒ'}. ì‘ë‹µ ì‹œì‘: ${text.substring(0, 100)}`);
          }
          
          const data = await res.json();
          if (data.ok) {
            if (data.duplicate) {
              $saveStatus.textContent = `âš  ${data.message || 'ì´ë¯¸ ë™ì¼í•œ ì†ì„±-ë°ì´í„° ì¡°í•©ì´ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.'}`;
              $saveStatus.style.color = '#ffc107';
            } else {
              $saveStatus.textContent = `âœ“ ì €ì¥ ì™„ë£Œ! ì†ì„± "${attributeText.substring(0, 20)}${attributeText.length > 20 ? '...' : ''}" (BIT: ${attrMax}, ${attrMin})ì— ë°ì´í„° ì¶”ê°€ë¨`;
              $saveStatus.style.color = '#28a745';
            }
            $textInput.value = ''; // ë°ì´í„° ì…ë ¥ë€ ì´ˆê¸°í™”
            $calculatedBitMax.value = '';
            $calculatedBitMin.value = '';
            
            // ì†ì„± ë°ì´í„° ëª©ë¡ ìƒˆë¡œê³ ì¹¨
            await loadAttributeData();
          } else {
            $saveStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${data.error || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`;
            $saveStatus.style.color = '#dc3545';
          }
        } catch (e) {
          $saveStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
          $saveStatus.style.color = '#dc3545';
        } finally {
          $saveBtn.disabled = false;
        }
      }
      
      $loadAttributeBtn.addEventListener('click', loadAttributeData);
      
      // ê²€ìƒ‰ ê²°ê³¼ì—ì„œ ì†ì„± ê°’ ë³µì‚¬ (ê²€ìƒ‰ ê²°ê³¼ì˜ í…ìŠ¤íŠ¸ë¥¼ ì†ì„±ìœ¼ë¡œ ì‚¬ìš©)
      $copyToAttributeBtn.addEventListener('click', () => {
        // ê²€ìƒ‰ ê²°ê³¼ì—ì„œ ì²« ë²ˆì§¸ ê²°ê³¼ì˜ ì…ë ¥ í…ìŠ¤íŠ¸ë¥¼ ì†ì„±ìœ¼ë¡œ ì‚¬ìš©
        const firstResult = document.querySelector('#resultBody tr:first-child td:nth-child(5)');
        if (firstResult && firstResult.textContent.trim()) {
          const resultText = firstResult.textContent.trim();
          $attributeInput.value = resultText;
          // ì†ì„± BIT ê°’ ìë™ ê³„ì‚°
          const bitValues = calculateBitValues(resultText);
          $attributeBitMax.value = bitValues.max || '';
          $attributeBitMin.value = bitValues.min || '';
          $saveStatus.textContent = 'ê²€ìƒ‰ ê²°ê³¼ì—ì„œ ì†ì„±ì´ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.';
          $saveStatus.style.color = '#007bff';
          loadAttributeData(); // ìë™ìœ¼ë¡œ ë°ì´í„° ë¡œë“œ
        } else if ($searchTextInput.value.trim()) {
          // ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ì†ì„±ìœ¼ë¡œ ì‚¬ìš©
          const searchText = $searchTextInput.value.trim();
          $attributeInput.value = searchText;
          const bitValues = calculateBitValues(searchText);
          $attributeBitMax.value = bitValues.max || '';
          $attributeBitMin.value = bitValues.min || '';
          $saveStatus.textContent = 'ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ì†ì„±ìœ¼ë¡œ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.';
          $saveStatus.style.color = '#007bff';
          loadAttributeData(); // ìë™ìœ¼ë¡œ ë°ì´í„° ë¡œë“œ
        } else {
          $saveStatus.textContent = 'ë¨¼ì € ê²€ìƒ‰ì„ ì‹¤í–‰í•˜ì—¬ ê²°ê³¼ë¥¼ ì°¾ìœ¼ì„¸ìš”.';
          $saveStatus.style.color = '#dc3545';
        }
      });

      $saveBtn.addEventListener('click', saveData);

      // ì—”í„°í‚¤ë¡œ ì €ì¥ (Shift+EnterëŠ” ì¤„ë°”ê¿ˆ)
      $textInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          saveData();
        }
      });

      // ê²€ìƒ‰ í…ìŠ¤íŠ¸ ì…ë ¥ ì‹œ BIT ê°’ ê³„ì‚°
      $searchTextInput.addEventListener('input', () => {
        const text = $searchTextInput.value.trim();
        if (text) {
          const bitValues = calculateBitValues(text);
          $bitMax.value = bitValues.max || '';
          $bitMin.value = bitValues.min || '';
        } else {
          $bitMax.value = '';
          $bitMin.value = '';
        }
      });

      async function search() {
        const searchText = $searchTextInput.value.trim();
        let bitMax, bitMin;
        
        // í…ìŠ¤íŠ¸ ì…ë ¥ì´ ìˆìœ¼ë©´ BIT ê°’ ê³„ì‚°
        if (searchText) {
          const bitValues = calculateBitValues(searchText);
          bitMax = bitValues.max;
          bitMin = bitValues.min;
          
          if (bitMax === null || bitMin === null) {
            $searchStatus.textContent = 'BIT ê°’ ê³„ì‚° ì‹¤íŒ¨.';
            $searchStatus.style.color = '#dc3545';
            return;
          }
        } else {
          // í…ìŠ¤íŠ¸ê°€ ì—†ìœ¼ë©´ ì§ì ‘ ì…ë ¥ëœ BIT ê°’ ì‚¬ìš© (í•˜ìœ„ í˜¸í™˜ì„±)
          bitMax = $bitMax.value.trim() ? Number($bitMax.value) : undefined;
          bitMin = $bitMin.value.trim() ? Number($bitMin.value) : undefined;
        }
        
        const useSimilar = $useSimilarity.checked;
        const maxOnly = $searchByMaxOnly.checked;
        const minOnly = $searchByMinOnly.checked;
        const limit = Number($limit.value) || 10;

        // ê²€ì¦
        if (!useSimilar && bitMax === undefined && bitMin === undefined) {
          $searchStatus.textContent = 'ê²€ìƒ‰í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
          $searchStatus.style.color = '#dc3545';
          return;
        }

        try {
          $searchBtn.disabled = true;
          $searchStatus.textContent = 'ì„œë²„ ì—°ê²° í™•ì¸ ì¤‘...';
          $searchStatus.style.color = '#007bff';
          
          // ì„œë²„ ì—°ê²° í™•ì¸
          const isConnected = await testServerConnection();
          if (!isConnected) {
            throw new Error('ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ê°€ http://localhost:8123 ì—ì„œ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.');
          }
          
          $searchStatus.textContent = 'ê²€ìƒ‰ ì¤‘...';
          $resultBody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">ê²€ìƒ‰ ì¤‘...</td></tr>';

          let results = [];

          if (useSimilar) {
            // ìœ ì‚¬ë„ ê²€ìƒ‰ (training ë°ì´í„° ì‚¬ìš©)
            try {
              const url = getServerUrl('/api/training/similar');
              const requestBody = {
                query: '', // í…ìŠ¤íŠ¸ ì¿¼ë¦¬ëŠ” ë¹„ìš°ê³  BIT ê°’ë§Œ ì‚¬ìš©
                queryBitMax: maxOnly ? bitMax : (minOnly ? undefined : bitMax),
                queryBitMin: minOnly ? bitMin : (maxOnly ? undefined : bitMin),
                limit: limit
              };
              
              console.log('[Search] ìœ ì‚¬ë„ ê²€ìƒ‰ ìš”ì²­:', { url, body: requestBody });
              
              const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
              });
              
              console.log('[Search] ì‘ë‹µ ìƒíƒœ:', res.status, res.statusText, 'URL:', res.url);
              
              if (!res.ok) {
                const text = await res.text();
                let errorMsg = `HTTP ${res.status}: ${res.statusText}`;
                try {
                  const json = JSON.parse(text);
                  if (json.error) errorMsg = json.error;
                } catch {}
                throw new Error(errorMsg);
              }
              
              const contentType = res.headers.get('content-type');
              if (!contentType || !contentType.includes('application/json')) {
                const text = await res.text();
                throw new Error(`ì„œë²„ê°€ JSON ëŒ€ì‹  ë‹¤ë¥¸ í˜•ì‹ì„ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤. Content-Type: ${contentType || 'ì—†ìŒ'}. ì‘ë‹µ ì‹œì‘: ${text.substring(0, 100)}`);
              }
              
              const data = await res.json();
              if (data.ok && data.items) {
                results = data.items.map(item => ({
                  ...item,
                  source: 'training',
                  similarity: item.similarity_score || 0
                }));
              } else if (!data.ok) {
                throw new Error(data.error || 'ê²€ìƒ‰ ì‹¤íŒ¨');
              }
            } catch (e) {
              throw new Error(`ìœ ì‚¬ë„ ê²€ìƒ‰ ì˜¤ë¥˜: ${e.message}`);
            }
          } else {
            // ì •í™• ì¼ì¹˜ ê²€ìƒ‰
            if (bitMax !== undefined && !minOnly) {
              try {
                const res = await fetch(getServerUrl(`/api/log/by-max?nb_max=${bitMax}&n=${limit}`));
                
                if (!res.ok) {
                  const text = await res.text();
                  let errorMsg = `HTTP ${res.status}: ${res.statusText}`;
                  try {
                    const json = JSON.parse(text);
                    if (json.error) errorMsg = json.error;
                  } catch {}
                  throw new Error(errorMsg);
                }
                
                const contentType = res.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                  const text = await res.text();
                  throw new Error(`ì„œë²„ê°€ JSON ëŒ€ì‹  ë‹¤ë¥¸ í˜•ì‹ì„ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤. Content-Type: ${contentType || 'ì—†ìŒ'}. ì‘ë‹µ ì‹œì‘: ${text.substring(0, 100)}`);
                }
                
                const data = await res.json();
                if (data.ok && data.items) {
                  results.push(...data.items.map(item => ({
                    ...item,
                    source: 'log_max',
                    similarity: 1.0 // ì •í™• ì¼ì¹˜
                  })));
                }
              } catch (e) {
                throw new Error(`BIT MAX ê²€ìƒ‰ ì˜¤ë¥˜: ${e.message}`);
              }
            }
            if (bitMin !== undefined && !maxOnly) {
              try {
                const res = await fetch(getServerUrl(`/api/log/by-min?nb_min=${bitMin}&n=${limit}`));
                
                if (!res.ok) {
                  const text = await res.text();
                  let errorMsg = `HTTP ${res.status}: ${res.statusText}`;
                  try {
                    const json = JSON.parse(text);
                    if (json.error) errorMsg = json.error;
                  } catch {}
                  throw new Error(errorMsg);
                }
                
                const contentType = res.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                  const text = await res.text();
                  throw new Error(`ì„œë²„ê°€ JSON ëŒ€ì‹  ë‹¤ë¥¸ í˜•ì‹ì„ ë°˜í™˜í–ˆìŠµë‹ˆë‹¤. Content-Type: ${contentType || 'ì—†ìŒ'}. ì‘ë‹µ ì‹œì‘: ${text.substring(0, 100)}`);
                }
                
                const data = await res.json();
                if (data.ok && data.items) {
                  results.push(...data.items.map(item => ({
                    ...item,
                    source: 'log_min',
                    similarity: 1.0 // ì •í™• ì¼ì¹˜
                  })));
                }
              } catch (e) {
                throw new Error(`BIT MIN ê²€ìƒ‰ ì˜¤ë¥˜: ${e.message}`);
              }
            }
          }

          // ì†ì„±ì— ì—°ê²°ëœ ë°ì´í„° ì¡°íšŒ (ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ì†ì„±ì¼ ìˆ˜ ìˆìŒ)
          if (searchText && bitMax !== undefined && bitMin !== undefined) {
            try {
              // ìœ ì‚¬ë„ ê²€ìƒ‰ ì˜µì…˜ì— ë”°ë¼ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ì¶”ê°€
              const similarityParam = useSimilar ? '&similarity=true&threshold=0.1' : '';
              const attrRes = await fetch(getServerUrl(`/api/attributes/data?bitMax=${bitMax}&bitMin=${bitMin}&limit=${limit}${similarityParam}`));
              if (attrRes.ok) {
                const attrData = await attrRes.json();
                if (attrData.ok && attrData.items && attrData.items.length > 0) {
                  // ì†ì„±ì— ì—°ê²°ëœ ë°ì´í„°ë¥¼ ê²°ê³¼ì— ì¶”ê°€
                  attrData.items.forEach(item => {
                    // ì´ë¯¸ resultsì— ìˆëŠ”ì§€ í™•ì¸ (ì¤‘ë³µ ë°©ì§€)
                    const existingKey = `${item.t || ''}_${item.data?.text || item.s || ''}_${item.attribute?.bitMax || ''}_${item.attribute?.bitMin || ''}`;
                    const exists = results.some(r => {
                      const rKey = `${r.t || ''}_${r.data?.text || r.s || r.input || ''}_${r.attribute?.bitMax || ''}_${r.attribute?.bitMin || ''}`;
                      return rKey === existingKey;
                    });
                    
                    if (!exists) {
                      // ìœ ì‚¬ë„ ê³„ì‚° (ì„œë²„ì—ì„œ ê³„ì‚°í•œ similarity ì‚¬ìš©, ì—†ìœ¼ë©´ ê³„ì‚°)
                      let similarity = item.similarity || 1.0;
                      if (!item.similarity && item.attribute && item.attribute.bitMax !== undefined && item.attribute.bitMin !== undefined) {
                        // ê²€ìƒ‰ BITì™€ ì†ì„± BITì˜ ì°¨ì´ë¡œ ìœ ì‚¬ë„ ê³„ì‚°
                        const bitMaxDiff = Math.abs((bitMax || 0) - (item.attribute.bitMax || 0));
                        const bitMinDiff = Math.abs((bitMin || 0) - (item.attribute.bitMin || 0));
                        // ì°¨ì´ê°€ ì‘ì„ìˆ˜ë¡ ë†’ì€ ìœ ì‚¬ë„ (0~1 ë²”ìœ„)
                        const bitDistance = Math.sqrt(bitMaxDiff * bitMaxDiff + bitMinDiff * bitMinDiff);
                        similarity = Math.max(0, 1 / (1 + bitDistance)); // ê±°ë¦¬ê°€ 0ì´ë©´ 1.0, ê±°ë¦¬ê°€ ì»¤ì§ˆìˆ˜ë¡ ê°ì†Œ
                      }
                      
                      results.push({
                        ...item,
                        source: 'attribute_data',
                        similarity: similarity,
                        input: item.attribute?.text || searchText, // ì†ì„± í…ìŠ¤íŠ¸ë¥¼ inputìœ¼ë¡œ í‘œì‹œ
                        response: item.data?.text || item.s || '', // ë°ì´í„° í…ìŠ¤íŠ¸ë¥¼ responseë¡œ í‘œì‹œ
                        bit: {
                          max: item.attribute?.bitMax || null,
                          min: item.attribute?.bitMin || null
                        }
                      });
                    }
                  });
                  console.log('[Search] ì†ì„± ì—°ê²° ë°ì´í„° ì¶”ê°€:', attrData.items.length, 'ê°œ');
                }
              }
            } catch (e) {
              console.warn('[Search] ì†ì„± ë°ì´í„° ì¡°íšŒ ì˜¤ë¥˜:', e);
              // ì†ì„± ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨í•´ë„ ê¸°ì¡´ ê²€ìƒ‰ ê²°ê³¼ëŠ” í‘œì‹œ
            }
          }

          // ì¤‘ë³µ ì œê±° ë° ì •ë ¬
          const uniqueResults = [];
          const seen = new Set();
          results.forEach(item => {
            const key = `${item.t || ''}_${item.input || item.attribute?.text || ''}_${item.response || item.data?.text || item.s || ''}`;
            if (!seen.has(key)) {
              seen.add(key);
              uniqueResults.push(item);
            }
          });

          // ìœ ì‚¬ë„ìˆœ ì •ë ¬ (ë‚´ë¦¼ì°¨ìˆœ)
          uniqueResults.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));

          // ê²°ê³¼ ì œí•œ
          const finalResults = uniqueResults.slice(0, limit);

          renderResults(finalResults);
          
          $resultCount.textContent = `${finalResults.length}ê°œ`;
          $searchStatus.textContent = `âœ“ ê²€ìƒ‰ ì™„ë£Œ (${finalResults.length}ê°œ ê²°ê³¼)`;
          $searchStatus.style.color = '#28a745';
          
        } catch (e) {
          console.error('ê²€ìƒ‰ ì˜¤ë¥˜:', e);
          const errorMsg = e.message || String(e);
          $resultBody.innerHTML = `<tr><td colspan="7" class="text-danger">
            <strong>ê²€ìƒ‰ ì˜¤ë¥˜</strong><br>
            ${errorMsg}<br>
            <small class="text-muted">ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš” (http://localhost:8123)</small>
          </td></tr>`;
          $resultCount.textContent = 'ì˜¤ë¥˜';
          $searchStatus.textContent = `âœ— ê²€ìƒ‰ ì‹¤íŒ¨: ${errorMsg.substring(0, 50)}${errorMsg.length > 50 ? '...' : ''}`;
          $searchStatus.style.color = '#dc3545';
        } finally {
          $searchBtn.disabled = false;
        }
      }

      function renderResults(results) {
        $resultBody.innerHTML = '';
        if (results.length === 0) {
          $resultBody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</td></tr>';
          $resultInfo.textContent = '';
          return;
        }

        results.forEach((item, idx) => {
          const tr = document.createElement('tr');
          
          const time = item.t ? new Date(item.t).toLocaleString('ko-KR') : (item.timestamp || '');
          
          // BIT ê°’ ì¶”ì¶œ (ì†ì„± ë°ì´í„°ì¸ ê²½ìš° attribute.bitMax/Min, ì¼ë°˜ ë°ì´í„°ì¸ ê²½ìš° bit.max/min)
          const bitMax = (item.attribute && item.attribute.bitMax != null) ? String(item.attribute.bitMax) : 
                        (item.bit && item.bit.max != null) ? String(item.bit.max) : 
                        (item.nb_max != null ? String(item.nb_max) : '');
          const bitMin = (item.attribute && item.attribute.bitMin != null) ? String(item.attribute.bitMin) : 
                        (item.bit && item.bit.min != null) ? String(item.bit.min) : 
                        (item.nb_min != null ? String(item.nb_min) : '');
          
          // ì…ë ¥: ì†ì„± í…ìŠ¤íŠ¸ ë˜ëŠ” ì¼ë°˜ ì…ë ¥
          const input = item.input || item.attribute?.text || item.input_text || '';
          
          // ì‘ë‹µ: ë°ì´í„° í…ìŠ¤íŠ¸ ë˜ëŠ” ì¼ë°˜ ì‘ë‹µ
          const response = item.response || item.data?.text || item.s || item.output || '';
          
          const similarity = item.similarity != null ? (item.similarity * 100).toFixed(10) + '%' : '100%';
          
          // ì†ì„± ì—°ê²° ë°ì´í„° í‘œì‹œ (ì†ŒìŠ¤ í‘œì‹œ)
          const sourceBadge = item.source === 'attribute_data' ? '<span class="badge bg-info">ì†ì„±ì—°ê²°</span> ' : '';

          const tds = [
            idx + 1,
            time,
            bitMax,
            bitMin,
            (sourceBadge ? sourceBadge : '') + input.substring(0, 100) + (input.length > 100 ? '...' : ''),
            response.substring(0, 150) + (response.length > 150 ? '...' : ''),
            similarity
          ];

          tds.forEach((v, i) => {
            const td = document.createElement('td');
            if (i === 4 && sourceBadge) {
              // ì…ë ¥ ì»¬ëŸ¼ì— ë°°ì§€ê°€ ìˆìœ¼ë©´ HTMLë¡œ í‘œì‹œ
              td.innerHTML = String(v || '');
            } else {
              td.textContent = String(v || '');
            }
            if (i === 4 || i === 5) { // ì…ë ¥, ì‘ë‹µ ì»¬ëŸ¼
              td.style.wordBreak = 'break-word';
              td.style.fontSize = '0.9em';
            }
            tr.appendChild(td);
          });

          $resultBody.appendChild(tr);
        });

        // í†µê³„ ì •ë³´
        const avgSimilarity = results.length > 0 
          ? (results.reduce((sum, r) => sum + (r.similarity || 1), 0) / results.length * 100).toFixed(10)
          : 0;
        $resultInfo.textContent = `í‰ê·  ìœ ì‚¬ë„: ${avgSimilarity}%`;
      }

      $searchBtn.addEventListener('click', search);

      // ì—”í„°í‚¤ë¡œ ê²€ìƒ‰
      [$bitMax, $bitMin, $limit].forEach(el => {
        el.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            search();
          }
        });
      });

      // í´ëŸ¬ìŠ¤í„° ê°ì§€
      async function detectClusters() {
        if (!(await testServerConnection())) {
          $clusterStatus.textContent = 'âœ— ì„œë²„ ì—°ê²° ì‹¤íŒ¨';
          $clusterStatus.style.color = '#dc3545';
          return;
        }

        try {
          $detectClustersBtn.disabled = true;
          $clusterStatus.textContent = 'í´ëŸ¬ìŠ¤í„° ê°ì§€ ì¤‘...';
          $clusterStatus.style.color = '#007bff';

          const url = getServerUrl('/api/attributes/clusters/detect');
          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ threshold: 0.5, minPts: 2 })
          });

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }

          const data = await res.json();
          if (data.ok) {
            displayClusters(data.clusters, data.totalAttributes);
            $clusterStatus.textContent = `âœ“ ${data.clusters.length}ê°œ í´ëŸ¬ìŠ¤í„° ê°ì§€ë¨ (ì´ ${data.totalAttributes}ê°œ ì†ì„±)`;
            $clusterStatus.style.color = '#28a745';
          } else {
            throw new Error(data.error || 'í´ëŸ¬ìŠ¤í„° ê°ì§€ ì‹¤íŒ¨');
          }
        } catch (e) {
          console.error('í´ëŸ¬ìŠ¤í„° ê°ì§€ ì˜¤ë¥˜:', e);
          $clusterStatus.textContent = `âœ— í´ëŸ¬ìŠ¤í„° ê°ì§€ ì‹¤íŒ¨: ${e.message}`;
          $clusterStatus.style.color = '#dc3545';
        } finally {
          $detectClustersBtn.disabled = false;
        }
      }

      function displayClusters(clusters, totalAttributes) {
        $clustersList.innerHTML = '';
        
        if (clusters.length === 0) {
          $clustersList.innerHTML = '<div class="text-muted">í´ëŸ¬ìŠ¤í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
          return;
        }

        const card = document.createElement('div');
        card.className = 'card';
        const cardBody = document.createElement('div');
        cardBody.className = 'card-body';
        card.appendChild(cardBody);

        clusters.forEach((cluster, idx) => {
          const clusterDiv = document.createElement('div');
          clusterDiv.className = 'border rounded p-3 mb-3';
          
          const title = document.createElement('h6');
          title.innerHTML = `${cluster.isolated ? 'ğŸï¸ ê³ ë¦½' : 'ğŸ”— í´ëŸ¬ìŠ¤í„°'} ${idx + 1} (${cluster.size}ê°œ ì†ì„±)`;
          clusterDiv.appendChild(title);

          const centerInfo = document.createElement('div');
          centerInfo.className = 'small text-muted mb-2';
          centerInfo.textContent = `ì¤‘ì‹¬: BIT_MAX=${cluster.center.bitMax.toFixed(3)}, BIT_MIN=${cluster.center.bitMin.toFixed(3)}`;
          clusterDiv.appendChild(centerInfo);

          const attrsList = document.createElement('div');
          attrsList.className = 'mb-2';
          cluster.attributes.forEach(attr => {
            const badge = document.createElement('span');
            badge.className = 'badge bg-secondary me-1 mb-1';
            badge.textContent = `${attr.text} (${attr.dataCount}ê°œ ë°ì´í„°)`;
            attrsList.appendChild(badge);
          });
          clusterDiv.appendChild(attrsList);

          // ìƒìœ„ ì†ì„± ìƒì„± UI
          const createParentDiv = document.createElement('div');
          createParentDiv.className = 'mt-2';
          
          const inputGroup = document.createElement('div');
          inputGroup.className = 'input-group';
          
          const parentInput = document.createElement('input');
          parentInput.type = 'text';
          parentInput.className = 'form-control form-control-sm';
          parentInput.placeholder = 'ìƒìœ„ ì†ì„± ì´ë¦„ ì…ë ¥ (ì˜ˆ: í†¨í‚¨ ì„¸ê³„ê´€)';
          parentInput.value = cluster.isolated ? cluster.attributes[0].text : '';
          
          const createBtn = document.createElement('button');
          createBtn.className = 'btn btn-sm btn-success';
          createBtn.textContent = 'ìƒìœ„ ì†ì„± ìƒì„±';
          createBtn.onclick = () => createParentAttribute(cluster, parentInput.value.trim() || `í´ëŸ¬ìŠ¤í„°_${idx + 1}`);
          
          inputGroup.appendChild(parentInput);
          inputGroup.appendChild(createBtn);
          createParentDiv.appendChild(inputGroup);
          clusterDiv.appendChild(createParentDiv);

          cardBody.appendChild(clusterDiv);
        });

        $clustersList.appendChild(card);
      }

      async function createParentAttribute(cluster, parentText) {
        if (!parentText) {
          alert('ìƒìœ„ ì†ì„± ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”.');
          return;
        }

        try {
          const url = getServerUrl('/api/hierarchy/parent');
          const parentBitMax = cluster.center.bitMax;
          const parentBitMin = cluster.center.bitMin;
          
          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              parentText,
              parentBitMax,
              parentBitMin,
              childCellIds: cluster.cellIds,
              autoGenerated: false
            })
          });

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }

          const data = await res.json();
          if (data.ok) {
            if (data.duplicate) {
              if (data.updated) {
                alert(`âœ“ ê¸°ì¡´ ìƒìœ„ ì†ì„± "${parentText}"ì— ${data.newChildren.length}ê°œ í•˜ìœ„ ì†ì„±ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
              } else {
                alert(`âš  ${data.message || 'ì´ë¯¸ ë™ì¼í•œ ìƒìœ„ ì†ì„±ì´ ì¡´ì¬í•©ë‹ˆë‹¤.'}`);
              }
            } else {
              let msg = `âœ“ ìƒìœ„ ì†ì„± "${parentText}" ìƒì„± ì™„ë£Œ!`;
              if (data.conflicts && data.conflicts.length > 0) {
                msg += `\nâš  ì°¸ê³ : ${data.conflicts.length}ê°œ í•˜ìœ„ ì†ì„±ì´ ë‹¤ë¥¸ ìƒìœ„ ì†ì„±ì—ì„œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤.`;
              }
              alert(msg);
            }
            loadParents(); // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
          } else {
            throw new Error(data.error || 'ìƒì„± ì‹¤íŒ¨');
          }
        } catch (e) {
          console.error('ìƒìœ„ ì†ì„± ìƒì„± ì˜¤ë¥˜:', e);
          alert(`âœ— ìƒì„± ì‹¤íŒ¨: ${e.message}`);
        }
      }

      async function loadParents() {
        if (!(await testServerConnection())) {
          alert('ì„œë²„ ì—°ê²° ì‹¤íŒ¨');
          return;
        }

        try {
          const url = getServerUrl('/api/hierarchy/parents');
          const res = await fetch(url);

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }

          const data = await res.json();
          if (data.ok) {
            displayParents(data.parents);
            $parentsList.style.display = data.parents.length > 0 ? 'block' : 'none';
          }
        } catch (e) {
          console.error('ìƒìœ„ ì†ì„± ë¡œë“œ ì˜¤ë¥˜:', e);
          alert(`âœ— ë¡œë“œ ì‹¤íŒ¨: ${e.message}`);
        }
      }

      function displayParents(parents) {
        $parentsItems.innerHTML = '';
        
        if (parents.length === 0) {
          $parentsItems.innerHTML = '<div class="text-muted">ìƒìœ„ ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.</div>';
          return;
        }

        parents.forEach(parent => {
          const div = document.createElement('div');
          div.className = 'border rounded p-2 mb-2';
          
          const title = document.createElement('strong');
          title.textContent = parent.text;
          div.appendChild(title);

          const info = document.createElement('div');
          info.className = 'small text-muted';
          info.textContent = `${parent.childCellIds.length}ê°œ í•˜ìœ„ ì†ì„± | ìƒì„±: ${new Date(parent.createdAt).toLocaleString('ko-KR')}`;
          div.appendChild(info);

          const searchBtn = document.createElement('button');
          searchBtn.className = 'btn btn-sm btn-outline-primary mt-2';
          searchBtn.textContent = 'ì´ ìƒìœ„ ì†ì„±ìœ¼ë¡œ ê²€ìƒ‰';
          searchBtn.onclick = () => searchByParent(parent.parentId);
          div.appendChild(searchBtn);

          $parentsItems.appendChild(div);
        });
      }

      async function searchByParent(parentId) {
        if (!(await testServerConnection())) {
          alert('ì„œë²„ ì—°ê²° ì‹¤íŒ¨');
          return;
        }

        try {
          const url = getServerUrl(`/api/attributes/data/by-parent?parentId=${encodeURIComponent(parentId)}&limit=100`);
          const res = await fetch(url);

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }

          const data = await res.json();
          if (data.ok) {
            const items = data.items || [];
            // ê²°ê³¼ í¬ë§·íŒ… (renderResults í˜•ì‹ì— ë§ê²Œ)
            const formattedItems = items.map(item => ({
              ...item,
              input: item.attribute?.text || '',
              response: item.data?.text || item.s || '',
              similarity: 1.0,
              source: 'parent_attribute'
            }));
            renderResults(formattedItems);
            $resultCount.textContent = `${data.count || 0}ê°œ ê²°ê³¼`;
            $searchStatus.textContent = `ìƒìœ„ ì†ì„± "${data.parent.text}" ê²€ìƒ‰ (${data.childAttributes.length}ê°œ í•˜ìœ„ ì†ì„±)`;
            $searchStatus.style.color = '#28a745';
          }
        } catch (e) {
          console.error('ìƒìœ„ ì†ì„± ê²€ìƒ‰ ì˜¤ë¥˜:', e);
          alert(`âœ— ê²€ìƒ‰ ì‹¤íŒ¨: ${e.message}`);
        }
      }

      $detectClustersBtn.addEventListener('click', detectClusters);
      $loadParentsBtn.addEventListener('click', loadParents);
    })();
    </script>
</body>
</html>

