<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ì‹¤ì‹œê°„ ìë™í™” ì‹œìŠ¤í…œ</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://xn--9l4b4xi9r.com/_8%EB%B9%84%ED%8A%B8/js/bitCalculation.js" defer></script>
    <script src="js/searchAlgorithm.js"></script>
    <style>
        .input-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .output-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
        }
        .bit-display {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            background: white;
            color: #333;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }
        .auto-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }
        .status-active {
            background: #28a745;
            color: white;
        }
        .status-paused {
            background: #ffc107;
            color: #333;
        }
        .result-item {
            border-left: 3px solid #007bff;
            padding: 10px;
            margin: 10px 0;
            background: white;
            border-radius: 5px;
            transition: all 0.3s;
        }
        .result-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: translateX(5px);
        }
        .similarity-badge {
            font-size: 0.85em;
            padding: 3px 8px;
        }
        .input-textarea {
            font-size: 1.1em;
            min-height: 120px;
        }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <h2 class="mb-4">âš¡ ì‹¤ì‹œê°„ ìë™í™” ì‹œìŠ¤í…œ</h2>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ì…ë ¥ ì„¹ì…˜ -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="input-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h4 class="mb-0">ğŸ“ ì‹¤ì‹œê°„ ì…ë ¥</h4>
                        <div>
                            <span class="auto-status" id="autoStatus">â¸ï¸ ì¼ì‹œì •ì§€</span>
                            <button id="toggleAutoBtn" class="btn btn-light btn-sm ms-2">ìë™í™” í™œì„±í™”</button>
                        </div>
                    </div>
                    
                    <!-- ì†ì„± ì…ë ¥ -->
                    <div class="mb-3">
                        <label class="form-label fw-bold">1ë‹¨ê³„: ì†ì„± (ë¬¸ì ì…ë ¥)</label>
                        <textarea 
                            id="attributeInput" 
                            class="form-control input-textarea" 
                            placeholder="ì†ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                            rows="2"
                        ></textarea>
                        <div class="row mt-2">
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ì†ì„± BIT MAX:</strong> <span id="attributeMax">-</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ì†ì„± BIT MIN:</strong> <span id="attributeMin">-</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ë°ì´í„° ì…ë ¥ -->
                    <div class="mb-3 border-top pt-3">
                        <label class="form-label fw-bold">2ë‹¨ê³„: ë°ì´í„° (ë¬¸ì ì…ë ¥)</label>
                        <textarea 
                            id="realtimeInput" 
                            class="form-control input-textarea" 
                            placeholder="ì´ ì†ì„±ì— ì €ì¥í•  ë°ì´í„°(í…ìŠ¤íŠ¸)ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                            rows="3"
                        ></textarea>
                        <div class="row mt-2">
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ë°ì´í„° BIT MAX:</strong> <span id="calculatedMax">-</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ë°ì´í„° BIT MIN:</strong> <span id="calculatedMin">-</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ì €ì¥ ë²„íŠ¼ -->
                    <div class="mt-3">
                        <button id="saveBtn" class="btn btn-light">ì†ì„±ì— ë°ì´í„° ì €ì¥</button>
                        <span id="saveStatus" class="ms-2 small"></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ì¶œë ¥ ì„¹ì…˜ -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="output-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5>ğŸ“Š ì‹¤ì‹œê°„ ì¶œë ¥</h5>
                        <button id="clearOutputBtn" class="btn btn-sm btn-outline-secondary">ì¶œë ¥ ì§€ìš°ê¸°</button>
                    </div>
                    <div id="realtimeOutput"></div>
                </div>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ì¡°íšŒ ê²°ê³¼ -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <strong>ğŸ” ì‹¤ì‹œê°„ ì¡°íšŒ ê²°ê³¼</strong>
                        <span id="resultCount" class="badge bg-secondary">0ê°œ</span>
                    </div>
                    <div class="card-body">
                        <div id="searchStatus" class="small text-muted mb-2"></div>
                        <div class="table-responsive" style="max-height: 500px; overflow-y: auto;">
                            <table class="table table-sm table-hover">
                                <thead class="table-light sticky-top">
                                    <tr>
                                        <th style="width: 5%;">#</th>
                                        <th style="width: 15%;">ì‹œê°„</th>
                                        <th style="width: 12%;">BIT_MAX</th>
                                        <th style="width: 12%;">BIT_MIN</th>
                                        <th style="width: 20%;">ì†ì„±</th>
                                        <th style="width: 26%;">ë°ì´í„°</th>
                                        <th style="width: 10%;">ìœ ì‚¬ë„</th>
                                    </tr>
                                </thead>
                                <tbody id="resultBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    (function(){
      const $attributeInput = document.getElementById('attributeInput');
      const $attributeMax = document.getElementById('attributeMax');
      const $attributeMin = document.getElementById('attributeMin');
      const $input = document.getElementById('realtimeInput');
      const $calculatedMax = document.getElementById('calculatedMax');
      const $calculatedMin = document.getElementById('calculatedMin');
      const $autoStatus = document.getElementById('autoStatus');
      const $toggleAutoBtn = document.getElementById('toggleAutoBtn');
      const $realtimeOutput = document.getElementById('realtimeOutput');
      const $clearOutputBtn = document.getElementById('clearOutputBtn');
      const $resultBody = document.getElementById('resultBody');
      const $resultCount = document.getElementById('resultCount');
      const $searchStatus = document.getElementById('searchStatus');
      const $saveBtn = document.getElementById('saveBtn');
      const $saveStatus = document.getElementById('saveStatus');

      let isAutoEnabled = false;
      let inputDebounceTimer = null;
      let searchTimer = null;
      let lastInput = '';
      let lastAttribute = '';

      function getServerUrl(path) {
        if (window.location.protocol === 'file:') {
          return `http://localhost:8123${path}`;
        }
        return path;
      }

      async function testServerConnection() {
        try {
          const res = await fetch(getServerUrl('/health'));
          return res.ok;
        } catch {
          return false;
        }
      }

      function calculateBitValues(text) {
        if (!text || typeof text !== 'string' || text.trim() === '') {
          return { max: null, min: null };
        }
        try {
          if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
            console.warn('BIT ê³„ì‚° í•¨ìˆ˜ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            return { max: null, min: null };
          }
          const unicodeArray = wordNbUnicodeFormat(text);
          const max = BIT_MAX_NB(unicodeArray);
          const min = BIT_MIN_NB(unicodeArray);
          return { max: isFinite(max) ? max : null, min: isFinite(min) ? min : null };
        } catch (e) {
          console.error('BIT ê³„ì‚° ì˜¤ë¥˜:', e);
          return { max: null, min: null };
        }
      }

      function addOutput(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString('ko-KR');
        const div = document.createElement('div');
        div.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} alert-dismissible fade show`;
        div.style.fontSize = '0.9em';
        div.innerHTML = `
          <small class="text-muted">[${timestamp}]</small> ${message}
          <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        $realtimeOutput.insertBefore(div, $realtimeOutput.firstChild);
      }

      async function autoSaveAttributeData(attributeText, dataText) {
        if (!attributeText || !dataText) return;

        const attrBits = calculateBitValues(attributeText);
        const dataBits = calculateBitValues(dataText);

        if (!attrBits.max || !attrBits.min || !dataBits.max || !dataBits.min) {
          return;
        }

        try {
          const url = getServerUrl('/api/attributes/data');
          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              attributeBitMax: attrBits.max,
              attributeBitMin: attrBits.min,
              attributeText: attributeText,
              text: dataText,
              dataBitMax: dataBits.max,
              dataBitMin: dataBits.min
            })
          });

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }

          const data = await res.json();
          if (data.ok) {
            if (data.duplicate) {
              $saveStatus.textContent = `âš  ìë™ ì €ì¥: ${data.message || 'ì´ë¯¸ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.'}`;
              $saveStatus.style.color = '#ffc107';
              addOutput(`âš  ì†ì„± "${attributeText}"ì— ë°ì´í„° "${dataText}" ìë™ ì €ì¥ ì‹œë„ (ì¤‘ë³µ)`, 'warning');
            } else {
              $saveStatus.textContent = 'âœ“ ìë™ ì €ì¥ ì™„ë£Œ!';
              $saveStatus.style.color = '#28a745';
              addOutput(`âœ“ ì†ì„± "${attributeText}"ì— ë°ì´í„° "${dataText}" ìë™ ì €ì¥ ì™„ë£Œ`, 'success');
              // ìë™ ì €ì¥ í›„ ë°ì´í„° ì…ë ¥ë€ì€ ìœ ì§€ (ì‚¬ìš©ìê°€ ê³„ì† ì…ë ¥í•  ìˆ˜ ìˆë„ë¡)
            }
          } else {
            throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
          }
        } catch (e) {
          console.error('ìë™ ì €ì¥ ì˜¤ë¥˜:', e);
          $saveStatus.textContent = `âœ— ìë™ ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
          $saveStatus.style.color = '#dc3545';
          addOutput(`ìë™ ì €ì¥ ì˜¤ë¥˜: ${e.message}`, 'error');
        }
      }

      async function saveAttributeData() {
        const attributeText = $attributeInput.value.trim();
        const dataText = $input.value.trim();

        if (!attributeText) {
          $saveStatus.textContent = 'ì†ì„± í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ì…ë ¥í•˜ì„¸ìš”.';
          $saveStatus.style.color = '#dc3545';
          return;
        }

        if (!dataText) {
          $saveStatus.textContent = 'ë°ì´í„° í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
          $saveStatus.style.color = '#dc3545';
          return;
        }

        await autoSaveAttributeData(attributeText, dataText);
      }

      async function autoSave(text, bitMax, bitMin) {
        if (!text || !bitMax || !bitMin) return;

        try {
          // ìë™ ì €ì¥ì€ ë¹„í™œì„±í™” (ëª…ì‹œì  ì €ì¥ë§Œ)
          addOutput(`ì…ë ¥ í…ìŠ¤íŠ¸: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}" (BIT: ${bitMax.toFixed(15)}, ${bitMin.toFixed(15)})`, 'info');
        } catch (e) {
          addOutput(`ì €ì¥ ì˜¤ë¥˜: ${e.message}`, 'error');
        }
      }

      // ìœ ì‚¬ë„ ê³„ì‚° í—¬í¼ í•¨ìˆ˜ (ê³µí†µ ëª¨ë“ˆ ì‚¬ìš©)
      function calculateSimilarity(queryBitMax, queryBitMin, resultBitMax, resultBitMin) {
        return window.SearchAlgorithm.calculateSimilarity(queryBitMax, queryBitMin, resultBitMax, resultBitMin);
      }

      async function autoSearch(bitMax, bitMin, searchText = null) {
        if (!bitMax || !bitMin) return;

        try {
          $searchStatus.textContent = 'ê²€ìƒ‰ ì¤‘...';
          $searchStatus.style.color = '#007bff';

          // ê²€ìƒ‰ ì˜µì…˜ (real_time.htmlì€ ê¸°ë³¸ê°’ìœ¼ë¡œ 'attribute'ë§Œ ì‚¬ìš©)
          let searchOption = 'attribute';

          let results = [];
          // ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ì œê³µë˜ë©´ í•´ë‹¹ í…ìŠ¤íŠ¸ë¥¼ ì†ì„± í›„ë³´ë¡œë„ ê³ ë ¤
          let attributeText = $attributeInput.value.trim();
          // ì‹¤ì‹œê°„ ì¡°íšŒ ì…ë ¥ë€ì—ì„œ ê²€ìƒ‰í•œ ê²½ìš°, ê²€ìƒ‰ í…ìŠ¤íŠ¸ë¥¼ ì†ì„± í›„ë³´ë¡œ ì‚¬ìš©
          if (!attributeText && searchText) {
            attributeText = searchText.trim();
          }
          const dataText = $input.value.trim();

          // 1. ì†ì„± ê²€ìƒ‰ (ì†ì„± ê²€ìƒ‰ ë˜ëŠ” ì „ì²´ ê²€ìƒ‰ì¼ ë•Œ)
          if (searchOption === 'attribute' || searchOption === 'all') {
            try {
              
              // ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ìš°ì„  ì‚¬ìš© (ì‹¤ì‹œê°„ ì¡°íšŒ ì…ë ¥ë€ì—ì„œ ê²€ìƒ‰í•œ ê²½ìš°)
              const searchAttributeText = searchText ? searchText.trim() : attributeText;
              
              if (searchAttributeText) {
                const attrBits = calculateBitValues(searchAttributeText);
                if (attrBits.max && attrBits.min) {
                  // ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ (thresholdë¡œ ìœ ì‚¬í•œ ì†ì„±ë“¤ì„ ì°¾ìŒ)
                  const url = getServerUrl(`/api/attributes/data?bitMax=${attrBits.max}&bitMin=${attrBits.min}&limit=20&similarity=true&threshold=0.1`);
                  const res = await fetch(url);

                  if (res.ok) {
                    const data = await res.json();
                    if (data.ok && data.items) {
                      results.push(...data.items.map(item => {
                        // ì†ì„± ê²€ìƒ‰ì¸ ê²½ìš°: ê²€ìƒ‰ ì¿¼ë¦¬ì˜ ì†ì„± BITì™€ ê²°ê³¼ì˜ ì†ì„± BITë¥¼ ë¹„êµ
                        const resultAttrBitMax = item.attribute?.bitMax || null;
                        const resultAttrBitMin = item.attribute?.bitMin || null;
                        const resultAttrText = item.attribute?.text || '';
                        
                        // ì†ì„± BITë¡œ ìœ ì‚¬ë„ ê³„ì‚° (ê³µí†µ ëª¨ë“ˆ ì‚¬ìš©)
                        const similarity = window.SearchAlgorithm.calculateAttributeSimilarity(
                          searchAttributeText,
                          attrBits.max,
                          attrBits.min,
                          item
                        );
                        
                        return {
                          ...item,
                          source: 'attribute_data',
                          input: item.attribute?.text || searchAttributeText,
                          response: item.data?.text || item.s || '',
                          similarity: similarity
                        };
                      }));
                    }
                  }
                }
              }
              
              // ì†ì„±ìœ¼ë¡œë§Œ ê²€ìƒ‰í•˜ëŠ” ê²½ìš°, ê²€ìƒ‰ í…ìŠ¤íŠ¸ BITë¡œ ëª¨ë“  ì†ì„±ê³¼ ìœ ì‚¬ë„ ë¹„êµ
              if (searchOption === 'attribute' && searchText && bitMax && bitMin) {
                try {
                  // ëª¨ë“  ì†ì„± ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                  const allAttrUrl = getServerUrl('/api/attributes/all');
                  const allAttrRes = await fetch(allAttrUrl);
                  
                  if (allAttrRes.ok) {
                    const allAttrData = await allAttrRes.json();
                    if (allAttrData.ok && allAttrData.attributes && allAttrData.attributes.length > 0) {
                      // ê²€ìƒ‰ í…ìŠ¤íŠ¸ BITì™€ ê° ì†ì„± BIT ê°„ì˜ ìœ ì‚¬ë„ ê³„ì‚° (ê³µí†µ ëª¨ë“ˆ ì‚¬ìš©)
                      const similarAttributes = window.SearchAlgorithm.findSimilarAttributes(
                        searchText, 
                        bitMax, 
                        bitMin, 
                        allAttrData.attributes, 
                        0.1, 
                        10
                      );
                      
                      // ìœ ì‚¬í•œ ì†ì„±ë“¤ì˜ ë°ì´í„° ì¡°íšŒ
                      for (const similarAttr of similarAttributes) {
                        try {
                          const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${similarAttr.bitMax}&bitMin=${similarAttr.bitMin}&limit=5`);
                          const dataRes = await fetch(dataUrl);
                          
                          if (dataRes.ok) {
                            const dataData = await dataRes.json();
                            if (dataData.ok && dataData.items) {
                              results.push(...dataData.items.map(item => ({
                                ...item,
                                source: 'attribute_similar',
                                input: item.attribute?.text || similarAttr.text,
                                response: item.data?.text || item.s || '',
                                similarity: similarAttr.similarity * 0.9 // ì†ì„± ìœ ì‚¬ë„ì— ì•½ê°„ì˜ í˜ë„í‹° ì ìš©
                              })));
                            }
                          }
                        } catch (e) {
                          console.warn(`ì†ì„± "${similarAttr.text}" ë°ì´í„° ì¡°íšŒ ì˜¤ë¥˜:`, e);
                        }
                      }
                    }
                  }
                } catch (e) {
                  console.warn('ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ ì˜¤ë¥˜:', e);
                }
              }
            } catch (e) {
              console.warn('ì†ì„± ë°ì´í„° ê²€ìƒ‰ ì˜¤ë¥˜:', e);
            }
          }

          // 2. ë°ì´í„° BIT ê°’ìœ¼ë¡œë„ ê²€ìƒ‰ (ì†ì„±-ë°ì´í„° ì—°ê²°ëœ í•­ëª©) - ì „ì²´ ê²€ìƒ‰ ë˜ëŠ” ë°ì´í„° ê²€ìƒ‰ì¼ ë•Œ
          if (searchOption === 'all' || searchOption === 'data') {
            try {
              const maxUrl = getServerUrl(`/api/log/by-max?nb_max=${bitMax}&n=20`);
              const minUrl = getServerUrl(`/api/log/by-min?nb_min=${bitMin}&n=20`);
              
              const [maxRes, minRes] = await Promise.all([fetch(maxUrl), fetch(minUrl)]);
              
              if (maxRes.ok) {
                const maxData = await maxRes.json();
                if (maxData.ok && maxData.items) {
                  const attrItems = maxData.items.filter(item => item.attribute).map(item => {
                    // ê²€ìƒ‰ ì¿¼ë¦¬ BITì™€ ê²°ê³¼ BIT ê°„ì˜ ìœ ì‚¬ë„ ê³„ì‚°
                    const resultBitMax = item.data?.bitMax || item.max || item.nb_max || null;
                    const resultBitMin = item.data?.bitMin || item.min || item.nb_min || null;
                    const similarity = calculateSimilarity(bitMax, bitMin, resultBitMax, resultBitMin);
                    
                    return {
                      ...item,
                      source: 'attribute_data_by_data',
                      input: item.attribute?.text || '',
                      response: item.data?.text || item.s || '',
                      similarity: similarity
                    };
                  });
                  results.push(...attrItems);
                }
              }
              
              if (minRes.ok) {
                const minData = await minRes.json();
                if (minData.ok && minData.items) {
                  const attrItems = minData.items.filter(item => item.attribute).map(item => {
                    // ê²€ìƒ‰ ì¿¼ë¦¬ BITì™€ ê²°ê³¼ BIT ê°„ì˜ ìœ ì‚¬ë„ ê³„ì‚°
                    const resultBitMax = item.data?.bitMax || item.max || item.nb_max || null;
                    const resultBitMin = item.data?.bitMin || item.min || item.nb_min || null;
                    const similarity = calculateSimilarity(bitMax, bitMin, resultBitMax, resultBitMin);
                    
                    return {
                      ...item,
                      source: 'attribute_data_by_data',
                      input: item.attribute?.text || '',
                      response: item.data?.text || item.s || '',
                      similarity: similarity
                    };
                  });
                  results.push(...attrItems);
                }
              }
            } catch (e) {
              console.warn('ë°ì´í„° BIT ê²€ìƒ‰ ì˜¤ë¥˜:', e);
            }
          }

          // 3. ì¼ë°˜ ë¡œê·¸ ë°ì´í„° ê²€ìƒ‰ (ì†ì„±ì´ ì—†ëŠ” ì¼ë°˜ ë°ì´í„°) - ì „ì²´ ê²€ìƒ‰ì¼ ë•Œë§Œ
          if (searchOption === 'all') {
            try {
              const maxUrl = getServerUrl(`/api/log/by-max?nb_max=${bitMax}&n=10`);
              const minUrl = getServerUrl(`/api/log/by-min?nb_min=${bitMin}&n=10`);
              
              const [maxRes, minRes] = await Promise.all([fetch(maxUrl), fetch(minUrl)]);
              
              const generalItems = [];
              
              if (maxRes.ok) {
                const maxData = await maxRes.json();
                if (maxData.ok && maxData.items) {
                  maxData.items.filter(item => !item.attribute).forEach(item => {
                    const resultBitMax = item.nb_max || item.max || null;
                    const resultBitMin = item.nb_min || item.min || null;
                    const similarity = calculateSimilarity(bitMax, bitMin, resultBitMax, resultBitMin);
                    
                    generalItems.push({
                      ...item,
                      source: 'log',
                      input: item.input_text || item.s || '',
                      response: item.output || item.s || '',
                      similarity: similarity
                    });
                  });
                }
              }
              
              if (minRes.ok) {
                const minData = await minRes.json();
                if (minData.ok && minData.items) {
                  minData.items.filter(item => !item.attribute).forEach(item => {
                    const resultBitMax = item.nb_max || item.max || null;
                    const resultBitMin = item.nb_min || item.min || null;
                    const similarity = calculateSimilarity(bitMax, bitMin, resultBitMax, resultBitMin);
                    
                    generalItems.push({
                      ...item,
                      source: 'log',
                      input: item.input_text || item.s || '',
                      response: item.output || item.s || '',
                      similarity: similarity
                    });
                  });
                }
              }
              
              results.push(...generalItems);
            } catch (e) {
              console.warn('ì¼ë°˜ ë¡œê·¸ ê²€ìƒ‰ ì˜¤ë¥˜:', e);
            }
          }

          // 4. ìœ ì‚¬ë„ ê²€ìƒ‰ (training ë°ì´í„°) - ì „ì²´ ê²€ìƒ‰ì¼ ë•Œë§Œ
          if (searchOption === 'all') {
            try {
              const url = getServerUrl('/api/training/similar');
              const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  query: '',
                  queryBitMax: bitMax,
                  queryBitMin: bitMin,
                  limit: 10
                })
              });

              if (res.ok) {
                const data = await res.json();
                if (data.ok && data.items) {
                  results.push(...data.items.map(item => ({
                    ...item,
                    source: 'training',
                    similarity: item.similarity_score || calculateSimilarity(bitMax, bitMin, item.bit?.max, item.bit?.min)
                  })));
                }
              }
            } catch (e) {
              console.warn('ìœ ì‚¬ë„ ê²€ìƒ‰ ì˜¤ë¥˜:', e);
            }
          }

          // ì¤‘ë³µ ì œê±° ë° ì •ë ¬ (ê³µí†µ ëª¨ë“ˆ ì‚¬ìš©)
          let finalResults = window.SearchAlgorithm.processSearchResults(results, bitMax, bitMin, 20);
          
          // ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ìˆì„ ë•Œ í…ìŠ¤íŠ¸ ì •í™• ë§¤ì¹­ ìš°ì„  ì •ë ¬
          if (searchText && searchText.trim()) {
            const searchTextTrimmed = searchText.trim();
            finalResults = finalResults.sort((a, b) => {
              const aAttrText = (a.attribute?.text || a.input || '').trim();
              const bAttrText = (b.attribute?.text || b.input || '').trim();
              
              // í…ìŠ¤íŠ¸ê°€ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ê²½ìš° ìš°ì„ 
              const aExactMatch = aAttrText === searchTextTrimmed;
              const bExactMatch = bAttrText === searchTextTrimmed;
              
              if (aExactMatch && !bExactMatch) return -1;
              if (!aExactMatch && bExactMatch) return 1;
              
              // ë‘˜ ë‹¤ ì •í™•íˆ ì¼ì¹˜í•˜ê±°ë‚˜ ë‘˜ ë‹¤ ì•„ë‹Œ ê²½ìš° ìœ ì‚¬ë„ìˆœ ì •ë ¬
              return (b.similarity || 0) - (a.similarity || 0);
            });
          }

          renderResults(finalResults);
          $resultCount.textContent = `${finalResults.length}ê°œ`;
          $searchStatus.textContent = `âœ“ ê²€ìƒ‰ ì™„ë£Œ (${finalResults.length}ê°œ ê²°ê³¼)`;
          $searchStatus.style.color = '#28a745';

        } catch (e) {
          console.error('ê²€ìƒ‰ ì˜¤ë¥˜:', e);
          $searchStatus.textContent = `âœ— ê²€ìƒ‰ ì‹¤íŒ¨: ${e.message}`;
          $searchStatus.style.color = '#dc3545';
        }
      }

      function renderResults(results) {
        $resultBody.innerHTML = '';
        
        if (results.length === 0) {
          $resultBody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</td></tr>';
          return;
        }

        results.forEach((item, idx) => {
          const tr = document.createElement('tr');
          
          const time = item.t ? new Date(item.t).toLocaleString('ko-KR') : (item.timestamp || '');
          
          const bitMax = (item.attribute && item.attribute.bitMax != null) ? String(item.attribute.bitMax) : 
                        (item.bit && item.bit.max != null) ? String(item.bit.max) : 
                        (item.nb_max != null ? String(item.nb_max) : '');
          const bitMin = (item.attribute && item.attribute.bitMin != null) ? String(item.attribute.bitMin) : 
                        (item.bit && item.bit.min != null) ? String(item.bit.min) : 
                        (item.nb_min != null ? String(item.nb_min) : '');
          
          const input = item.input || item.attribute?.text || item.input_text || '';
          const response = item.response || item.data?.text || item.s || item.output || '';
          const similarity = item.similarity != null ? (item.similarity * 100).toFixed(10) + '%' : '100%';
          
          const similarityClass = item.similarity >= 0.9 ? 'bg-success' : item.similarity >= 0.7 ? 'bg-warning' : 'bg-danger';
          
          tr.innerHTML = `
            <td>${idx + 1}</td>
            <td><small>${time}</small></td>
            <td><code>${bitMax.substring(0, 10)}${bitMax.length > 10 ? '...' : ''}</code></td>
            <td><code>${bitMin.substring(0, 10)}${bitMin.length > 10 ? '...' : ''}</code></td>
            <td>${input.substring(0, 30)}${input.length > 30 ? '...' : ''}</td>
            <td>${response.substring(0, 40)}${response.length > 40 ? '...' : ''}</td>
            <td><span class="badge ${similarityClass} similarity-badge">${similarity}</span></td>
          `;
          
          $resultBody.appendChild(tr);
        });
      }

      function updateBitDisplay(text, $maxEl, $minEl) {
        const { max, min } = calculateBitValues(text);
        if ($maxEl) $maxEl.textContent = max !== null ? max.toFixed(15) : '-';
        if ($minEl) $minEl.textContent = min !== null ? min.toFixed(15) : '-';
        return { max, min };
      }

      function updateAttributeBitDisplay(text) {
        return updateBitDisplay(text, $attributeMax, $attributeMin);
      }

      function updateDataBitDisplay(text) {
        return updateBitDisplay(text, $calculatedMax, $calculatedMin);
      }

      async function processInput(text) {
        if (!text || text.trim() === '') {
          updateDataBitDisplay('');
          return;
        }

        const { max, min } = updateDataBitDisplay(text);

        if (max !== null && min !== null) {
          // ì†ì„±ê³¼ ë°ì´í„°ê°€ ëª¨ë‘ ì…ë ¥ë˜ì–´ ìˆìœ¼ë©´ ìë™ ì €ì¥ (ì €ì¥ê³¼ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰)
          const attributeText = $attributeInput.value.trim();
          if (attributeText) {
            // ìë™ ì €ì¥ (ë””ë°”ìš´ì‹±) - ì €ì¥ ê²°ê³¼ì™€ ê´€ê³„ì—†ì´ ì‹¤í–‰
            if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
            inputDebounceTimer = setTimeout(async () => {
              await autoSaveAttributeData(attributeText, text);
              // ì €ì¥ í›„ì—ë„ ê²€ìƒ‰ì€ ë³„ë„ë¡œ ì‹¤í–‰ë¨ (ì¤‘ë³µì´ì–´ë„ ìƒê´€ì—†ì´)
            }, 1000); // 1ì´ˆ í›„ ìë™ ì €ì¥
          }

          // ìë™ ê²€ìƒ‰ (ì €ì¥ê³¼ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰, ì¤‘ë³µì´ì–´ë„ ê²€ìƒ‰ ìˆ˜í–‰)
          if (searchTimer) clearTimeout(searchTimer);
          searchTimer = setTimeout(() => {
            autoSearch(max, min); // ì¤‘ë³µ ì €ì¥ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ í•­ìƒ ê²€ìƒ‰ ì‹¤í–‰
          }, 1000); // 1ì´ˆ í›„ ê²€ìƒ‰ (ì €ì¥ê³¼ ë™ì‹œì— ì‹¤í–‰ ê°€ëŠ¥)
        }
      }

      function processAttributeInput(text) {
        if (!text || text.trim() === '') {
          updateAttributeBitDisplay('');
          return;
        }

        // ì†ì„± ì…ë ¥ì—ì„œëŠ” BIT ê³„ì‚°ë§Œ í•˜ê³  ê²€ìƒ‰ì€ í•˜ì§€ ì•ŠìŒ
        updateAttributeBitDisplay(text);
      }

      // ì†ì„± ì…ë ¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ê²€ìƒ‰í•˜ì§€ ì•ŠìŒ, BIT ê³„ì‚°ë§Œ)
      $attributeInput.addEventListener('input', (e) => {
        const text = e.target.value;
        processAttributeInput(text);
        // ì†ì„± ì…ë ¥ì—ì„œëŠ” ê²€ìƒ‰í•˜ì§€ ì•ŠìŒ
      });

      // ë°ì´í„° ì…ë ¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ìë™ ì €ì¥ + ê²€ìƒ‰)
      $input.addEventListener('input', (e) => {
        const text = e.target.value;
        
        // ì‹¤ì‹œê°„ BIT ê³„ì‚° (ì¦‰ì‹œ)
        updateDataBitDisplay(text);

        if (!isAutoEnabled) return;

        // ìë™ ì²˜ë¦¬ (ë””ë°”ìš´ì‹±)
        if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
        
        inputDebounceTimer = setTimeout(() => {
          if (text !== lastInput) {
            lastInput = text;
            processInput(text); // ì—¬ê¸°ì„œ ìë™ ì €ì¥ + ê²€ìƒ‰
          }
        }, 500); // 0.5ì´ˆ í›„ ì²˜ë¦¬
      });

      // ì €ì¥ ë²„íŠ¼ í´ë¦­
      $saveBtn.addEventListener('click', saveAttributeData);

      // ìë™í™” í† ê¸€
      $toggleAutoBtn.addEventListener('click', async () => {
        const isConnected = await testServerConnection();
        if (!isConnected) {
          alert('ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ê°€ http://localhost:8123 ì—ì„œ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.');
          return;
        }

        isAutoEnabled = !isAutoEnabled;
        
        if (isAutoEnabled) {
          $autoStatus.textContent = 'â–¶ï¸ í™œì„±';
          $autoStatus.className = 'auto-status status-active';
          $toggleAutoBtn.textContent = 'ìë™í™” ë¹„í™œì„±í™”';
          
          // í˜„ì¬ ì…ë ¥ëœ í…ìŠ¤íŠ¸ë¡œ ì¦‰ì‹œ ì²˜ë¦¬
          const text = $input.value.trim();
          if (text) {
            processInput(text);
          }
        } else {
          $autoStatus.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
          $autoStatus.className = 'auto-status status-paused';
          $toggleAutoBtn.textContent = 'ìë™í™” í™œì„±í™”';
          
          if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
          if (searchTimer) clearTimeout(searchTimer);
        }
      });

      // ì¶œë ¥ ì§€ìš°ê¸°
      $clearOutputBtn.addEventListener('click', () => {
        $realtimeOutput.innerHTML = '';
      });

      // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
      addOutput('ì‹¤ì‹œê°„ ìë™í™” ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ê³  "ìë™í™” í™œì„±í™”"ë¥¼ í´ë¦­í•˜ì„¸ìš”.', 'info');
    })();
    </script>
</body>
</html>

