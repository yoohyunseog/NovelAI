<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ì‹¤ì‹œê°„ ìë™í™” ì‹œìŠ¤í…œ</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://xn--9l4b4xi9r.com/_8%EB%B9%84%ED%8A%B8/js/bitCalculation.js" defer></script>
    <style>
        .input-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .output-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
        }
        .bit-display {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            background: white;
            color: #333;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }
        .auto-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }
        .status-active {
            background: #28a745;
            color: white;
        }
        .status-paused {
            background: #ffc107;
            color: #333;
        }
        .result-item {
            border-left: 3px solid #007bff;
            padding: 10px;
            margin: 10px 0;
            background: white;
            border-radius: 5px;
            transition: all 0.3s;
        }
        .result-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: translateX(5px);
        }
        .similarity-badge {
            font-size: 0.85em;
            padding: 3px 8px;
        }
        .input-textarea {
            font-size: 1.1em;
            min-height: 120px;
        }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <h2 class="mb-4">âš¡ ì‹¤ì‹œê°„ ìë™í™” ì‹œìŠ¤í…œ</h2>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ì…ë ¥ ì„¹ì…˜ -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="input-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h4 class="mb-0">ğŸ“ ì‹¤ì‹œê°„ ì…ë ¥</h4>
                        <div>
                            <span class="auto-status" id="autoStatus">â¸ï¸ ì¼ì‹œì •ì§€</span>
                            <button id="toggleAutoBtn" class="btn btn-light btn-sm ms-2">ìë™í™” í™œì„±í™”</button>
                        </div>
                    </div>
                    
                    <!-- ì†ì„± ì…ë ¥ -->
                    <div class="mb-3">
                        <label class="form-label fw-bold">1ë‹¨ê³„: ì†ì„± (ë¬¸ì ì…ë ¥)</label>
                        <textarea 
                            id="attributeInput" 
                            class="form-control input-textarea" 
                            placeholder="ì†ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                            rows="2"
                        ></textarea>
                        <div class="row mt-2">
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ì†ì„± BIT MAX:</strong> <span id="attributeMax">-</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ì†ì„± BIT MIN:</strong> <span id="attributeMin">-</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ë°ì´í„° ì…ë ¥ -->
                    <div class="mb-3 border-top pt-3">
                        <label class="form-label fw-bold">2ë‹¨ê³„: ë°ì´í„° (ë¬¸ì ì…ë ¥)</label>
                        <textarea 
                            id="realtimeInput" 
                            class="form-control input-textarea" 
                            placeholder="ì´ ì†ì„±ì— ì €ì¥í•  ë°ì´í„°(í…ìŠ¤íŠ¸)ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                            rows="3"
                        ></textarea>
                        <div class="row mt-2">
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ë°ì´í„° BIT MAX:</strong> <span id="calculatedMax">-</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ë°ì´í„° BIT MIN:</strong> <span id="calculatedMin">-</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ì €ì¥ ë²„íŠ¼ -->
                    <div class="mt-3">
                        <button id="saveBtn" class="btn btn-light">ì†ì„±ì— ë°ì´í„° ì €ì¥</button>
                        <span id="saveStatus" class="ms-2 small"></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ì¶œë ¥ ì„¹ì…˜ -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="output-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h5>ğŸ“Š ì‹¤ì‹œê°„ ì¶œë ¥</h5>
                        <button id="clearOutputBtn" class="btn btn-sm btn-outline-secondary">ì¶œë ¥ ì§€ìš°ê¸°</button>
                    </div>
                    <div id="realtimeOutput"></div>
                </div>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ì¡°íšŒ ê²°ê³¼ -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <strong>ğŸ” ì‹¤ì‹œê°„ ì¡°íšŒ ê²°ê³¼</strong>
                        <span id="resultCount" class="badge bg-secondary">0ê°œ</span>
                    </div>
                    <div class="card-body">
                        <div id="searchStatus" class="small text-muted mb-2"></div>
                        <div class="table-responsive" style="max-height: 500px; overflow-y: auto;">
                            <table class="table table-sm table-hover">
                                <thead class="table-light sticky-top">
                                    <tr>
                                        <th style="width: 5%;">#</th>
                                        <th style="width: 15%;">ì‹œê°„</th>
                                        <th style="width: 12%;">BIT_MAX</th>
                                        <th style="width: 12%;">BIT_MIN</th>
                                        <th style="width: 20%;">ì†ì„±</th>
                                        <th style="width: 26%;">ë°ì´í„°</th>
                                        <th style="width: 10%;">ìœ ì‚¬ë„</th>
                                    </tr>
                                </thead>
                                <tbody id="resultBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    (function(){
      const $attributeInput = document.getElementById('attributeInput');
      const $attributeMax = document.getElementById('attributeMax');
      const $attributeMin = document.getElementById('attributeMin');
      const $input = document.getElementById('realtimeInput');
      const $calculatedMax = document.getElementById('calculatedMax');
      const $calculatedMin = document.getElementById('calculatedMin');
      const $autoStatus = document.getElementById('autoStatus');
      const $toggleAutoBtn = document.getElementById('toggleAutoBtn');
      const $realtimeOutput = document.getElementById('realtimeOutput');
      const $clearOutputBtn = document.getElementById('clearOutputBtn');
      const $resultBody = document.getElementById('resultBody');
      const $resultCount = document.getElementById('resultCount');
      const $searchStatus = document.getElementById('searchStatus');
      const $saveBtn = document.getElementById('saveBtn');
      const $saveStatus = document.getElementById('saveStatus');

      let isAutoEnabled = false;
      let inputDebounceTimer = null;
      let searchTimer = null;
      let lastInput = '';
      let lastAttribute = '';

      function getServerUrl(path) {
        if (window.location.protocol === 'file:') {
          return `http://localhost:8123${path}`;
        }
        return path;
      }

      async function testServerConnection() {
        try {
          const res = await fetch(getServerUrl('/health'));
          return res.ok;
        } catch {
          return false;
        }
      }

      function calculateBitValues(text) {
        if (!text || typeof text !== 'string' || text.trim() === '') {
          return { max: null, min: null };
        }
        try {
          if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
            console.warn('BIT ê³„ì‚° í•¨ìˆ˜ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            return { max: null, min: null };
          }
          const unicodeArray = wordNbUnicodeFormat(text);
          const max = BIT_MAX_NB(unicodeArray);
          const min = BIT_MIN_NB(unicodeArray);
          return { max: isFinite(max) ? max : null, min: isFinite(min) ? min : null };
        } catch (e) {
          console.error('BIT ê³„ì‚° ì˜¤ë¥˜:', e);
          return { max: null, min: null };
        }
      }

      function addOutput(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString('ko-KR');
        const div = document.createElement('div');
        div.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} alert-dismissible fade show`;
        div.style.fontSize = '0.9em';
        div.innerHTML = `
          <small class="text-muted">[${timestamp}]</small> ${message}
          <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        $realtimeOutput.insertBefore(div, $realtimeOutput.firstChild);
      }

      async function autoSaveAttributeData(attributeText, dataText) {
        if (!attributeText || !dataText) return;

        const attrBits = calculateBitValues(attributeText);
        const dataBits = calculateBitValues(dataText);

        if (!attrBits.max || !attrBits.min || !dataBits.max || !dataBits.min) {
          return;
        }

        try {
          const url = getServerUrl('/api/attributes/data');
          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              attributeBitMax: attrBits.max,
              attributeBitMin: attrBits.min,
              attributeText: attributeText,
              text: dataText,
              dataBitMax: dataBits.max,
              dataBitMin: dataBits.min
            })
          });

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }

          const data = await res.json();
          if (data.ok) {
            if (data.duplicate) {
              $saveStatus.textContent = `âš  ìë™ ì €ì¥: ${data.message || 'ì´ë¯¸ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.'}`;
              $saveStatus.style.color = '#ffc107';
              addOutput(`âš  ì†ì„± "${attributeText}"ì— ë°ì´í„° "${dataText}" ìë™ ì €ì¥ ì‹œë„ (ì¤‘ë³µ)`, 'warning');
            } else {
              $saveStatus.textContent = 'âœ“ ìë™ ì €ì¥ ì™„ë£Œ!';
              $saveStatus.style.color = '#28a745';
              addOutput(`âœ“ ì†ì„± "${attributeText}"ì— ë°ì´í„° "${dataText}" ìë™ ì €ì¥ ì™„ë£Œ`, 'success');
              // ìë™ ì €ì¥ í›„ ë°ì´í„° ì…ë ¥ë€ì€ ìœ ì§€ (ì‚¬ìš©ìê°€ ê³„ì† ì…ë ¥í•  ìˆ˜ ìˆë„ë¡)
            }
          } else {
            throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
          }
        } catch (e) {
          console.error('ìë™ ì €ì¥ ì˜¤ë¥˜:', e);
          $saveStatus.textContent = `âœ— ìë™ ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
          $saveStatus.style.color = '#dc3545';
          addOutput(`ìë™ ì €ì¥ ì˜¤ë¥˜: ${e.message}`, 'error');
        }
      }

      async function saveAttributeData() {
        const attributeText = $attributeInput.value.trim();
        const dataText = $input.value.trim();

        if (!attributeText) {
          $saveStatus.textContent = 'ì†ì„± í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ì…ë ¥í•˜ì„¸ìš”.';
          $saveStatus.style.color = '#dc3545';
          return;
        }

        if (!dataText) {
          $saveStatus.textContent = 'ë°ì´í„° í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
          $saveStatus.style.color = '#dc3545';
          return;
        }

        await autoSaveAttributeData(attributeText, dataText);
      }

      async function autoSave(text, bitMax, bitMin) {
        if (!text || !bitMax || !bitMin) return;

        try {
          // ìë™ ì €ì¥ì€ ë¹„í™œì„±í™” (ëª…ì‹œì  ì €ì¥ë§Œ)
          addOutput(`ì…ë ¥ í…ìŠ¤íŠ¸: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}" (BIT: ${bitMax.toFixed(6)}, ${bitMin.toFixed(6)})`, 'info');
        } catch (e) {
          addOutput(`ì €ì¥ ì˜¤ë¥˜: ${e.message}`, 'error');
        }
      }

      async function autoSearch(bitMax, bitMin) {
        if (!bitMax || !bitMin) return;

        try {
          $searchStatus.textContent = 'ê²€ìƒ‰ ì¤‘...';
          $searchStatus.style.color = '#007bff';

          let results = [];
          const attributeText = $attributeInput.value.trim();
          const dataText = $input.value.trim();

          // 1. ì†ì„±ì´ ìˆìœ¼ë©´ í•´ë‹¹ ì†ì„±ì˜ ë°ì´í„° ì¡°íšŒ
          if (attributeText) {
            try {
              const attrBits = calculateBitValues(attributeText);
              if (attrBits.max && attrBits.min) {
                const url = getServerUrl(`/api/attributes/data?bitMax=${attrBits.max}&bitMin=${attrBits.min}&limit=20&similarity=true&threshold=0.1`);
                const res = await fetch(url);

                if (res.ok) {
                  const data = await res.json();
                  if (data.ok && data.items) {
                    results.push(...data.items.map(item => {
                      // ë°ì´í„° BIT ê°’ìœ¼ë¡œ ìœ ì‚¬ë„ ê³„ì‚°
                      const dataBitMaxDiff = Math.abs((bitMax || 0) - (item.data?.bitMax || item.max || 0));
                      const dataBitMinDiff = Math.abs((bitMin || 0) - (item.data?.bitMin || item.min || 0));
                      const dataDistance = Math.sqrt(dataBitMaxDiff * dataBitMaxDiff + dataBitMinDiff * dataBitMinDiff);
                      const dataSimilarity = Math.max(0, 1 / (1 + dataDistance));
                      
                      // ì†ì„± ìœ ì‚¬ë„ì™€ ë°ì´í„° ìœ ì‚¬ë„ì˜ í‰ê· 
                      const avgSimilarity = item.similarity ? (item.similarity + dataSimilarity) / 2 : dataSimilarity;
                      
                      return {
                        ...item,
                        source: 'attribute_data',
                        input: item.attribute?.text || attributeText,
                        response: item.data?.text || item.s || '',
                        similarity: avgSimilarity
                      };
                    }));
                    console.log('[Search] ì†ì„± ë°ì´í„° ì¡°íšŒ:', data.items.length, 'ê°œ');
                  }
                }
              }
            } catch (e) {
              console.warn('ì†ì„± ë°ì´í„° ê²€ìƒ‰ ì˜¤ë¥˜:', e);
            }
          }

          // 2. ë°ì´í„° BIT ê°’ìœ¼ë¡œë„ ê²€ìƒ‰ (ë°ì´í„°ê°€ ë‹¤ë¥¸ ì†ì„±ì— ì €ì¥ë˜ì–´ ìˆì„ ìˆ˜ ìˆìŒ)
          try {
            // ë°ì´í„° BIT ê°’ìœ¼ë¡œ MAX/MIN í´ë”ì—ì„œ ê²€ìƒ‰
            const maxUrl = getServerUrl(`/api/log/by-max?nb_max=${bitMax}&n=10`);
            const minUrl = getServerUrl(`/api/log/by-min?nb_min=${bitMin}&n=10`);
            
            const [maxRes, minRes] = await Promise.all([fetch(maxUrl), fetch(minUrl)]);
            
            if (maxRes.ok) {
              const maxData = await maxRes.json();
              if (maxData.ok && maxData.items) {
                // ì†ì„± ë°ì´í„°ë§Œ í•„í„°ë§
                const attrItems = maxData.items.filter(item => item.attribute).map(item => ({
                  ...item,
                  source: 'attribute_data_by_data',
                  input: item.attribute?.text || '',
                  response: item.data?.text || item.s || '',
                  similarity: 1.0 // ì •í™• ì¼ì¹˜
                }));
                results.push(...attrItems);
              }
            }
            
            if (minRes.ok) {
              const minData = await minRes.json();
              if (minData.ok && minData.items) {
                // ì†ì„± ë°ì´í„°ë§Œ í•„í„°ë§
                const attrItems = minData.items.filter(item => item.attribute).map(item => ({
                  ...item,
                  source: 'attribute_data_by_data',
                  input: item.attribute?.text || '',
                  response: item.data?.text || item.s || '',
                  similarity: 1.0 // ì •í™• ì¼ì¹˜
                }));
                results.push(...attrItems);
              }
            }
          } catch (e) {
            console.warn('ë°ì´í„° BIT ê²€ìƒ‰ ì˜¤ë¥˜:', e);
          }

          // 3. ìœ ì‚¬ë„ ê²€ìƒ‰ (training ë°ì´í„°)
          try {
            const url = getServerUrl('/api/training/similar');
            const res = await fetch(url, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                query: '',
                queryBitMax: bitMax,
                queryBitMin: bitMin,
                limit: 10
              })
            });

            if (res.ok) {
              const data = await res.json();
              if (data.ok && data.items) {
                results.push(...data.items.map(item => ({
                  ...item,
                  source: 'training',
                  similarity: item.similarity_score || 0
                })));
              }
            }
          } catch (e) {
            console.warn('ìœ ì‚¬ë„ ê²€ìƒ‰ ì˜¤ë¥˜:', e);
          }

          // ì¤‘ë³µ ì œê±° ë° ì •ë ¬
          const seen = new Set();
          const uniqueResults = [];
          results.forEach(item => {
            const key = `${item.t || ''}_${item.input || item.attribute?.text || ''}_${item.response || item.data?.text || item.s || ''}`;
            if (!seen.has(key)) {
              seen.add(key);
              uniqueResults.push(item);
            }
          });

          uniqueResults.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));
          const finalResults = uniqueResults.slice(0, 20);

          renderResults(finalResults);
          $resultCount.textContent = `${finalResults.length}ê°œ`;
          $searchStatus.textContent = `âœ“ ê²€ìƒ‰ ì™„ë£Œ (${finalResults.length}ê°œ ê²°ê³¼)`;
          $searchStatus.style.color = '#28a745';

        } catch (e) {
          console.error('ê²€ìƒ‰ ì˜¤ë¥˜:', e);
          $searchStatus.textContent = `âœ— ê²€ìƒ‰ ì‹¤íŒ¨: ${e.message}`;
          $searchStatus.style.color = '#dc3545';
        }
      }

      function renderResults(results) {
        $resultBody.innerHTML = '';
        
        if (results.length === 0) {
          $resultBody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</td></tr>';
          return;
        }

        results.forEach((item, idx) => {
          const tr = document.createElement('tr');
          
          const time = item.t ? new Date(item.t).toLocaleString('ko-KR') : (item.timestamp || '');
          
          const bitMax = (item.attribute && item.attribute.bitMax != null) ? String(item.attribute.bitMax) : 
                        (item.bit && item.bit.max != null) ? String(item.bit.max) : 
                        (item.nb_max != null ? String(item.nb_max) : '');
          const bitMin = (item.attribute && item.attribute.bitMin != null) ? String(item.attribute.bitMin) : 
                        (item.bit && item.bit.min != null) ? String(item.bit.min) : 
                        (item.nb_min != null ? String(item.nb_min) : '');
          
          const input = item.input || item.attribute?.text || item.input_text || '';
          const response = item.response || item.data?.text || item.s || item.output || '';
          const similarity = item.similarity != null ? (item.similarity * 100).toFixed(1) + '%' : '100%';
          
          const similarityClass = item.similarity >= 0.9 ? 'bg-success' : item.similarity >= 0.7 ? 'bg-warning' : 'bg-danger';
          
          tr.innerHTML = `
            <td>${idx + 1}</td>
            <td><small>${time}</small></td>
            <td><code>${bitMax.substring(0, 10)}${bitMax.length > 10 ? '...' : ''}</code></td>
            <td><code>${bitMin.substring(0, 10)}${bitMin.length > 10 ? '...' : ''}</code></td>
            <td>${input.substring(0, 30)}${input.length > 30 ? '...' : ''}</td>
            <td>${response.substring(0, 40)}${response.length > 40 ? '...' : ''}</td>
            <td><span class="badge ${similarityClass} similarity-badge">${similarity}</span></td>
          `;
          
          $resultBody.appendChild(tr);
        });
      }

      function updateBitDisplay(text, $maxEl, $minEl) {
        const { max, min } = calculateBitValues(text);
        if ($maxEl) $maxEl.textContent = max !== null ? max.toFixed(10) : '-';
        if ($minEl) $minEl.textContent = min !== null ? min.toFixed(10) : '-';
        return { max, min };
      }

      function updateAttributeBitDisplay(text) {
        return updateBitDisplay(text, $attributeMax, $attributeMin);
      }

      function updateDataBitDisplay(text) {
        return updateBitDisplay(text, $calculatedMax, $calculatedMin);
      }

      async function processInput(text) {
        if (!text || text.trim() === '') {
          updateDataBitDisplay('');
          return;
        }

        const { max, min } = updateDataBitDisplay(text);

        if (max !== null && min !== null) {
          // ì†ì„±ê³¼ ë°ì´í„°ê°€ ëª¨ë‘ ì…ë ¥ë˜ì–´ ìˆìœ¼ë©´ ìë™ ì €ì¥ (ì €ì¥ê³¼ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰)
          const attributeText = $attributeInput.value.trim();
          if (attributeText) {
            // ìë™ ì €ì¥ (ë””ë°”ìš´ì‹±) - ì €ì¥ ê²°ê³¼ì™€ ê´€ê³„ì—†ì´ ì‹¤í–‰
            if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
            inputDebounceTimer = setTimeout(async () => {
              await autoSaveAttributeData(attributeText, text);
              // ì €ì¥ í›„ì—ë„ ê²€ìƒ‰ì€ ë³„ë„ë¡œ ì‹¤í–‰ë¨ (ì¤‘ë³µì´ì–´ë„ ìƒê´€ì—†ì´)
            }, 1000); // 1ì´ˆ í›„ ìë™ ì €ì¥
          }

          // ìë™ ê²€ìƒ‰ (ì €ì¥ê³¼ ë…ë¦½ì ìœ¼ë¡œ ì‹¤í–‰, ì¤‘ë³µì´ì–´ë„ ê²€ìƒ‰ ìˆ˜í–‰)
          if (searchTimer) clearTimeout(searchTimer);
          searchTimer = setTimeout(() => {
            autoSearch(max, min); // ì¤‘ë³µ ì €ì¥ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ í•­ìƒ ê²€ìƒ‰ ì‹¤í–‰
          }, 1000); // 1ì´ˆ í›„ ê²€ìƒ‰ (ì €ì¥ê³¼ ë™ì‹œì— ì‹¤í–‰ ê°€ëŠ¥)
        }
      }

      function processAttributeInput(text) {
        if (!text || text.trim() === '') {
          updateAttributeBitDisplay('');
          return;
        }

        // ì†ì„± ì…ë ¥ì—ì„œëŠ” BIT ê³„ì‚°ë§Œ í•˜ê³  ê²€ìƒ‰ì€ í•˜ì§€ ì•ŠìŒ
        updateAttributeBitDisplay(text);
      }

      // ì†ì„± ì…ë ¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ê²€ìƒ‰í•˜ì§€ ì•ŠìŒ, BIT ê³„ì‚°ë§Œ)
      $attributeInput.addEventListener('input', (e) => {
        const text = e.target.value;
        processAttributeInput(text);
        // ì†ì„± ì…ë ¥ì—ì„œëŠ” ê²€ìƒ‰í•˜ì§€ ì•ŠìŒ
      });

      // ë°ì´í„° ì…ë ¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ìë™ ì €ì¥ + ê²€ìƒ‰)
      $input.addEventListener('input', (e) => {
        const text = e.target.value;
        
        // ì‹¤ì‹œê°„ BIT ê³„ì‚° (ì¦‰ì‹œ)
        updateDataBitDisplay(text);

        if (!isAutoEnabled) return;

        // ìë™ ì²˜ë¦¬ (ë””ë°”ìš´ì‹±)
        if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
        
        inputDebounceTimer = setTimeout(() => {
          if (text !== lastInput) {
            lastInput = text;
            processInput(text); // ì—¬ê¸°ì„œ ìë™ ì €ì¥ + ê²€ìƒ‰
          }
        }, 500); // 0.5ì´ˆ í›„ ì²˜ë¦¬
      });

      // ì €ì¥ ë²„íŠ¼ í´ë¦­
      $saveBtn.addEventListener('click', saveAttributeData);

      // ìë™í™” í† ê¸€
      $toggleAutoBtn.addEventListener('click', async () => {
        const isConnected = await testServerConnection();
        if (!isConnected) {
          alert('ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ê°€ http://localhost:8123 ì—ì„œ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.');
          return;
        }

        isAutoEnabled = !isAutoEnabled;
        
        if (isAutoEnabled) {
          $autoStatus.textContent = 'â–¶ï¸ í™œì„±';
          $autoStatus.className = 'auto-status status-active';
          $toggleAutoBtn.textContent = 'ìë™í™” ë¹„í™œì„±í™”';
          
          // í˜„ì¬ ì…ë ¥ëœ í…ìŠ¤íŠ¸ë¡œ ì¦‰ì‹œ ì²˜ë¦¬
          const text = $input.value.trim();
          if (text) {
            processInput(text);
          }
        } else {
          $autoStatus.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
          $autoStatus.className = 'auto-status status-paused';
          $toggleAutoBtn.textContent = 'ìë™í™” í™œì„±í™”';
          
          if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
          if (searchTimer) clearTimeout(searchTimer);
        }
      });

      // ì¶œë ¥ ì§€ìš°ê¸°
      $clearOutputBtn.addEventListener('click', () => {
        $realtimeOutput.innerHTML = '';
      });

      // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
      addOutput('ì‹¤ì‹œê°„ ìë™í™” ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ê³  "ìë™í™” í™œì„±í™”"ë¥¼ í´ë¦­í•˜ì„¸ìš”.', 'info');
    })();
    </script>
</body>
</html>

