# 상위 속성 계층 구조 설계 구도
## Hierarchy Design for Parent Attributes

---

## 🎯 문제 상황

### 속성이 많아질 때
```
초기 상태:
  속성1: "반지의 제왕"
  속성2: "호빗"
  속성3: "실마릴리온"

속성들이 늘어남:
  속성4: "간달프"
  속성5: "프로도"
  속성6: "아라곤"
  속성7: "프로도"
  속성8: "엘론드"
  ...
  속성100: "엘프"
  속성101: "드워프"
  속성102: "오크"

→ 관리가 어려워짐!
→ 유사한 속성들이 흩어져 있음
→ 구조화가 필요함
```

### 자연스러운 클러스터 형성
```
BIT 공간에서 자동으로 클러스터 생성:
  클러스터 A:
    - "반지의 제왕" (3.06, 2.66)
    - "호빗" (3.12, 2.70)
    - "실마릴리온" (3.08, 2.68)
    → 모두 가까이 있음 (거리 < 0.5)

  클러스터 B:
    - "엘프" (4.20, 3.10)
    - "엘론드" (4.18, 3.12)
    - "리벤델" (4.22, 3.08)
    → 모두 가까이 있음

  클러스터 C:
    - "드워프" (5.30, 4.20)
    - "모리아" (5.28, 4.22)
    → 모두 가까이 있음
```

### 상위 속성의 필요성
```
각 클러스터를 하나의 개념으로 묶고 싶음:

  클러스터 A → 상위 속성: "톨킨 세계관"
  클러스터 B → 상위 속성: "엘프 종족"
  클러스터 C → 상위 속성: "드워프 종족"

또는 더 큰 범위:
  클러스터 A + B + C → 상위 속성: "판타지 세계"
```

---

## 🏗️ 설계 모델

### 모델 1: 명시적 상위 속성 (Explicit Parent Attribute)

**구조:**
```
상위 속성: "톨킨 세계관"
  ├─ 속성: "반지의 제왕"
  │   ├─ 데이터: "원정대"
  │   └─ 데이터: "골룸"
  ├─ 속성: "호빗"
  │   ├─ 데이터: "샤이어"
  │   └─ 데이터: "바긴스"
  └─ 속성: "실마릴리온"
      └─ 데이터: "실마릴"
```

**데이터 구조:**
```json
// 하위 속성 레코드에 상위 속성 정보 추가
{
  "cellId": "attr_반지의제왕",
  "cellType": "attribute",
  "position": {
    "bitMax": 3.063923076923077,
    "bitMin": 2.660476923076924
  },
  "content": {
    "text": "반지의 제왕"
  },
  "parentAttribute": {  // ← 신규 필드
    "cellId": "attr_톨킨세계관",
    "text": "톨킨 세계관",
    "bitMax": 3.50,  // 클러스터 중심 또는 사용자 지정
    "bitMin": 2.50
  },
  "children": ["data_원정대", "data_골룸"]
}
```

**저장 방식:**
```
1. 상위 속성도 일반 속성처럼 저장
   - 상위 속성 "톨킨 세계관"의 BIT 값으로 MAX/MIN 폴더에 저장

2. 하위 속성 저장 시 상위 속성 정보 포함
   - 하위 속성 레코드에 parentAttribute 필드 추가
   - 상위 속성의 BIT 값으로도 추가 저장 (선택적)
```

---

### 모델 2: 자동 클러스터 기반 상위 속성 (Auto Cluster)

**구조:**
```
클러스터 감지 → 자동으로 상위 속성 생성

클러스터 ID: "cluster_1"
  중심: (BIT_MAX: 3.10, BIT_MIN: 2.68)
  포함 속성:
    - "반지의 제왕"
    - "호빗"
    - "실마릴리온"
  
→ 자동 생성 상위 속성: "Cluster_1" 또는 "판타지_소설_그룹_1"
```

**데이터 구조:**
```json
// 클러스터 메타데이터
{
  "clusterId": "cluster_1",
  "center": {
    "bitMax": 3.10,
    "bitMin": 2.68
  },
  "autoGeneratedParent": {
    "text": "판타지_소설_그룹_1",  // 자동 생성 이름
    "bitMax": 3.10,  // 클러스터 중심
    "bitMin": 2.68,
    "generatedAt": "2025-10-31T23:00:00Z"
  },
  "cellIds": [
    "attr_반지의제왕",
    "attr_호빗",
    "attr_실마릴리온"
  ]
}
```

---

### 모델 3: 다중 계층 상위 속성 (Multi-Level Hierarchy)

**구조:**
```
1차 상위 속성: "판타지 세계"
  ├─ 2차 상위 속성: "톨킨 세계관"
  │   ├─ 속성: "반지의 제왕"
  │   ├─ 속성: "호빗"
  │   └─ 속성: "실마릴리온"
  ├─ 2차 상위 속성: "해리포터 세계관"
  │   ├─ 속성: "해리포터"
  │   └─ 속성: "호그와트"
  └─ 2차 상위 속성: "게임 오브 스론즈"
      └─ 속성: "웨스테로스"
```

**데이터 구조:**
```json
// 2차 상위 속성 레코드
{
  "cellId": "attr_톨킨세계관",
  "cellType": "attribute",
  "content": {
    "text": "톨킨 세계관"
  },
  "parentAttribute": {  // 1차 상위 속성
    "cellId": "attr_판타지세계",
    "text": "판타지 세계",
    "bitMax": 4.0,
    "bitMin": 3.0
  },
  "children": [
    "attr_반지의제왕",  // 하위 속성들
    "attr_호빗",
    "attr_실마릴리온"
  ],
  "hierarchyLevel": 2  // 계층 레벨
}
```

---

## 🔄 상위 속성 생성 방법

### 방법 1: 수동 생성 (Manual Creation)

**사용자가 직접 생성:**
```
1. 사용자가 "톨킨 세계관" 텍스트 입력
2. BIT 값 계산 (또는 클러스터 중심 사용)
3. 하위 속성들을 선택하여 연결
4. 저장
```

**장점:**
- 사용자 의도 반영 가능
- 의미 있는 이름 지정

**단점:**
- 수동 작업 필요

---

### 방법 2: 자동 클러스터 기반 (Auto Cluster-Based)

**클러스터 감지 → 자동 상위 속성 생성:**
```
1단계: 모든 속성 수집
2단계: 클러스터 감지 (DBSCAN 또는 밀도 기반)
3단계: 각 클러스터에 대해:
   - 클러스터 중심 계산
   - 임시 상위 속성 생성 (이름: "Cluster_{ID}" 또는 GPT로 생성)
   - 하위 속성들 연결
4단계: 사용자에게 확인 및 이름 수정 기회 제공
5단계: 저장
```

**장점:**
- 자동화
- 빠른 구조화

**단점:**
- 이름이 비의미적일 수 있음 (GPT로 보완 가능)

---

### 방법 3: GPT 기반 자동 생성 (GPT-Assisted)

**클러스터 → GPT 분석 → 의미 있는 이름:**
```
1단계: 클러스터 감지
2단계: 클러스터 내 속성 텍스트 수집
   예: ["반지의 제왕", "호빗", "실마릴리온"]
3단계: GPT에게 질문:
   "다음 속성들을 묶는 상위 카테고리는?"
   → GPT 응답: "톨킨 세계관" 또는 "중간계 관련"
4단계: GPT가 생성한 이름으로 상위 속성 생성
```

**장점:**
- 의미 있는 이름 자동 생성
- 사용자 편의성 향상

**단점:**
- GPT API 호출 필요 (비용)

---

### 방법 4: 하이브리드 (Hybrid)

**자동 감지 + 사용자 확인/수정:**
```
1단계: 자동 클러스터 감지
2단계: GPT로 임시 이름 생성 (선택적)
3단계: 사용자에게 제안:
   - "다음 속성들을 하나로 묶을까요?"
   - 속성 목록 표시
   - 자동 생성 이름 제안
   - 사용자가 확인/수정/거부
4단계: 저장
```

**권장: 방법 4 (하이브리드)**

---

## 💾 저장 구조 설계

### 옵션 A: 기존 구조 확장

**상위 속성도 일반 속성처럼 저장:**
```
상위 속성 "톨킨 세계관":
  - BIT 값 계산 → MAX/MIN 폴더에 저장 (일반 속성처럼)
  - 레코드에 hierarchyLevel 필드 추가
  - 레코드에 children 필드 추가 (하위 속성 ID 목록)
```

**하위 속성 레코드 확장:**
```json
{
  "timestamp": "...",
  "t": ...,
  "s": "원정대",
  "max": 2.9828260869565213,
  "min": 2.7721739130434786,
  "attribute": {
    "text": "반지의 제왕",
    "bitMax": 3.063923076923077,
    "bitMin": 2.660476923076924,
    "parentAttribute": {  // ← 신규
      "text": "톨킨 세계관",
      "bitMax": 3.50,
      "bitMin": 2.50,
      "cellId": "attr_톨킨세계관"
    },
    "hierarchyLevel": 1  // 0=최상위, 1=하위, 2=하위의 하위
  },
  "data": {
    "text": "원정대",
    ...
  }
}
```

**저장 위치:**
```
1. 상위 속성 BIT 값으로도 저장 (선택적)
   - 속성 BIT_MAX/MIN + 상위 속성 BIT_MAX/MIN → 8곳 저장?
   - 아니면 상위 속성은 별도 저장 (메타데이터만)

2. 권장: 상위 속성은 별도 저장 (honeycomb/ 메타데이터)
   - 기존 MAX/MIN 구조는 유지
   - 계층 정보는 메타데이터로 관리
```

---

### 옵션 B: 메타데이터 분리 저장

**계층 정보는 별도 파일로:**
```
data/
├─ max/... (기존 구조 유지)
├─ min/... (기존 구조 유지)
└─ honeycomb/
    └─ hierarchy/
        ├─ parents.json  // 상위 속성 정의
        └─ children_map.json  // 하위 속성 매핑
```

**parents.json:**
```json
{
  "attr_톨킨세계관": {
    "cellId": "attr_톨킨세계관",
    "text": "톨킨 세계관",
    "bitMax": 3.50,
    "bitMin": 2.50,
    "hierarchyLevel": 0,
    "createdAt": "...",
    "autoGenerated": false
  }
}
```

**children_map.json:**
```json
{
  "attr_반지의제왕": "attr_톨킨세계관",
  "attr_호빗": "attr_톨킨세계관",
  "attr_실마릴리온": "attr_톨킨세계관"
}
```

**권장: 옵션 B (메타데이터 분리)**

---

## 🔍 검색 확장

### 검색 시나리오

**시나리오 1: 상위 속성으로 검색**
```
검색: "톨킨 세계관"
  → 상위 속성 찾기
  → 하위 속성들 모두 수집
  → 각 하위 속성의 데이터들 모두 수집
  → 결과 반환
```

**시나리오 2: 하위 속성 검색 시 상위 속성도 표시**
```
검색: "반지의 제왕"
  → 속성 찾기
  → parentAttribute 확인
  → "톨킨 세계관" 정보도 함께 표시
  → 관련 하위 속성들도 제안
```

**시나리오 3: 계층 탐색**
```
검색: "판타지 세계"
  → 1차 상위 속성 찾기
  → 2차 상위 속성들 수집
  → 각 2차 상위 속성의 하위 속성들 수집
  → 모든 데이터 수집
  → 계층 구조로 표시
```

---

## 🎨 UI 설계

### 계층 구조 표시

**트리 뷰:**
```
📁 판타지 세계
  ├─ 📁 톨킨 세계관
  │   ├─ 📄 반지의 제왕
  │   │   ├─ 원정대
  │   │   └─ 골룸
  │   ├─ 📄 호빗
  │   │   └─ 샤이어
  │   └─ 📄 실마릴리온
  ├─ 📁 해리포터 세계관
  │   └─ ...
  └─ 📁 게임 오브 스론즈
      └─ ...
```

**카드 그룹:**
```
┌─────────────────────────┐
│ 상위 속성: 톨킨 세계관   │
├─────────────────────────┤
│ [반지의 제왕] [호빗]     │
│ [실마릴리온]             │
│                         │
│ 전체 데이터: 15개        │
└─────────────────────────┘
```

---

## 🔄 구현 단계

### Phase 1: 명시적 상위 속성 생성 (수동)
- 사용자가 상위 속성 텍스트 입력
- 하위 속성 선택 UI
- parentAttribute 필드 추가
- 저장 및 검색

### Phase 2: 자동 클러스터 감지
- 클러스터 감지 알고리즘
- 클러스터 중심 계산
- 상위 속성 후보 제안

### Phase 3: GPT 기반 이름 생성
- GPT API 연동
- 클러스터 분석 → 이름 생성
- 사용자 확인/수정

### Phase 4: 다중 계층 지원
- 2차, 3차 상위 속성
- 계층 탐색 기능
- 트리 구조 UI

---

## 🤔 논의 사항

### Q1: 상위 속성 생성 방식
- [ ] 수동만 (사용자가 직접 생성)
- [ ] 자동 클러스터 기반
- [ ] GPT 기반 자동 생성
- [ ] 하이브리드 (권장)

### Q2: 저장 구조
- [ ] 기존 MAX/MIN 구조에 통합
- [ ] 별도 메타데이터 파일 (권장)
- [ ] 혼합

### Q3: 계층 깊이
- [ ] 2단계만 (상위 속성 → 하위 속성)
- [ ] 다중 계층 (3단계 이상)
- [ ] 무제한

### Q4: 자동 생성 빈도
- [ ] 사용자 요청 시만
- [ ] 주기적으로 (예: 하루에 한 번)
- [ ] 실시간 (새 속성 추가 시마다)

---

## 📝 요약

### 핵심 아이디어
- **속성이 많아지면 → 클러스터 형성 → 상위 속성 필요**
- **상위 속성 = 여러 하위 속성을 묶는 카테고리**
- **생성 방식: 수동 / 자동 클러스터 / GPT 기반 / 하이브리드**

### 권장 설계
1. **저장 구조**: 메타데이터 분리 저장 (honeycomb/hierarchy/)
2. **생성 방식**: 하이브리드 (자동 감지 + 사용자 확인/수정)
3. **계층 깊이**: 2단계부터 시작, 필요 시 확장
4. **검색**: 상위 속성 검색 시 모든 하위 데이터 포함

---

**이제 속성들이 자연스럽게 그룹화되고, 더 체계적으로 관리할 수 있습니다!**

