<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>GPT AI ìë™í™” ì‹œìŠ¤í…œ</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://xn--9l4b4xi9r.com/_8%EB%B9%84%ED%8A%B8/js/bitCalculation.js" defer></script>
    <style>
        .gpt-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .input-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .result-section {
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            margin-bottom: 20px;
        }
        .bit-display {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            background: white;
            color: #333;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }
        .gpt-response {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            white-space: pre-wrap;
        }
        .auto-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: bold;
        }
        .status-active {
            background: #28a745;
            color: white;
        }
        .status-paused {
            background: #ffc107;
            color: #333;
        }
        .attribute-display, .data-display {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
        }
        .attribute-display {
            border-color: #007bff;
        }
        .data-display {
            border-color: #28a745;
        }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <h2 class="mb-4">ğŸ¤– GPT AI ìë™í™” ì‹œìŠ¤í…œ</h2>
            </div>
        </div>

        <!-- GPT ë¶„ì„ ì…ë ¥ ì„¹ì…˜ -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="gpt-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h4 class="mb-0">ğŸ’¬ GPT AI ì…ë ¥</h4>
                        <div>
                            <span class="auto-status" id="gptStatus">ì¤€ë¹„</span>
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label fw-bold">í”„ë¡¬í”„íŠ¸ ì…ë ¥ (ì„ íƒì‚¬í•­)</label>
                        <textarea 
                            id="gptPrompt" 
                            class="form-control mb-2" 
                            placeholder="GPTì—ê²Œ ì¶”ê°€ ì§€ì‹œì‚¬í•­ì„ ì…ë ¥í•˜ì„¸ìš”. ì˜ˆ: 'ì†Œì„¤ ê´€ë ¨ ë‚´ìš©ë§Œ ì¶”ì¶œí•´ì£¼ì„¸ìš”', 'ê²Œì„ ê´€ë ¨ í•­ëª©ìœ¼ë¡œ ë¶„ë¥˜í•´ì£¼ì„¸ìš”' ë“±... (ë¹„ì›Œë‘ë©´ ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©)"
                            rows="2"
                        ></textarea>
                        <label class="form-label fw-bold">ë¶„ì„í•  í…ìŠ¤íŠ¸ ì…ë ¥</label>
                        <textarea 
                            id="gptInput" 
                            class="form-control" 
                            placeholder="í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ë©´ GPT AIê°€ ì†ì„±ê³¼ ë°ì´í„°ë¡œ ìë™ ë¶„ë¦¬í•©ë‹ˆë‹¤. ì˜ˆ: 'ë°˜ì§€ì˜ ì œì™• ì†Œì„¤ì˜ ì›ì •ëŒ€ ì´ì•¼ê¸°'..."
                            rows="4"
                        ></textarea>
                    </div>
                    <button id="analyzeBtn" class="btn btn-light btn-lg w-100">
                        ğŸ” GPT AIë¡œ ë¶„ì„í•˜ì—¬ ì €ì¥
                    </button>
                </div>
            </div>
        </div>

        <!-- GPT ë¶„ì„ ê²°ê³¼ -->
        <div class="row mb-4" id="analysisResult" style="display: none;">
            <div class="col-12">
                <div class="result-section">
                    <h5 class="mb-3">ğŸ“‹ GPT ë¶„ì„ ê²°ê³¼</h5>
                    
                    <!-- í”„ë¡¬í”„íŠ¸ í‘œì‹œ -->
                    <div class="mb-3 p-3 bg-light rounded">
                        <h6 class="text-secondary mb-2">ğŸ“ ì‚¬ìš©ì í”„ë¡¬í”„íŠ¸:</h6>
                        <div id="displayedPrompt" class="text-muted small" style="white-space: pre-wrap;"></div>
                    </div>
                    
                    <!-- GPT ì‘ë‹µ í‘œì‹œ -->
                    <div class="mb-3">
                        <h6 class="text-secondary mb-2">ğŸ¤– GPT ì‘ë‹µ:</h6>
                        <div id="gptResponse" class="gpt-response"></div>
                    </div>
                    
                    <div class="row mt-3">
                        <div class="col-md-6">
                            <div class="attribute-display">
                                <h6 class="text-primary">ğŸ¯ ì†ì„± (GPTê°€ ì¶”ì¶œ)</h6>
                                <div id="extractedAttribute" class="fw-bold mb-2">-</div>
                                <div class="bit-display">
                                    <small><strong>ì†ì„± BIT MAX:</strong> <span id="extractedAttrMax">-</span></small>
                                </div>
                                <div class="bit-display">
                                    <small><strong>ì†ì„± BIT MIN:</strong> <span id="extractedAttrMin">-</span></small>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="data-display">
                                <h6 class="text-success">ğŸ“ ë°ì´í„° (GPTê°€ ì¶”ì¶œ)</h6>
                                <div id="extractedData" class="fw-bold mb-2">-</div>
                                <div class="bit-display">
                                    <small><strong>ë°ì´í„° BIT MAX:</strong> <span id="extractedDataMax">-</span></small>
                                </div>
                                <div class="bit-display">
                                    <small><strong>ë°ì´í„° BIT MIN:</strong> <span id="extractedDataMin">-</span></small>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="mt-3">
                        <button id="saveAnalyzedBtn" class="btn btn-success btn-lg">
                            âœ… ë¶„ì„ ê²°ê³¼ ì €ì¥
                        </button>
                        <span id="saveAnalyzedStatus" class="ms-2"></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ì…ë ¥ ì„¹ì…˜ (real_time.html ê¸°ëŠ¥) -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="input-section">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h4 class="mb-0">ğŸ“ ì‹¤ì‹œê°„ ì…ë ¥ (ìˆ˜ë™)</h4>
                        <div>
                            <span class="auto-status" id="autoStatus">â¸ï¸ ì¼ì‹œì •ì§€</span>
                            <button id="toggleAutoBtn" class="btn btn-primary btn-sm ms-2">ìë™í™” í™œì„±í™”</button>
                        </div>
                    </div>
                    
                    <!-- ì†ì„± ì…ë ¥ -->
                    <div class="mb-3">
                        <label class="form-label fw-bold">1ë‹¨ê³„: ì†ì„± (ë¬¸ì ì…ë ¥)</label>
                        <textarea 
                            id="attributeInput" 
                            class="form-control" 
                            placeholder="ì†ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                            rows="2"
                        ></textarea>
                        <div class="row mt-2">
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ì†ì„± BIT MAX:</strong> <span id="attributeMax">-</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ì†ì„± BIT MIN:</strong> <span id="attributeMin">-</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ë°ì´í„° ì…ë ¥ -->
                    <div class="mb-3 border-top pt-3">
                        <label class="form-label fw-bold">2ë‹¨ê³„: ë°ì´í„° (ë¬¸ì ì…ë ¥)</label>
                        <textarea 
                            id="realtimeInput" 
                            class="form-control" 
                            placeholder="ì´ ì†ì„±ì— ì €ì¥í•  ë°ì´í„°(í…ìŠ¤íŠ¸)ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                            rows="3"
                        ></textarea>
                        <div class="row mt-2">
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ë°ì´í„° BIT MAX:</strong> <span id="calculatedMax">-</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ë°ì´í„° BIT MIN:</strong> <span id="calculatedMin">-</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- ì‹¤ì‹œê°„ ì¡°íšŒ ì „ìš© ì…ë ¥ë€ -->
                    <div class="mb-3 border-top pt-3">
                        <label class="form-label fw-bold">ğŸ” ì‹¤ì‹œê°„ ì¡°íšŒ ì…ë ¥ (ìë™ ê²€ìƒ‰)</label>
                        <textarea 
                            id="searchInput" 
                            class="form-control" 
                            placeholder="í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ë©´ ìë™ìœ¼ë¡œ ê²€ìƒ‰ë©ë‹ˆë‹¤..."
                            rows="2"
                        ></textarea>
                        <div class="row mt-2">
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ì¡°íšŒ BIT MAX:</strong> <span id="searchBitMax">-</span>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="bit-display">
                                    <strong>ì¡°íšŒ BIT MIN:</strong> <span id="searchBitMin">-</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ê²€ìƒ‰ ì˜µì…˜ -->
                        <div class="mt-3 p-2 bg-light rounded">
                            <label class="form-label fw-bold small mb-2">ğŸ” ê²€ìƒ‰ ì˜µì…˜</label>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="searchOption" id="searchOptionAttribute" value="attribute" checked>
                                <label class="form-check-label" for="searchOptionAttribute">
                                    ì†ì„±ìœ¼ë¡œë§Œ ê²€ìƒ‰ (ê¸°ë³¸)
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="searchOption" id="searchOptionAll" value="all">
                                <label class="form-check-label" for="searchOptionAll">
                                    ì „ì²´ ê²€ìƒ‰ (ì†ì„± + ë°ì´í„° + ì¼ë°˜ ë¡œê·¸)
                                </label>
                            </div>
                            <div class="form-check">
                                <input class="form-check-input" type="radio" name="searchOption" id="searchOptionData" value="data">
                                <label class="form-check-label" for="searchOptionData">
                                    ë°ì´í„°ë¡œë§Œ ê²€ìƒ‰
                                </label>
                            </div>
                        </div>
                        
                        <small class="text-muted">ì´ ì…ë ¥ë€ì— ì…ë ¥í•˜ë©´ ìë™ìœ¼ë¡œ ê²€ìƒ‰ì´ ì‹¤í–‰ë©ë‹ˆë‹¤.</small>
                    </div>

                    <div class="mt-3">
                        <button id="saveBtn" class="btn btn-primary">ì†ì„±ì— ë°ì´í„° ì €ì¥</button>
                        <span id="saveStatus" class="ms-2 small"></span>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ì¶œë ¥ ì„¹ì…˜ -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">ğŸ“Š ì‹¤ì‹œê°„ ì¶œë ¥</h5>
                        <button id="clearOutputBtn" class="btn btn-sm btn-outline-secondary">ì¶œë ¥ ì§€ìš°ê¸°</button>
                    </div>
                    <div class="card-body" style="max-height: 300px; overflow-y: auto;">
                        <div id="realtimeOutput"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ì¡°íšŒ ê²°ê³¼ -->
        <div class="row">
            <div class="col-12">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <strong>ğŸ” ì‹¤ì‹œê°„ ì¡°íšŒ ê²°ê³¼</strong>
                        <span id="resultCount" class="badge bg-secondary">0ê°œ</span>
                    </div>
                    <div class="card-body">
                        <div id="searchStatus" class="small text-muted mb-2"></div>
                        <div class="table-responsive" style="max-height: 500px; overflow-y: auto;">
                            <table class="table table-sm table-hover">
                                <thead class="table-light sticky-top">
                                    <tr>
                                        <th style="width: 5%;">#</th>
                                        <th style="width: 15%;">ì‹œê°„</th>
                                        <th style="width: 12%;">BIT_MAX</th>
                                        <th style="width: 12%;">BIT_MIN</th>
                                        <th style="width: 20%;">ì†ì„±</th>
                                        <th style="width: 26%;">ë°ì´í„°</th>
                                        <th style="width: 10%;">ìœ ì‚¬ë„</th>
                                    </tr>
                                </thead>
                                <tbody id="resultBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
    (function(){
      // GPT ë¶„ì„ ê´€ë ¨
      const $gptPrompt = document.getElementById('gptPrompt');
      const $gptInput = document.getElementById('gptInput');
      const $analyzeBtn = document.getElementById('analyzeBtn');
      const $gptStatus = document.getElementById('gptStatus');
      const $analysisResult = document.getElementById('analysisResult');
      const $gptResponse = document.getElementById('gptResponse');
      const $extractedAttribute = document.getElementById('extractedAttribute');
      const $extractedData = document.getElementById('extractedData');
      const $extractedAttrMax = document.getElementById('extractedAttrMax');
      const $extractedAttrMin = document.getElementById('extractedAttrMin');
      const $extractedDataMax = document.getElementById('extractedDataMax');
      const $extractedDataMin = document.getElementById('extractedDataMin');
      const $saveAnalyzedBtn = document.getElementById('saveAnalyzedBtn');
      const $saveAnalyzedStatus = document.getElementById('saveAnalyzedStatus');

      // ì‹¤ì‹œê°„ ì…ë ¥ ê´€ë ¨ (real_time.html ê¸°ëŠ¥)
      const $attributeInput = document.getElementById('attributeInput');
      const $attributeMax = document.getElementById('attributeMax');
      const $attributeMin = document.getElementById('attributeMin');
      const $input = document.getElementById('realtimeInput');
      const $calculatedMax = document.getElementById('calculatedMax');
      const $calculatedMin = document.getElementById('calculatedMin');
      const $autoStatus = document.getElementById('autoStatus');
      const $toggleAutoBtn = document.getElementById('toggleAutoBtn');
      const $realtimeOutput = document.getElementById('realtimeOutput');
      const $clearOutputBtn = document.getElementById('clearOutputBtn');
      const $resultBody = document.getElementById('resultBody');
      const $resultCount = document.getElementById('resultCount');
      const $searchStatus = document.getElementById('searchStatus');
      const $saveBtn = document.getElementById('saveBtn');
      const $saveStatus = document.getElementById('saveStatus');

      // ì‹¤ì‹œê°„ ì¡°íšŒ ì „ìš© ì…ë ¥ë€
      const $searchInput = document.getElementById('searchInput');
      const $searchBitMax = document.getElementById('searchBitMax');
      const $searchBitMin = document.getElementById('searchBitMin');
      const $searchOptionAttribute = document.getElementById('searchOptionAttribute');
      const $searchOptionAll = document.getElementById('searchOptionAll');
      const $searchOptionData = document.getElementById('searchOptionData');

      // GPT ë¶„ì„ ê²°ê³¼ í‘œì‹œìš© ìš”ì†Œ
      const $displayedPrompt = document.getElementById('displayedPrompt');

      let isAutoEnabled = false;
      let inputDebounceTimer = null;
      let searchTimer = null;
      let searchInputTimer = null;
      let lastInput = '';
      let lastSearchInput = '';
      let analyzedAttribute = '';
      let analyzedData = '';
      let analyzedAttrBits = null;
      let analyzedDataBits = null;
      let lastUsedPrompt = '';
      let lastAnalyzedText = '';

      function getServerUrl(path) {
        if (window.location.protocol === 'file:') {
          return `http://localhost:8123${path}`;
        }
        return path;
      }

      async function testServerConnection() {
        try {
          const res = await fetch(getServerUrl('/health'));
          return res.ok;
        } catch {
          return false;
        }
      }

      function calculateBitValues(text) {
        if (!text || typeof text !== 'string' || text.trim() === '') {
          return { max: null, min: null };
        }
        try {
          if (typeof wordNbUnicodeFormat === 'undefined' || typeof BIT_MAX_NB === 'undefined' || typeof BIT_MIN_NB === 'undefined') {
            console.warn('BIT ê³„ì‚° í•¨ìˆ˜ê°€ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
            return { max: null, min: null };
          }
          const unicodeArray = wordNbUnicodeFormat(text);
          const max = BIT_MAX_NB(unicodeArray);
          const min = BIT_MIN_NB(unicodeArray);
          return { max: isFinite(max) ? max : null, min: isFinite(min) ? min : null };
        } catch (e) {
          console.error('BIT ê³„ì‚° ì˜¤ë¥˜:', e);
          return { max: null, min: null };
        }
      }

      function addOutput(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString('ko-KR');
        const div = document.createElement('div');
        div.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} alert-dismissible fade show`;
        div.style.fontSize = '0.9em';
        div.innerHTML = `
          <small class="text-muted">[${timestamp}]</small> ${message}
          <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        $realtimeOutput.insertBefore(div, $realtimeOutput.firstChild);
      }

      // GPT ë¶„ì„ í•¨ìˆ˜
      async function analyzeWithGPT(text) {
        if (!text || text.trim() === '') {
          alert('ë¶„ì„í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
          return;
        }

        try {
          $analyzeBtn.disabled = true;
          $gptStatus.textContent = 'GPT AI ë¶„ì„ ì¤‘...';
          $gptStatus.className = 'auto-status status-active';
          $gptResponse.textContent = 'ë¶„ì„ ì¤‘...';

          const customPrompt = $gptPrompt.value.trim();
          
          const systemMessage = `ë‹¹ì‹ ì€ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†ì„±(attribute)ê³¼ ë°ì´í„°(data)ë¡œ ë¶„ë¦¬í•˜ëŠ” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ì…ë ¥ëœ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬:
1. **ì†ì„± (attribute)**: ì „ì²´ì ì¸ ì£¼ì œ, ì¹´í…Œê³ ë¦¬, ë˜ëŠ” ê°œë…ì„ ë‚˜íƒ€ë‚´ëŠ” í‚¤ì›Œë“œ
2. **ë°ì´í„° (data)**: ì†ì„± ì•„ë˜ì— ì†í•˜ëŠ” êµ¬ì²´ì ì¸ ë‚´ìš©, ì„¸ë¶€ì‚¬í•­, ë˜ëŠ” ì˜ˆì‹œ

ì˜ˆì‹œ:
- ì…ë ¥: "ë°˜ì§€ì˜ ì œì™• ì†Œì„¤ì˜ ì›ì •ëŒ€ ì´ì•¼ê¸°"
  - ì†ì„±: "ë°˜ì§€ì˜ ì œì™•"
  - ë°ì´í„°: "ì›ì •ëŒ€"

- ì…ë ¥: "íŒíƒ€ì§€ ê²Œì„ì˜ ë§ˆë²• ì‹œìŠ¤í…œ"
  - ì†ì„±: "íŒíƒ€ì§€ ê²Œì„"
  - ë°ì´í„°: "ë§ˆë²• ì‹œìŠ¤í…œ"

${customPrompt ? `\n[ì¶”ê°€ ì§€ì‹œì‚¬í•­]\n${customPrompt}\n` : ''}

ì‘ë‹µ í˜•ì‹ (JSONë§Œ ë°˜í™˜):
{
  "attribute": "ì†ì„± í…ìŠ¤íŠ¸",
  "data": "ë°ì´í„° í…ìŠ¤íŠ¸",
  "reasoning": "ë¶„ë¦¬ ì´ìœ  ì„¤ëª…"
}`;

          const url = getServerUrl('/api/gpt/chat');
          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              prompt: `ë‹¤ìŒ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì†ì„±ê³¼ ë°ì´í„°ë¡œ ë¶„ë¦¬í•´ì£¼ì„¸ìš”:\n\n"${text}"${customPrompt ? `\n\n${customPrompt}` : ''}`,
              systemMessage: systemMessage,
              model: 'gpt-4o-mini',
              temperature: 0.3,
              maxTokens: 500
            })
          });

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }

          const data = await res.json();
          if (!data.ok) {
            throw new Error(data.error || 'GPT ë¶„ì„ ì‹¤íŒ¨');
          }

          // JSON ì‘ë‹µ íŒŒì‹±
          let parsed = null;
          try {
            parsed = JSON.parse(data.response);
          } catch {
            // JSONì´ ì•„ë‹Œ ê²½ìš° ì‘ë‹µ í…ìŠ¤íŠ¸ì—ì„œ ì¶”ì¶œ ì‹œë„
            const jsonMatch = data.response.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              parsed = JSON.parse(jsonMatch[0]);
            } else {
              throw new Error('GPT ì‘ë‹µì—ì„œ JSONì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
          }

          if (!parsed.attribute || !parsed.data) {
            throw new Error('GPT ì‘ë‹µì— ì†ì„± ë˜ëŠ” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
          }

          // ë¶„ì„ ê²°ê³¼ í‘œì‹œ
          analyzedAttribute = parsed.attribute.trim();
          analyzedData = parsed.data.trim();
          analyzedAttrBits = calculateBitValues(analyzedAttribute);
          analyzedDataBits = calculateBitValues(analyzedData);

          // í”„ë¡¬í”„íŠ¸ ë° ì…ë ¥ í…ìŠ¤íŠ¸ ì €ì¥
          lastUsedPrompt = customPrompt || '(ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©)';
          lastAnalyzedText = text;

          // í”„ë¡¬í”„íŠ¸ë§Œ í‘œì‹œ (í…ìŠ¤íŠ¸ ì…ë ¥ì€ ìƒëµ)
          const promptDisplay = customPrompt 
            ? customPrompt
            : '(ê¸°ë³¸ í”„ë¡¬í”„íŠ¸ ì‚¬ìš©)';
          $displayedPrompt.textContent = promptDisplay;

          // GPT ì‘ë‹µ í‘œì‹œ
          $gptResponse.textContent = data.response;
          $extractedAttribute.textContent = analyzedAttribute;
          $extractedData.textContent = analyzedData;
          $extractedAttrMax.textContent = analyzedAttrBits.max !== null ? analyzedAttrBits.max.toFixed(10) : '-';
          $extractedAttrMin.textContent = analyzedAttrBits.min !== null ? analyzedAttrBits.min.toFixed(10) : '-';
          $extractedDataMax.textContent = analyzedDataBits.max !== null ? analyzedDataBits.max.toFixed(10) : '-';
          $extractedDataMin.textContent = analyzedDataBits.min !== null ? analyzedDataBits.min.toFixed(10) : '-';

          // ìë™ìœ¼ë¡œ ì‹¤ì‹œê°„ ì…ë ¥ë€ì— ë³µì‚¬
          $attributeInput.value = analyzedAttribute;
          $input.value = analyzedData;
          updateAttributeBitDisplay(analyzedAttribute);
          updateDataBitDisplay(analyzedData);
          addOutput(`âœ“ GPT ë¶„ì„ ê²°ê³¼ê°€ ì‹¤ì‹œê°„ ì…ë ¥ë€ì— ìë™ ì…ë ¥ë˜ì—ˆìŠµë‹ˆë‹¤.`, 'success');

          $analysisResult.style.display = 'block';
          $gptStatus.textContent = 'âœ“ ë¶„ì„ ì™„ë£Œ';
          $gptStatus.className = 'auto-status status-active';
          addOutput(`GPT ë¶„ì„ ì™„ë£Œ: ì†ì„±="${analyzedAttribute}", ë°ì´í„°="${analyzedData}"`, 'success');

        } catch (e) {
          console.error('GPT ë¶„ì„ ì˜¤ë¥˜:', e);
          $gptStatus.textContent = 'âœ— ë¶„ì„ ì‹¤íŒ¨';
          $gptStatus.className = 'auto-status';
          $gptResponse.textContent = `ì˜¤ë¥˜: ${e.message}`;
          addOutput(`GPT ë¶„ì„ ì˜¤ë¥˜: ${e.message}`, 'error');
        } finally {
          $analyzeBtn.disabled = false;
        }
      }

      // ë¶„ì„ ê²°ê³¼ ì €ì¥
      async function saveAnalyzedData() {
        if (!analyzedAttribute || !analyzedData || !analyzedAttrBits.max || !analyzedAttrBits.min || !analyzedDataBits.max || !analyzedDataBits.min) {
          $saveAnalyzedStatus.textContent = 'ë¶„ì„ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € GPT ë¶„ì„ì„ ì‹¤í–‰í•˜ì„¸ìš”.';
          $saveAnalyzedStatus.style.color = '#dc3545';
          return;
        }

        try {
          $saveAnalyzedBtn.disabled = true;
          $saveAnalyzedStatus.textContent = 'ì €ì¥ ì¤‘...';
          $saveAnalyzedStatus.style.color = '#007bff';

          const url = getServerUrl('/api/attributes/data');
          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              attributeBitMax: analyzedAttrBits.max,
              attributeBitMin: analyzedAttrBits.min,
              attributeText: analyzedAttribute,
              text: analyzedData,
              dataBitMax: analyzedDataBits.max,
              dataBitMin: analyzedDataBits.min
            })
          });

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }

          const data = await res.json();
          if (data.ok) {
            if (data.duplicate) {
              $saveAnalyzedStatus.textContent = `âš  ${data.message || 'ì´ë¯¸ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.'}`;
              $saveAnalyzedStatus.style.color = '#ffc107';
              addOutput(`âš  GPT ë¶„ì„ ê²°ê³¼ ì €ì¥ ì‹œë„ (ì¤‘ë³µ): ì†ì„±="${analyzedAttribute}", ë°ì´í„°="${analyzedData}"`, 'warning');
            } else {
              $saveAnalyzedStatus.textContent = 'âœ“ ì €ì¥ ì™„ë£Œ!';
              $saveAnalyzedStatus.style.color = '#28a745';
              addOutput(`âœ“ GPT ë¶„ì„ ê²°ê³¼ ì €ì¥ ì™„ë£Œ: ì†ì„±="${analyzedAttribute}", ë°ì´í„°="${analyzedData}"`, 'success');
              
              // ì €ì¥ í›„ ìë™ ê²€ìƒ‰
              setTimeout(() => {
                autoSearch(analyzedDataBits.max, analyzedDataBits.min);
              }, 500);
            }
          } else {
            throw new Error(data.error || 'ì €ì¥ ì‹¤íŒ¨');
          }
        } catch (e) {
          console.error('ì €ì¥ ì˜¤ë¥˜:', e);
          $saveAnalyzedStatus.textContent = `âœ— ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
          $saveAnalyzedStatus.style.color = '#dc3545';
          addOutput(`ì €ì¥ ì˜¤ë¥˜: ${e.message}`, 'error');
        } finally {
          $saveAnalyzedBtn.disabled = false;
        }
      }

      // real_time.htmlì˜ ê¸°ëŠ¥ë“¤ (ìë™ ì €ì¥, ê²€ìƒ‰ ë“±)
      function updateBitDisplay(text, $maxEl, $minEl) {
        const { max, min } = calculateBitValues(text);
        if ($maxEl) $maxEl.textContent = max !== null ? max.toFixed(10) : '-';
        if ($minEl) $minEl.textContent = min !== null ? min.toFixed(10) : '-';
        return { max, min };
      }

      function updateAttributeBitDisplay(text) {
        return updateBitDisplay(text, $attributeMax, $attributeMin);
      }

      function updateDataBitDisplay(text) {
        return updateBitDisplay(text, $calculatedMax, $calculatedMin);
      }

      async function autoSaveAttributeData(attributeText, dataText) {
        if (!attributeText || !dataText) return;

        const attrBits = calculateBitValues(attributeText);
        const dataBits = calculateBitValues(dataText);

        if (!attrBits.max || !attrBits.min || !dataBits.max || !dataBits.min) {
          return;
        }

        try {
          const url = getServerUrl('/api/attributes/data');
          const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              attributeBitMax: attrBits.max,
              attributeBitMin: attrBits.min,
              attributeText: attributeText,
              text: dataText,
              dataBitMax: dataBits.max,
              dataBitMin: dataBits.min
            })
          });

          if (!res.ok) {
            throw new Error(`HTTP ${res.status}`);
          }

          const data = await res.json();
          if (data.ok) {
            if (data.duplicate) {
              $saveStatus.textContent = `âš  ìë™ ì €ì¥: ${data.message || 'ì´ë¯¸ ì €ì¥ë˜ì–´ ìˆìŠµë‹ˆë‹¤.'}`;
              $saveStatus.style.color = '#ffc107';
              addOutput(`âš  ì†ì„± "${attributeText}"ì— ë°ì´í„° "${dataText}" ìë™ ì €ì¥ ì‹œë„ (ì¤‘ë³µ)`, 'warning');
            } else {
              $saveStatus.textContent = 'âœ“ ìë™ ì €ì¥ ì™„ë£Œ!';
              $saveStatus.style.color = '#28a745';
              addOutput(`âœ“ ì†ì„± "${attributeText}"ì— ë°ì´í„° "${dataText}" ìë™ ì €ì¥ ì™„ë£Œ`, 'success');
            }
          }
        } catch (e) {
          console.error('ìë™ ì €ì¥ ì˜¤ë¥˜:', e);
          $saveStatus.textContent = `âœ— ìë™ ì €ì¥ ì‹¤íŒ¨: ${e.message}`;
          $saveStatus.style.color = '#dc3545';
          addOutput(`ìë™ ì €ì¥ ì˜¤ë¥˜: ${e.message}`, 'error');
        }
      }

      // ìœ ì‚¬ë„ ê³„ì‚° í—¬í¼ í•¨ìˆ˜
      function calculateSimilarity(queryBitMax, queryBitMin, resultBitMax, resultBitMin) {
        if (resultBitMax === null || resultBitMax === undefined || 
            resultBitMin === null || resultBitMin === undefined) {
          return 0;
        }
        const bitMaxDiff = Math.abs((queryBitMax || 0) - (resultBitMax || 0));
        const bitMinDiff = Math.abs((queryBitMin || 0) - (resultBitMin || 0));
        const distance = Math.sqrt(bitMaxDiff * bitMaxDiff + bitMinDiff * bitMinDiff);
        // ê±°ë¦¬ê°€ 0ì´ë©´ 1.0, ê±°ë¦¬ê°€ ë©€ìˆ˜ë¡ 0ì— ê°€ê¹Œì›Œì§
        return Math.max(0, 1 / (1 + distance));
      }

      async function autoSearch(bitMax, bitMin, searchText = null) {
        if (!bitMax || !bitMin) return;

        try {
          $searchStatus.textContent = 'ê²€ìƒ‰ ì¤‘...';
          $searchStatus.style.color = '#007bff';

          // ê²€ìƒ‰ ì˜µì…˜ ê°€ì ¸ì˜¤ê¸°
          let searchOption = 'attribute'; // ê¸°ë³¸ê°’: ì†ì„±ìœ¼ë¡œë§Œ ê²€ìƒ‰
          if ($searchOptionAll && $searchOptionAll.checked) {
            searchOption = 'all';
          } else if ($searchOptionData && $searchOptionData.checked) {
            searchOption = 'data';
          } else if ($searchOptionAttribute && $searchOptionAttribute.checked) {
            searchOption = 'attribute';
          }

          let results = [];
          // ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ì œê³µë˜ë©´ í•´ë‹¹ í…ìŠ¤íŠ¸ë¥¼ ì†ì„± í›„ë³´ë¡œë„ ê³ ë ¤
          let attributeText = $attributeInput.value.trim();
          // ì‹¤ì‹œê°„ ì¡°íšŒ ì…ë ¥ë€ì—ì„œ ê²€ìƒ‰í•œ ê²½ìš°, ê²€ìƒ‰ í…ìŠ¤íŠ¸ë¥¼ ì†ì„± í›„ë³´ë¡œ ì‚¬ìš©
          if (!attributeText && searchText) {
            attributeText = searchText.trim();
          }
          const dataText = $input.value.trim();

          // 1. ì†ì„± ê²€ìƒ‰ (ì†ì„± ê²€ìƒ‰ ë˜ëŠ” ì „ì²´ ê²€ìƒ‰ì¼ ë•Œ)
          if (searchOption === 'attribute' || searchOption === 'all') {
            try {
              
              // ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ê·¸ê²ƒì„ ìš°ì„  ì‚¬ìš© (ì‹¤ì‹œê°„ ì¡°íšŒ ì…ë ¥ë€ì—ì„œ ê²€ìƒ‰í•œ ê²½ìš°)
              const searchAttributeText = searchText ? searchText.trim() : attributeText;
              
              if (searchAttributeText) {
                const attrBits = calculateBitValues(searchAttributeText);
                if (attrBits.max && attrBits.min) {
                  // ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ (thresholdë¡œ ìœ ì‚¬í•œ ì†ì„±ë“¤ì„ ì°¾ìŒ)
                  const url = getServerUrl(`/api/attributes/data?bitMax=${attrBits.max}&bitMin=${attrBits.min}&limit=20&similarity=true&threshold=0.1`);
                  const res = await fetch(url);

                  if (res.ok) {
                    const data = await res.json();
                    if (data.ok && data.items) {
                      results.push(...data.items.map(item => {
                        // ì†ì„± ê²€ìƒ‰ì¸ ê²½ìš°: ê²€ìƒ‰ ì¿¼ë¦¬ì˜ ì†ì„± BITì™€ ê²°ê³¼ì˜ ì†ì„± BITë¥¼ ë¹„êµ
                        const resultAttrBitMax = item.attribute?.bitMax || null;
                        const resultAttrBitMin = item.attribute?.bitMin || null;
                        const resultAttrText = item.attribute?.text || '';
                        
                        // ì†ì„± BITë¡œ ìœ ì‚¬ë„ ê³„ì‚° (ì†ì„± ê²€ìƒ‰ì´ë¯€ë¡œ ì†ì„± BITë¥¼ ìš°ì„  ë¹„êµ)
                        let similarity = 0;
                        if (resultAttrBitMax !== null && resultAttrBitMin !== null) {
                          // ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ì†ì„± (í…ìŠ¤íŠ¸ ë˜ëŠ” BIT ê°’)ì€ 100%
                          if (resultAttrText === searchAttributeText) {
                            similarity = 1.0;
                          } else {
                            // BIT ê°’ì´ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ë„ 100%
                            const bitMaxDiff = Math.abs((attrBits.max || 0) - (resultAttrBitMax || 0));
                            const bitMinDiff = Math.abs((attrBits.min || 0) - (resultAttrBitMin || 0));
                            if (bitMaxDiff === 0 && bitMinDiff === 0) {
                              similarity = 1.0;
                            } else {
                              // ì†ì„± BIT ê°’ìœ¼ë¡œ ìœ ì‚¬ë„ ê³„ì‚°
                              similarity = calculateSimilarity(attrBits.max, attrBits.min, resultAttrBitMax, resultAttrBitMin);
                            }
                          }
                        } else if (item.similarity) {
                          // ì„œë²„ì—ì„œ ë°˜í™˜ëœ ìœ ì‚¬ë„ ì‚¬ìš©
                          similarity = item.similarity;
                          // í…ìŠ¤íŠ¸ê°€ ì •í™•íˆ ì¼ì¹˜í•˜ë©´ 100%ë¡œ ì˜¤ë²„ë¼ì´ë“œ
                          if (resultAttrText === searchAttributeText) {
                            similarity = 1.0;
                          }
                        }
                        
                        return {
                          ...item,
                          source: 'attribute_data',
                          input: item.attribute?.text || searchAttributeText,
                          response: item.data?.text || item.s || '',
                          similarity: similarity
                        };
                      }));
                    }
                  }
                }
              }
              
              // ì†ì„±ìœ¼ë¡œë§Œ ê²€ìƒ‰í•˜ëŠ” ê²½ìš°, ê²€ìƒ‰ í…ìŠ¤íŠ¸ BITë¡œ ëª¨ë“  ì†ì„±ê³¼ ìœ ì‚¬ë„ ë¹„êµ
              if (searchOption === 'attribute' && searchText && bitMax && bitMin) {
                try {
                  // ëª¨ë“  ì†ì„± ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                  const allAttrUrl = getServerUrl('/api/attributes/all');
                  const allAttrRes = await fetch(allAttrUrl);
                  
                  if (allAttrRes.ok) {
                    const allAttrData = await allAttrRes.json();
                    if (allAttrData.ok && allAttrData.attributes && allAttrData.attributes.length > 0) {
                      // ê²€ìƒ‰ í…ìŠ¤íŠ¸ BITì™€ ê° ì†ì„± BIT ê°„ì˜ ìœ ì‚¬ë„ ê³„ì‚°
                      const similarAttributes = allAttrData.attributes
                        .map(attr => {
                          let similarity = 0;
                          // ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ì†ì„± (í…ìŠ¤íŠ¸ ë˜ëŠ” BIT ê°’)ì€ 100%
                          if (attr.text === searchText.trim()) {
                            similarity = 1.0;
                          } else {
                            // BIT ê°’ì´ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” ê²½ìš°ë„ 100%
                            const bitMaxDiff = Math.abs((bitMax || 0) - (attr.bitMax || 0));
                            const bitMinDiff = Math.abs((bitMin || 0) - (attr.bitMin || 0));
                            if (bitMaxDiff === 0 && bitMinDiff === 0) {
                              similarity = 1.0;
                            } else {
                              // ìœ ì‚¬ë„ ê³„ì‚°
                              similarity = calculateSimilarity(bitMax, bitMin, attr.bitMax, attr.bitMin);
                            }
                          }
                          return { ...attr, similarity };
                        })
                        .filter(attr => attr.similarity > 0.1) // ìœ ì‚¬ë„ ì„ê³„ê°’ 0.1
                        .sort((a, b) => b.similarity - a.similarity)
                        .slice(0, 10); // ìƒìœ„ 10ê°œ ì†ì„±ë§Œ
                      
                      // ìœ ì‚¬í•œ ì†ì„±ë“¤ì˜ ë°ì´í„° ì¡°íšŒ
                      for (const similarAttr of similarAttributes) {
                        try {
                          const dataUrl = getServerUrl(`/api/attributes/data?bitMax=${similarAttr.bitMax}&bitMin=${similarAttr.bitMin}&limit=5`);
                          const dataRes = await fetch(dataUrl);
                          
                          if (dataRes.ok) {
                            const dataData = await dataRes.json();
                            if (dataData.ok && dataData.items) {
                              results.push(...dataData.items.map(item => ({
                                ...item,
                                source: 'attribute_similar',
                                input: item.attribute?.text || similarAttr.text,
                                response: item.data?.text || item.s || '',
                                similarity: similarAttr.similarity * 0.9 // ì†ì„± ìœ ì‚¬ë„ì— ì•½ê°„ì˜ í˜ë„í‹° ì ìš©
                              })));
                            }
                          }
                        } catch (e) {
                          console.warn(`ì†ì„± "${similarAttr.text}" ë°ì´í„° ì¡°íšŒ ì˜¤ë¥˜:`, e);
                        }
                      }
                    }
                  }
                } catch (e) {
                  console.warn('ì†ì„± ìœ ì‚¬ë„ ê²€ìƒ‰ ì˜¤ë¥˜:', e);
                }
              }
            } catch (e) {
              console.warn('ì†ì„± ë°ì´í„° ê²€ìƒ‰ ì˜¤ë¥˜:', e);
            }
          }

          // 2. ë°ì´í„° BIT ê°’ìœ¼ë¡œë„ ê²€ìƒ‰ (ì†ì„±-ë°ì´í„° ì—°ê²°ëœ í•­ëª©) - ì „ì²´ ê²€ìƒ‰ ë˜ëŠ” ë°ì´í„° ê²€ìƒ‰ì¼ ë•Œ
          if (searchOption === 'all' || searchOption === 'data') {
            try {
              const maxUrl = getServerUrl(`/api/log/by-max?nb_max=${bitMax}&n=20`);
              const minUrl = getServerUrl(`/api/log/by-min?nb_min=${bitMin}&n=20`);
              
              const [maxRes, minRes] = await Promise.all([fetch(maxUrl), fetch(minUrl)]);
              
              if (maxRes.ok) {
                const maxData = await maxRes.json();
                if (maxData.ok && maxData.items) {
                  const attrItems = maxData.items.filter(item => item.attribute).map(item => {
                    // ê²€ìƒ‰ ì¿¼ë¦¬ BITì™€ ê²°ê³¼ BIT ê°„ì˜ ìœ ì‚¬ë„ ê³„ì‚°
                    const resultBitMax = item.data?.bitMax || item.max || item.nb_max || null;
                    const resultBitMin = item.data?.bitMin || item.min || item.nb_min || null;
                    const similarity = calculateSimilarity(bitMax, bitMin, resultBitMax, resultBitMin);
                    
                    return {
                      ...item,
                      source: 'attribute_data_by_data',
                      input: item.attribute?.text || '',
                      response: item.data?.text || item.s || '',
                      similarity: similarity
                    };
                  });
                  results.push(...attrItems);
                }
              }
              
              if (minRes.ok) {
                const minData = await minRes.json();
                if (minData.ok && minData.items) {
                  const attrItems = minData.items.filter(item => item.attribute).map(item => {
                    // ê²€ìƒ‰ ì¿¼ë¦¬ BITì™€ ê²°ê³¼ BIT ê°„ì˜ ìœ ì‚¬ë„ ê³„ì‚°
                    const resultBitMax = item.data?.bitMax || item.max || item.nb_max || null;
                    const resultBitMin = item.data?.bitMin || item.min || item.nb_min || null;
                    const similarity = calculateSimilarity(bitMax, bitMin, resultBitMax, resultBitMin);
                    
                    return {
                      ...item,
                      source: 'attribute_data_by_data',
                      input: item.attribute?.text || '',
                      response: item.data?.text || item.s || '',
                      similarity: similarity
                    };
                  });
                  results.push(...attrItems);
                }
              }
            } catch (e) {
              console.warn('ë°ì´í„° BIT ê²€ìƒ‰ ì˜¤ë¥˜:', e);
            }
          }

          // 3. ì¼ë°˜ ë¡œê·¸ ë°ì´í„° ê²€ìƒ‰ (ì†ì„±ì´ ì—†ëŠ” ì¼ë°˜ ë°ì´í„°) - ì „ì²´ ê²€ìƒ‰ì¼ ë•Œë§Œ
          if (searchOption === 'all') {
            try {
              const maxUrl = getServerUrl(`/api/log/by-max?nb_max=${bitMax}&n=10`);
              const minUrl = getServerUrl(`/api/log/by-min?nb_min=${bitMin}&n=10`);
              
              const [maxRes, minRes] = await Promise.all([fetch(maxUrl), fetch(minUrl)]);
              
              const generalItems = [];
              
              if (maxRes.ok) {
                const maxData = await maxRes.json();
                if (maxData.ok && maxData.items) {
                  maxData.items.filter(item => !item.attribute).forEach(item => {
                    const resultBitMax = item.nb_max || item.max || null;
                    const resultBitMin = item.nb_min || item.min || null;
                    const similarity = calculateSimilarity(bitMax, bitMin, resultBitMax, resultBitMin);
                    
                    generalItems.push({
                      ...item,
                      source: 'log',
                      input: item.input_text || item.s || '',
                      response: item.output || item.s || '',
                      similarity: similarity
                    });
                  });
                }
              }
              
              if (minRes.ok) {
                const minData = await minRes.json();
                if (minData.ok && minData.items) {
                  minData.items.filter(item => !item.attribute).forEach(item => {
                    const resultBitMax = item.nb_max || item.max || null;
                    const resultBitMin = item.nb_min || item.min || null;
                    const similarity = calculateSimilarity(bitMax, bitMin, resultBitMax, resultBitMin);
                    
                    generalItems.push({
                      ...item,
                      source: 'log',
                      input: item.input_text || item.s || '',
                      response: item.output || item.s || '',
                      similarity: similarity
                    });
                  });
                }
              }
              
              results.push(...generalItems);
            } catch (e) {
              console.warn('ì¼ë°˜ ë¡œê·¸ ê²€ìƒ‰ ì˜¤ë¥˜:', e);
            }
          }

          // 4. ìœ ì‚¬ë„ ê²€ìƒ‰ (training ë°ì´í„°) - ì „ì²´ ê²€ìƒ‰ì¼ ë•Œë§Œ
          if (searchOption === 'all') {
            try {
              const url = getServerUrl('/api/training/similar');
              const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  query: '',
                  queryBitMax: bitMax,
                  queryBitMin: bitMin,
                  limit: 10
                })
              });

              if (res.ok) {
                const data = await res.json();
                if (data.ok && data.items) {
                  results.push(...data.items.map(item => ({
                    ...item,
                    source: 'training',
                    similarity: item.similarity_score || calculateSimilarity(bitMax, bitMin, item.bit?.max, item.bit?.min)
                  })));
                }
              }
            } catch (e) {
              console.warn('ìœ ì‚¬ë„ ê²€ìƒ‰ ì˜¤ë¥˜:', e);
            }
          }

          // ì¤‘ë³µ ì œê±° ë° ì •ë ¬
          const seen = new Set();
          const uniqueResults = [];
          results.forEach(item => {
            const key = `${item.t || ''}_${item.input || item.attribute?.text || ''}_${item.response || item.data?.text || item.s || ''}`;
            if (!seen.has(key)) {
              seen.add(key);
              uniqueResults.push(item);
            }
          });

          // ìœ ì‚¬ë„ê°€ ê³„ì‚°ë˜ì§€ ì•Šì€ í•­ëª©ì— ëŒ€í•´ ê³„ì‚° ì‹œë„
          uniqueResults.forEach(item => {
            if (item.similarity === undefined || item.similarity === null) {
              const resultBitMax = item.data?.bitMax || item.max || item.nb_max || item.bit?.max || null;
              const resultBitMin = item.data?.bitMin || item.min || item.nb_min || item.bit?.min || null;
              item.similarity = calculateSimilarity(bitMax, bitMin, resultBitMax, resultBitMin);
            }
          });
          
          // ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” í•­ëª©(ìœ ì‚¬ë„ 1.0)ì„ ë¨¼ì €, ê·¸ ë‹¤ìŒ ìœ ì‚¬ë„ìˆœìœ¼ë¡œ ì •ë ¬
          uniqueResults.sort((a, b) => {
            const aIsExact = (a.similarity || 0) === 1.0;
            const bIsExact = (b.similarity || 0) === 1.0;
            if (aIsExact && !bIsExact) return -1;
            if (!aIsExact && bIsExact) return 1;
            // ë‘˜ ë‹¤ ì •í™•íˆ ì¼ì¹˜í•˜ê±°ë‚˜ ë‘˜ ë‹¤ ì•„ë‹Œ ê²½ìš° ìœ ì‚¬ë„ìˆœ ì •ë ¬
            return (b.similarity || 0) - (a.similarity || 0);
          });
          const finalResults = uniqueResults.slice(0, 20);

          renderResults(finalResults);
          $resultCount.textContent = `${finalResults.length}ê°œ`;
          $searchStatus.textContent = `âœ“ ê²€ìƒ‰ ì™„ë£Œ (${finalResults.length}ê°œ ê²°ê³¼)`;
          $searchStatus.style.color = '#28a745';

        } catch (e) {
          console.error('ê²€ìƒ‰ ì˜¤ë¥˜:', e);
          $searchStatus.textContent = `âœ— ê²€ìƒ‰ ì‹¤íŒ¨: ${e.message}`;
          $searchStatus.style.color = '#dc3545';
        }
      }

      function renderResults(results) {
        $resultBody.innerHTML = '';
        
        if (results.length === 0) {
          $resultBody.innerHTML = '<tr><td colspan="7" class="text-center text-muted">ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</td></tr>';
          return;
        }

        results.forEach((item, idx) => {
          const tr = document.createElement('tr');
          
          const time = item.t ? new Date(item.t).toLocaleString('ko-KR') : (item.timestamp || '');
          
          const bitMax = (item.attribute && item.attribute.bitMax != null) ? String(item.attribute.bitMax) : 
                        (item.bit && item.bit.max != null) ? String(item.bit.max) : 
                        (item.nb_max != null ? String(item.nb_max) : '');
          const bitMin = (item.attribute && item.attribute.bitMin != null) ? String(item.attribute.bitMin) : 
                        (item.bit && item.bit.min != null) ? String(item.bit.min) : 
                        (item.nb_min != null ? String(item.nb_min) : '');
          
          const input = item.input || item.attribute?.text || item.input_text || '';
          const response = item.response || item.data?.text || item.s || item.output || '';
          const similarity = item.similarity != null ? (item.similarity * 100).toFixed(1) + '%' : '100%';
          
          const similarityClass = item.similarity >= 0.9 ? 'bg-success' : item.similarity >= 0.7 ? 'bg-warning' : 'bg-danger';
          
          tr.innerHTML = `
            <td>${idx + 1}</td>
            <td><small>${time}</small></td>
            <td><code>${bitMax.substring(0, 10)}${bitMax.length > 10 ? '...' : ''}</code></td>
            <td><code>${bitMin.substring(0, 10)}${bitMin.length > 10 ? '...' : ''}</code></td>
            <td>${input.substring(0, 30)}${input.length > 30 ? '...' : ''}</td>
            <td>${response.substring(0, 40)}${response.length > 40 ? '...' : ''}</td>
            <td><span class="badge ${similarityClass}">${similarity}</span></td>
          `;
          
          $resultBody.appendChild(tr);
        });
      }

      async function processInput(text) {
        if (!text || text.trim() === '') {
          updateDataBitDisplay('');
          return;
        }

        const { max, min } = updateDataBitDisplay(text);

        if (max !== null && min !== null) {
          const attributeText = $attributeInput.value.trim();
          if (attributeText && isAutoEnabled) {
            if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
            inputDebounceTimer = setTimeout(async () => {
              await autoSaveAttributeData(attributeText, text);
            }, 1000);
          }

          if (isAutoEnabled && searchTimer) clearTimeout(searchTimer);
          if (isAutoEnabled) {
            searchTimer = setTimeout(() => {
              autoSearch(max, min);
            }, 1000);
          }
        }
      }

      function processAttributeInput(text) {
        if (!text || text.trim() === '') {
          updateAttributeBitDisplay('');
          return;
        }
        updateAttributeBitDisplay(text);
      }

      // GPT ë¶„ì„ ë²„íŠ¼
      $analyzeBtn.addEventListener('click', () => {
        const text = $gptInput.value.trim();
        analyzeWithGPT(text);
      });

      // ë¶„ì„ ê²°ê³¼ ì €ì¥ ë²„íŠ¼
      $saveAnalyzedBtn.addEventListener('click', saveAnalyzedData);

      // ì†ì„± ì…ë ¥ ì´ë²¤íŠ¸
      $attributeInput.addEventListener('input', (e) => {
        const text = e.target.value;
        processAttributeInput(text);
      });

      // ë°ì´í„° ì…ë ¥ ì´ë²¤íŠ¸
      $input.addEventListener('input', (e) => {
        const text = e.target.value;
        updateDataBitDisplay(text);
        if (isAutoEnabled) {
          if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
          inputDebounceTimer = setTimeout(() => {
            if (text !== lastInput) {
              lastInput = text;
              processInput(text);
            }
          }, 500);
        }
      });

      // ì‹¤ì‹œê°„ ì¡°íšŒ ì…ë ¥ ì´ë²¤íŠ¸ (ìë™ ê²€ìƒ‰)
      $searchInput.addEventListener('input', (e) => {
        const text = e.target.value.trim();
        
        // ì‹¤ì‹œê°„ BIT ê³„ì‚° ë° í‘œì‹œ
        const { max, min } = calculateBitValues(text);
        $searchBitMax.textContent = max !== null ? max.toFixed(10) : '-';
        $searchBitMin.textContent = min !== null ? min.toFixed(10) : '-';

        // ë””ë°”ìš´ì‹±ìœ¼ë¡œ ìë™ ê²€ìƒ‰
        if (searchInputTimer) clearTimeout(searchInputTimer);
        
        if (!text || text === '') {
          return;
        }

        searchInputTimer = setTimeout(() => {
          if (text !== lastSearchInput && max !== null && min !== null) {
            lastSearchInput = text;
            autoSearch(max, min, text);
            addOutput(`ğŸ” ì‹¤ì‹œê°„ ì¡°íšŒ: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}" ê²€ìƒ‰ ì‹¤í–‰`, 'info');
          }
        }, 800); // 0.8ì´ˆ í›„ ìë™ ê²€ìƒ‰
      });

      // ì €ì¥ ë²„íŠ¼
      async function saveAttributeData() {
        const attributeText = $attributeInput.value.trim();
        const dataText = $input.value.trim();

        if (!attributeText) {
          $saveStatus.textContent = 'ì†ì„± í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ì…ë ¥í•˜ì„¸ìš”.';
          $saveStatus.style.color = '#dc3545';
          return;
        }

        if (!dataText) {
          $saveStatus.textContent = 'ë°ì´í„° í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”.';
          $saveStatus.style.color = '#dc3545';
          return;
        }

        await autoSaveAttributeData(attributeText, dataText);
      }
      $saveBtn.addEventListener('click', saveAttributeData);

      // ìë™í™” í† ê¸€
      $toggleAutoBtn.addEventListener('click', async () => {
        const isConnected = await testServerConnection();
        if (!isConnected) {
          alert('ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë²„ê°€ http://localhost:8123 ì—ì„œ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.');
          return;
        }

        isAutoEnabled = !isAutoEnabled;
        
        if (isAutoEnabled) {
          $autoStatus.textContent = 'â–¶ï¸ í™œì„±';
          $autoStatus.className = 'auto-status status-active';
          $toggleAutoBtn.textContent = 'ìë™í™” ë¹„í™œì„±í™”';
          
          const text = $input.value.trim();
          if (text) {
            processInput(text);
          }
        } else {
          $autoStatus.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
          $autoStatus.className = 'auto-status status-paused';
          $toggleAutoBtn.textContent = 'ìë™í™” í™œì„±í™”';
          
          if (inputDebounceTimer) clearTimeout(inputDebounceTimer);
          if (searchTimer) clearTimeout(searchTimer);
        }
      });

      // ì¶œë ¥ ì§€ìš°ê¸°
      $clearOutputBtn.addEventListener('click', () => {
        $realtimeOutput.innerHTML = '';
      });

      // ì´ˆê¸°í™”
      addOutput('GPT AI ìë™í™” ì‹œìŠ¤í…œì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
    })();
    </script>
</body>
</html>

